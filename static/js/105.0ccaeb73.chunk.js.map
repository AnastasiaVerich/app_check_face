{"version":3,"file":"static/js/105.0ccaeb73.chunk.js","mappings":"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","sources":["../node_modules/@vladmandic/face-api/dist|sync","utils/faceUtils.ts","components/CameraSection/CameraSection.tsx","hooks/useFaceDetection.ts"],"sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 291;\nmodule.exports = webpackEmptyContext;","export interface Circle {\r\n    cx: number; // Координата X центра круга\r\n    cy: number; // Координата Y центра круга\r\n    r: number;  // Радиус круга\r\n}\r\n\r\nexport interface Rectangle {\r\n    x: number;     // Координата X верхнего левого угла прямоугольника\r\n    y: number;     // Координата Y верхнего левого угла прямоугольника\r\n    width: number; // Ширина прямоугольника\r\n    height: number; // Высота прямоугольника\r\n}\r\n\r\n// Функция для проверки, перекрывает ли прямоугольник круг, с учетом порогового значения (threshold)\r\nexport function isRectangleCoveredByCircle(circle: Circle, rect: Rectangle, threshold = 0.8): boolean {\r\n\r\n    // Вычисляем площадь прямоугольника\r\n    const rectArea = rect.width * rect.height;\r\n    // Вычисляем площадь круга\r\n    const circleArea = Math.PI * circle.r * circle.r;\r\n\r\n    // Проверяем, чтобы прямоугольник не был слишком маленьким ( в 5 раз и более)\r\n    if (rectArea*5 < circleArea) {\r\n        return false;\r\n    }\r\n\r\n    // Вычисляем площадь пересечения прямоугольника и круга\r\n    const intersectionArea = calculateIntersectionArea(circle, rect);\r\n\r\n    // Рассчитываем долю пересекающейся площади (отношение площади пересечения к площади прямоугольника)\r\n    const overlapRatio = intersectionArea / rectArea;\r\n\r\n    // Координаты центра прямоугольника\r\n    const rectCenterX = rect.x + rect.width / 2; // Центр прямоугольника по оси X\r\n    const rectCenterY = rect.y + rect.height / 2; // Центр прямоугольника по оси Y\r\n\r\n    // Проверяем, находится ли центр прямоугольника внутри круга\r\n    const dx = rectCenterX - circle.cx; // Расстояние по оси X от центра прямоугольника до центра круга\r\n    const dy = rectCenterY - circle.cy; // Расстояние по оси Y от центра прямоугольника до центра круга\r\n    const distanceSquared = dx * dx + dy * dy; // Квадрат расстояния между центрами прямоугольника и круга\r\n\r\n    // Проверка, лежит ли центр прямоугольника внутри круга (по формуле расстояния между точками)\r\n    const isCenterInsideCircle = distanceSquared <= circle.r * circle.r;\r\n\r\n    // Проверка, лежит ли центр прямоугольника в пределах маленького радиуса (для дополнительной проверки)\r\n    const smallR = circle.r / 4; // Маленький радиус (четверть от радиуса круга)\r\n    const isCenterWithinSmallRadius = distanceSquared <= (smallR) * (circle.r / 2); // Проверяем, лежит ли центр внутри маленького круга\r\n\r\n    // Возвращаем true, если доля пересечения больше порогового значения, центр прямоугольника внутри круга\r\n    // и центр прямоугольника находится в пределах маленького радиуса\r\n    return overlapRatio >= threshold && isCenterInsideCircle && isCenterWithinSmallRadius;\r\n}\r\n\r\n// Функция для вычисления площади пересечения круга и прямоугольника\r\nfunction calculateIntersectionArea(circle: Circle, rect: Rectangle): number {\r\n    const { cx, cy, r } = circle; // Извлекаем параметры круга\r\n    const { x, y, width, height } = rect; // Извлекаем параметры прямоугольника\r\n\r\n    // Шаг для численного расчета площади пересечения (меньший шаг - более точный расчет)\r\n    const step = Math.min(width, height) / 100;\r\n    let intersectionArea = 0;// Переменная для хранения площади пересечения\r\n\r\n    // Перебираем все точки внутри прямоугольника с шагом step по осям X и Y\r\n    for (let px = x; px <= x + width; px += step) {\r\n        for (let py = y; py <= y + height; py += step) {\r\n            // Проверяем, находится ли точка внутри круга\r\n            const dx = px - cx; // Расстояние по оси X от точки до центра круга\r\n            const dy = py - cy; // Расстояние по оси Y от точки до центра круга\r\n            if (dx * dx + dy * dy <= r * r) {\r\n                // Если точка лежит внутри круга, увеличиваем площадь пересечения\r\n                intersectionArea += step * step; // Добавляем площадь соответствующего квадрата\r\n            }\r\n        }\r\n    }\r\n    // Возвращаем вычисленную площадь пересечения\r\n    return intersectionArea;\r\n}\r\n","import React, {Suspense, useEffect, useState} from \"react\";\r\nimport './CameraSection.css'\r\nimport {Section} from \"../../shared/ui/Section/Section\";\r\nimport {HStack} from \"../../shared/ui/HStack/HStack\";\r\nimport {Text} from \"../../shared/ui/Text/Text\";\r\nimport {CAMERA_DESC, TAKE_PHOTO} from \"../../types/const\";\r\nimport {Svg} from \"../../shared/ui/Svg/Svg\";\r\nimport {CommonSection} from \"../../shared/ui/CommonSection/CommonSection\";\r\nimport {ReactComponent as CameraSvg} from '../../shared/assets/svg/Camea.svg'\r\nimport {ReactComponent as ArrowSvg} from '../../shared/assets/svg/Arrow.svg'\r\nimport {useFaceDetection} from \"../../hooks/useFaceDetection\";\r\n\r\n\r\ninterface CameraProps {\r\n    videoBorderRef: React.RefObject<HTMLDivElement>;\r\n    videoRef: React.RefObject<HTMLVideoElement>; // Ссылка на элемент video, который будет показывать видео с камеры\r\n    canvasRef: React.RefObject<HTMLCanvasElement>; // Ссылка на элемент canvas, на котором будет отображаться сделанное фото\r\n    setError: any,    // Признак, что лицо было обнаружено на видео\r\n\r\n    setPhotoUrl: any, // Функция для установки URL снимка (состояние для изображения)\r\n    streamRef: any\r\n    setIsCameraOn: any\r\n    isCameraOn: any\r\n}\r\n\r\nconst CameraSection: React.FC<CameraProps> = ({\r\n                                                  setPhotoUrl,\r\n                                                  streamRef,\r\n                                                  isCameraOn,\r\n                                                  setIsCameraOn,\r\n                                                  setError,\r\n                                                  videoBorderRef,\r\n                                                  videoRef,\r\n                                                  canvasRef\r\n                                              }) => {\r\n    const [isLoaded, setIsLoaded] = useState(false);\r\n\r\n    const {\r\n        isFaceDetected,\r\n    } = useFaceDetection(isCameraOn, videoRef, canvasRef, videoBorderRef)\r\n\r\n    const handleVideoLoaded = () => {\r\n        setTimeout(() => {\r\n            setIsLoaded(true);\r\n        }, 0)\r\n\r\n    };\r\n\r\n    useEffect(() => {\r\n        const startVideo = async () => {\r\n            try {\r\n                // Получаем доступ к камере с использованием API getUserMedia\r\n                const stream = await navigator.mediaDevices.getUserMedia({\r\n                    video: {facingMode: \"user\"}, // Запрашиваем видео с камеры пользователя (фронтальная)\r\n                });\r\n                streamRef.current = stream; // Сохраняем поток для управления (для остановки камеры)\r\n                if (videoRef.current) videoRef.current.srcObject = stream;// Отображаем поток в элементе video\r\n                setPhotoUrl(null); // Обнуляем URL снимка (если камера включена, не показываем старое фото)\r\n                setError(null); // Очищаем ошибку, если она была\r\n            } catch (err) {\r\n                // Если не удалось получить доступ к камере, выводим ошибку\r\n                setError(\"Ошибка доступа к камере\");\r\n                console.error(err);\r\n            }\r\n        }\r\n        startVideo()\r\n    }, [])\r\n\r\n    const takePhoto = () => {\r\n        if (canvasRef.current && videoRef.current) {\r\n            const canvas = canvasRef.current; // Получаем ссылку на канвас\r\n            const context = canvas.getContext(\"2d\"); // Получаем контекст рисования канваса\r\n            if (context) {\r\n                // Устанавливаем размеры канваса, чтобы они соответствовали видео\r\n                canvas.width = videoRef.current.videoWidth;\r\n                canvas.height = videoRef.current.videoHeight;\r\n                // Рисуем изображение с видео на канвасе\r\n                context.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\r\n                // Устанавливаем фото как DataURL с форматом JPEG\r\n                setPhotoUrl(canvas.toDataURL(\"image/jpeg\"));\r\n            } else {\r\n                setPhotoUrl(null) // Если не удалось сделать снимок, сбрасываем URL\r\n                if (streamRef.current) {\r\n\r\n                    // Останавливаем все треки (видео и аудио), связанные с камерой\r\n                    streamRef.current.getTracks().forEach((track: { stop: () => any; }) => track.stop());\r\n                }\r\n            }\r\n        } else {\r\n            setPhotoUrl(null) // Если не удалось сделать снимок, сбрасываем URL\r\n            if (streamRef.current) {\r\n\r\n                // Останавливаем все треки (видео и аудио), связанные с камерой\r\n                streamRef.current.getTracks().forEach((track: { stop: () => any; }) => track.stop());\r\n            }\r\n        }\r\n\r\n        setIsCameraOn(false);\r\n    };\r\n    return (\r\n        <CommonSection\r\n            max\r\n        >\r\n            <Section className={`video_box ${isLoaded ? '' : 'hide'}`}>\r\n\r\n                <video\r\n                    className=\"video_online\"\r\n                    ref={videoRef}\r\n                    playsInline\r\n                    autoPlay\r\n                    muted\r\n                    controls={false}\r\n                    onLoadedMetadata={handleVideoLoaded}\r\n                />\r\n                <div ref={videoBorderRef} className=\"video_box__wrapper\"/>\r\n                <canvas\r\n                    ref={canvasRef}\r\n                    className={'canvas'}\r\n                />\r\n                {/* Оверлей для отображения информации о распознавании лица */}\r\n                <div\r\n                    className={`face_overlay ${isFaceDetected ? 'ok' : 'err'}`}\r\n\r\n                />\r\n            </Section>\r\n            <Section max>\r\n                <HStack max>\r\n                    <Text\r\n                        text={CAMERA_DESC}\r\n                        type={'text'}\r\n                        max\r\n                    />\r\n                </HStack>\r\n            </Section>\r\n            <Section\r\n                clickable\r\n                max\r\n                onClick={takePhoto}\r\n                disabled={!isFaceDetected}\r\n            >\r\n                <HStack gap={'10'} max>\r\n                    <Svg Svg={CameraSvg}/>\r\n                    <Text\r\n                        text={TAKE_PHOTO}\r\n                        type={'text'}\r\n                        max\r\n                    />\r\n                    <Svg width={'12px'} height={'12px'} color={'subtitle'} Svg={ArrowSvg}/>\r\n                </HStack>\r\n\r\n            </Section>\r\n        </CommonSection>\r\n    );\r\n};\r\n\r\nexport default CameraSection\r\n","import {useState, useEffect} from \"react\";\r\nimport {\r\n    nets, matchDimensions,\r\n    TinyFaceDetectorOptions,\r\n    detectAllFaces,\r\n    resizeResults\r\n} from \"@vladmandic/face-api\";\r\nimport {Circle, isRectangleCoveredByCircle, Rectangle} from \"../utils/faceUtils\";\r\n\r\nexport const useFaceDetection = (\r\n    isCameraOn: boolean, // Пропс, который говорит, включена ли камера\r\n    videoRef: React.RefObject<HTMLVideoElement>, // Ссылка на элемент video, который будет показывать видео с камеры\r\n    canvasRef: React.RefObject<HTMLCanvasElement>, // Ссылка на элемент canvas, на котором будет отображаться сделанное фото\r\n    videoBorderRef: React.RefObject<HTMLDivElement>\r\n) => {\r\n    const [isFaceDetected, setIsFaceDetected] = useState(false);// Состояние для отслеживания, было ли найдено лицо\r\n    const [modelsLoaded, setModelsLoaded] = useState(false);// Состояние для отслеживания, загружены ли модели\r\n    const [isDraw] = useState(false);// Состояние для отслеживания, загружены ли модели\r\n\r\n    // Загружаем модели детекции лиц при монтировании компонента\r\n    useEffect(() => {\r\n        const loadModels = async () => {\r\n            const MODEL_URL = \"ia_models\"; // Путь к моделям (например, на сервере)\r\n            await Promise.all([\r\n                nets.tinyFaceDetector.loadFromUri(MODEL_URL),\r\n            ]);\r\n            setModelsLoaded(true);\r\n        };\r\n        loadModels(); // Вызываем функцию загрузки моделей\r\n    }, []);\r\n\r\n    // Детекция лиц\r\n    useEffect(() => {\r\n        let interval: any\r\n        // Если модели загружены и камера включена\r\n        if (modelsLoaded && isCameraOn) {\r\n            const detectFace = async () => {\r\n                if (videoRef.current && canvasRef.current && videoBorderRef.current) { // Если video и canvas элементы существуют\r\n                    const video = videoRef.current;\r\n                    const canvas = canvasRef.current;\r\n                    const video_border = videoBorderRef.current;\r\n\r\n                    // Настроим размеры канваса, чтобы он соответствовал размеру видео\r\n                    const displaySize = {\r\n                        width: video_border.offsetWidth,\r\n                        height: video_border.offsetHeight\r\n                    };\r\n                    // Настроим канвас для масштабирования детекций\r\n                    matchDimensions(canvas, displaySize);\r\n\r\n                    // Детекция всех лиц с использованием опций для детектора\r\n                    const options = new TinyFaceDetectorOptions({inputSize: 416, scoreThreshold: 0.3});\r\n                    const detections = await detectAllFaces(video, options); // Получаем все обнаруженные лица на видео\r\n                    const resizedDetections = resizeResults(detections, displaySize); // Масштабируем результаты детекции под размер видео\r\n\r\n                    let ctx: any = null\r\n                    if (isDraw) {\r\n                        ctx = canvas.getContext('2d');\r\n                        if (!ctx) return\r\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n                    }\r\n\r\n\r\n                    // Проверяем, попадает ли лицо в оверлей\r\n                    const circle: Circle = {cx: canvas.clientWidth / 2, cy: canvas.clientHeight / 2, r: 150}; // Создаем круг в центре видео с радиусом 150px\r\n\r\n                    let faceDetected = false// Флаг для проверки, было ли найдено лицо в области круга\r\n                    resizedDetections.forEach((detection) => {\r\n                            // Извлекаем информацию о прямоугольнике, в котором расположено лицо\r\n                            const {x, y, width, height} = detection.box;\r\n                            // Если применен scaleX(-1), нужно скорректировать координаты\r\n                            const transformedX = canvas.clientWidth - (x + width);\r\n                            //const rectangle: Rectangle = {x: transformedX, y, width, height};\r\n                            const rectangle: Rectangle = {x: transformedX, y, width, height}\r\n\r\n                            // Проверяем, перекрывает ли прямоугольник (лицо) круг более чем на 80%\r\n                            // И что бы круг был не больше чем в 5 раз больше прямоугольник , инчае слишко далеко лицо\r\n                            faceDetected = isRectangleCoveredByCircle(circle, rectangle, 0.8)\r\n                            if (isDraw && ctx) {\r\n                                // Рисуем рамку\r\n                                ctx.lineWidth = 4;\r\n                                ctx.lineCap = 'square';\r\n                                ctx.lineJoin = 'bevel';\r\n                                ctx.strokeStyle = '#5199d9';\r\n\r\n\r\n                                //ctx.strokeRect(transformedX, y, width, height);\r\n                                ctx.strokeRect(transformedX, y, width, height);\r\n                            }\r\n                        }\r\n                    );\r\n                    setIsFaceDetected(faceDetected);\r\n                    if (isDraw && ctx) {\r\n                        ctx.beginPath();\r\n                        ctx.arc(circle.cx, circle.cy, circle.r, 0, 2 * Math.PI); // Рисуем круг\r\n                        ctx.fillStyle = faceDetected ? 'transparent' : 'transparent'; // Зеленый если лицо внутри круга, красный если нет\r\n                        ctx.fill();\r\n                        ctx.lineWidth = 4;\r\n                        ctx.strokeStyle = faceDetected ? 'green' : 'red';\r\n                        ctx.stroke();\r\n                    }\r\n                }\r\n            };\r\n\r\n            interval = setInterval(detectFace, 100);// Запускаем детекцию лиц каждые 100 миллисекунд\r\n        }\r\n        return () => clearInterval(interval); // Останавливаем детекцию при размонтировании компонента\r\n\r\n    }, [modelsLoaded, isCameraOn]);\r\n\r\n    return {isFaceDetected, modelsLoaded};\r\n};\r\n"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","id","module","exports","isRectangleCoveredByCircle","circle","rect","threshold","arguments","length","undefined","rectArea","width","height","Math","PI","r","intersectionArea","cx","cy","x","y","step","min","px","py","dx","dy","calculateIntersectionArea","overlapRatio","rectCenterX","rectCenterY","distanceSquared","isCenterInsideCircle","isCenterWithinSmallRadius","_ref","setPhotoUrl","streamRef","isCameraOn","setIsCameraOn","setError","videoBorderRef","videoRef","canvasRef","isLoaded","setIsLoaded","useState","isFaceDetected","useFaceDetection","setIsFaceDetected","modelsLoaded","setModelsLoaded","isDraw","useEffect","async","Promise","all","nets","tinyFaceDetector","loadFromUri","loadModels","interval","setInterval","current","video","canvas","video_border","displaySize","offsetWidth","offsetHeight","matchDimensions","options","TinyFaceDetectorOptions","inputSize","scoreThreshold","detections","detectAllFaces","resizedDetections","resizeResults","ctx","getContext","clearRect","clientWidth","clientHeight","faceDetected","forEach","detection","box","transformedX","lineWidth","lineCap","lineJoin","strokeStyle","strokeRect","beginPath","arc","fillStyle","fill","stroke","clearInterval","stream","navigator","mediaDevices","getUserMedia","facingMode","srcObject","err","console","error","startVideo","_jsxs","CommonSection","max","children","Section","className","_jsx","ref","playsInline","autoPlay","muted","controls","onLoadedMetadata","handleVideoLoaded","setTimeout","HStack","Text","text","CAMERA_DESC","type","clickable","onClick","takePhoto","context","videoWidth","videoHeight","drawImage","toDataURL","getTracks","track","stop","disabled","gap","Svg","CameraSvg","TAKE_PHOTO","color","ArrowSvg"],"sourceRoot":""}