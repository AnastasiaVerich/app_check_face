/*! For license information please see main.311e6a28.js.LICENSE.txt */
(()=>{var e={291:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=291,e.exports=t},730:(e,t,n)=>{"use strict";var r=n(43),a=n(853);function i(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var s=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)s.add(t[e])}var d=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),c=Object.prototype.hasOwnProperty,p=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,h={},f={};function m(e,t,n,r,a,i,s){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=i,this.removeEmptyString=s}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function v(e,t,n,r){var a=g.hasOwnProperty(t)?g[t]:null;(null!==a?0!==a.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null===t||"undefined"===typeof t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,a,r)&&(n=null),r||null===a?function(e){return!!c.call(f,e)||!c.call(h,e)&&(p.test(e)?f[e]=!0:(h[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=null===n?3!==a.type&&"":n:(t=a.attributeName,r=a.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var x=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),T=Symbol.for("react.provider"),_=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),A=Symbol.for("react.suspense_list"),$=Symbol.for("react.memo"),R=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var F=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function M(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var O,P=Object.assign;function L(e){if(void 0===O)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);O=t&&t[1]||""}return"\n"+O+e}var z=!1;function B(e,t){if(!e||z)return"";z=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&"string"===typeof u.stack){for(var a=u.stack.split("\n"),i=r.stack.split("\n"),s=a.length-1,o=i.length-1;1<=s&&0<=o&&a[s]!==i[o];)o--;for(;1<=s&&0<=o;s--,o--)if(a[s]!==i[o]){if(1!==s||1!==o)do{if(s--,0>--o||a[s]!==i[o]){var l="\n"+a[s].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=s&&0<=o);break}}}finally{z=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?L(e):""}function W(e){switch(e.tag){case 5:return L(e.type);case 16:return L("Lazy");case 13:return L("Suspense");case 19:return L("SuspenseList");case 0:case 2:case 15:return e=B(e.type,!1);case 11:return e=B(e.type.render,!1);case 1:return e=B(e.type,!0);default:return""}}function U(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case N:return"Profiler";case I:return"StrictMode";case E:return"Suspense";case A:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case _:return(e.displayName||"Context")+".Consumer";case T:return(e._context.displayName||"Context")+".Provider";case C:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case $:return null!==(t=e.displayName||null)?t:U(e.type)||"Memo";case R:t=e._payload,e=e._init;try{return U(e(t))}catch(n){}}return null}function V(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return U(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function G(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function H(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function j(e){e._valueTracker||(e._valueTracker=function(e){var t=H(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,i=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,i.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=H(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function K(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function X(e,t){var n=t.checked;return P({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=G(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&v(e,"checked",t,!1)}function J(e,t){Q(e,t);var n=G(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,G(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Z(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&K(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+G(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(i(91));return P({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ae(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(i(92));if(te(n)){if(1<n.length)throw Error(i(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:G(n)}}function ie(e,t){var n=G(t.value),r=G(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function se(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,de,ce=(de=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return de(e,t)}))}:de);function pe(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var he={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||he.hasOwnProperty(e)&&he[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=me(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}Object.keys(he).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),he[t]=he[e]}))}));var ye=P({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(i(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(i(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(i(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(i(62))}}function ve(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xe=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Ne(e){if(e=va(e)){if("function"!==typeof ke)throw Error(i(280));var t=e.stateNode;t&&(t=wa(t),ke(e.stateNode,e.type,t))}}function Te(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function _e(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Ne(e),t)for(e=0;e<t.length;e++)Ne(t[e])}}function Ce(e,t){return e(t)}function Ee(){}var Ae=!1;function $e(e,t,n){if(Ae)return e(t,n);Ae=!0;try{return Ce(e,t,n)}finally{Ae=!1,(null!==Se||null!==Ie)&&(Ee(),_e())}}function Re(e,t){var n=e.stateNode;if(null===n)return null;var r=wa(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(i(231,t,typeof n));return n}var Fe=!1;if(d)try{var De={};Object.defineProperty(De,"passive",{get:function(){Fe=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(de){Fe=!1}function Me(e,t,n,r,a,i,s,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(d){this.onError(d)}}var Oe=!1,Pe=null,Le=!1,ze=null,Be={onError:function(e){Oe=!0,Pe=e}};function We(e,t,n,r,a,i,s,o,l){Oe=!1,Pe=null,Me.apply(Be,arguments)}function Ue(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ve(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function Ge(e){if(Ue(e)!==e)throw Error(i(188))}function He(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ue(e)))throw Error(i(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var s=a.alternate;if(null===s){if(null!==(r=a.return)){n=r;continue}break}if(a.child===s.child){for(s=a.child;s;){if(s===n)return Ge(a),e;if(s===r)return Ge(a),t;s=s.sibling}throw Error(i(188))}if(n.return!==r.return)n=a,r=s;else{for(var o=!1,l=a.child;l;){if(l===n){o=!0,n=a,r=s;break}if(l===r){o=!0,r=a,n=s;break}l=l.sibling}if(!o){for(l=s.child;l;){if(l===n){o=!0,n=s,r=a;break}if(l===r){o=!0,r=s,n=a;break}l=l.sibling}if(!o)throw Error(i(189))}}if(n.alternate!==r)throw Error(i(190))}if(3!==n.tag)throw Error(i(188));return n.stateNode.current===n?e:t}(e))?je(e):null}function je(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=je(e);if(null!==t)return t;e=e.sibling}return null}var qe=a.unstable_scheduleCallback,Ke=a.unstable_cancelCallback,Xe=a.unstable_shouldYield,Ye=a.unstable_requestPaint,Qe=a.unstable_now,Je=a.unstable_getCurrentPriorityLevel,Ze=a.unstable_ImmediatePriority,et=a.unstable_UserBlockingPriority,tt=a.unstable_NormalPriority,nt=a.unstable_LowPriority,rt=a.unstable_IdlePriority,at=null,it=null;var st=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2;var ut=64,dt=4194304;function ct(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function pt(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,a=e.suspendedLanes,i=e.pingedLanes,s=268435455&n;if(0!==s){var o=s&~a;0!==o?r=ct(o):0!==(i&=s)&&(r=ct(i))}else 0!==(s=n&~a)?r=ct(s):0!==i&&(r=ct(i));if(0===r)return 0;if(0!==t&&t!==r&&0===(t&a)&&((a=r&-r)>=(i=t&-t)||16===a&&0!==(4194240&i)))return t;if(0!==(4&r)&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)a=1<<(n=31-st(t)),r|=e[n],t&=~a;return r}function ht(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=ut;return 0===(4194240&(ut<<=1))&&(ut=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-st(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-st(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var vt=0;function xt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,It,Nt,Tt=!1,_t=[],Ct=null,Et=null,At=null,$t=new Map,Rt=new Map,Ft=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Mt(e,t){switch(e){case"focusin":case"focusout":Ct=null;break;case"dragenter":case"dragleave":Et=null;break;case"mouseover":case"mouseout":At=null;break;case"pointerover":case"pointerout":$t.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Rt.delete(t.pointerId)}}function Ot(e,t,n,r,a,i){return null===e||e.nativeEvent!==i?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:i,targetContainers:[a]},null!==t&&(null!==(t=va(t))&&kt(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function Pt(e){var t=ba(e.target);if(null!==t){var n=Ue(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ve(n)))return e.blockedOn=t,void Nt(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Lt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Xt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=va(n))&&kt(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);xe=r,n.target.dispatchEvent(r),xe=null,t.shift()}return!0}function zt(e,t,n){Lt(e)&&n.delete(t)}function Bt(){Tt=!1,null!==Ct&&Lt(Ct)&&(Ct=null),null!==Et&&Lt(Et)&&(Et=null),null!==At&&Lt(At)&&(At=null),$t.forEach(zt),Rt.forEach(zt)}function Wt(e,t){e.blockedOn===t&&(e.blockedOn=null,Tt||(Tt=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,Bt)))}function Ut(e){function t(t){return Wt(t,e)}if(0<_t.length){Wt(_t[0],e);for(var n=1;n<_t.length;n++){var r=_t[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==Ct&&Wt(Ct,e),null!==Et&&Wt(Et,e),null!==At&&Wt(At,e),$t.forEach(t),Rt.forEach(t),n=0;n<Ft.length;n++)(r=Ft[n]).blockedOn===e&&(r.blockedOn=null);for(;0<Ft.length&&null===(n=Ft[0]).blockedOn;)Pt(n),null===n.blockedOn&&Ft.shift()}var Vt=x.ReactCurrentBatchConfig,Gt=!0;function Ht(e,t,n,r){var a=vt,i=Vt.transition;Vt.transition=null;try{vt=1,qt(e,t,n,r)}finally{vt=a,Vt.transition=i}}function jt(e,t,n,r){var a=vt,i=Vt.transition;Vt.transition=null;try{vt=4,qt(e,t,n,r)}finally{vt=a,Vt.transition=i}}function qt(e,t,n,r){if(Gt){var a=Xt(e,t,n,r);if(null===a)Gr(e,t,r,Kt,n),Mt(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return Ct=Ot(Ct,e,t,n,r,a),!0;case"dragenter":return Et=Ot(Et,e,t,n,r,a),!0;case"mouseover":return At=Ot(At,e,t,n,r,a),!0;case"pointerover":var i=a.pointerId;return $t.set(i,Ot($t.get(i)||null,e,t,n,r,a)),!0;case"gotpointercapture":return i=a.pointerId,Rt.set(i,Ot(Rt.get(i)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(Mt(e,r),4&t&&-1<Dt.indexOf(e)){for(;null!==a;){var i=va(a);if(null!==i&&wt(i),null===(i=Xt(e,t,n,r))&&Gr(e,t,r,Kt,n),i===a)break;a=i}null!==a&&r.stopPropagation()}else Gr(e,t,r,null,n)}}var Kt=null;function Xt(e,t,n,r){if(Kt=null,null!==(e=ba(e=we(r))))if(null===(t=Ue(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ve(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Kt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Je()){case Ze:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Qt=null,Jt=null,Zt=null;function en(){if(Zt)return Zt;var e,t,n=Jt,r=n.length,a="value"in Qt?Qt.value:Qt.textContent,i=a.length;for(e=0;e<r&&n[e]===a[e];e++);var s=r-e;for(t=1;t<=s&&n[r-t]===a[i-t];t++);return Zt=a.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function an(e){function t(t,n,r,a,i){for(var s in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=i,this.currentTarget=null,e)e.hasOwnProperty(s)&&(t=e[s],this[s]=t?t(a):a[s]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return P(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var sn,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},dn=an(un),cn=P({},un,{view:0,detail:0}),pn=an(cn),hn=P({},cn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(sn=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=sn=0,ln=e),sn)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=an(hn),mn=an(P({},hn,{dataTransfer:0})),gn=an(P({},cn,{relatedTarget:0})),yn=an(P({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=P({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),vn=an(bn),xn=an(P({},un,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Nn(){return In}var Tn=P({},cn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),_n=an(Tn),Cn=an(P({},hn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),En=an(P({},cn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),An=an(P({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),$n=P({},hn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Rn=an($n),Fn=[9,13,27,32],Dn=d&&"CompositionEvent"in window,Mn=null;d&&"documentMode"in document&&(Mn=document.documentMode);var On=d&&"TextEvent"in window&&!Mn,Pn=d&&(!Dn||Mn&&8<Mn&&11>=Mn),Ln=String.fromCharCode(32),zn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==Fn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Un=!1;var Vn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Gn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Vn[e.type]:"textarea"===t}function Hn(e,t,n,r){Te(r),0<(t=jr(t,"onChange")).length&&(n=new dn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var jn=null,qn=null;function Kn(e){Lr(e,0)}function Xn(e){if(q(xa(e)))return e}function Yn(e,t){if("change"===e)return t}var Qn=!1;if(d){var Jn;if(d){var Zn="oninput"in document;if(!Zn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Zn="function"===typeof er.oninput}Jn=Zn}else Jn=!1;Qn=Jn&&(!document.documentMode||9<document.documentMode)}function tr(){jn&&(jn.detachEvent("onpropertychange",nr),qn=jn=null)}function nr(e){if("value"===e.propertyName&&Xn(qn)){var t=[];Hn(t,qn,e,we(e)),$e(Kn,t)}}function rr(e,t,n){"focusin"===e?(tr(),qn=n,(jn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function ar(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Xn(qn)}function ir(e,t){if("click"===e)return Xn(t)}function sr(e,t){if("input"===e||"change"===e)return Xn(t)}var or="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function lr(e,t){if(or(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!c.call(t,a)||!or(e[a],t[a]))return!1}return!0}function ur(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function dr(e,t){var n,r=ur(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ur(r)}}function cr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?cr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function pr(){for(var e=window,t=K();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=K((e=t.contentWindow).document)}return t}function hr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=pr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&cr(n.ownerDocument.documentElement,n)){if(null!==r&&hr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var a=n.textContent.length,i=Math.min(r.start,a);r=void 0===r.end?i:Math.min(r.end,a),!e.extend&&i>r&&(a=r,r=i,i=a),a=dr(n,i);var s=dr(n,r);a&&s&&(1!==e.rangeCount||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==s.node||e.focusOffset!==s.offset)&&((t=t.createRange()).setStart(a.node,a.offset),e.removeAllRanges(),i>r?(e.addRange(t),e.extend(s.node,s.offset)):(t.setEnd(s.node,s.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mr=d&&"documentMode"in document&&11>=document.documentMode,gr=null,yr=null,br=null,vr=!1;function xr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==gr||gr!==K(r)||("selectionStart"in(r=gr)&&hr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},br&&lr(br,r)||(br=r,0<(r=jr(yr,"onSelect")).length&&(t=new dn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=gr)))}function wr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var kr={animationend:wr("Animation","AnimationEnd"),animationiteration:wr("Animation","AnimationIteration"),animationstart:wr("Animation","AnimationStart"),transitionend:wr("Transition","TransitionEnd")},Sr={},Ir={};function Nr(e){if(Sr[e])return Sr[e];if(!kr[e])return e;var t,n=kr[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ir)return Sr[e]=n[t];return e}d&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Tr=Nr("animationend"),_r=Nr("animationiteration"),Cr=Nr("animationstart"),Er=Nr("transitionend"),Ar=new Map,$r="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Rr(e,t){Ar.set(e,t),l(t,[e])}for(var Fr=0;Fr<$r.length;Fr++){var Dr=$r[Fr];Rr(Dr.toLowerCase(),"on"+(Dr[0].toUpperCase()+Dr.slice(1)))}Rr(Tr,"onAnimationEnd"),Rr(_r,"onAnimationIteration"),Rr(Cr,"onAnimationStart"),Rr("dblclick","onDoubleClick"),Rr("focusin","onFocus"),Rr("focusout","onBlur"),Rr(Er,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Mr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Or=new Set("cancel close invalid load scroll toggle".split(" ").concat(Mr));function Pr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,a,s,o,l,u){if(We.apply(this,arguments),Oe){if(!Oe)throw Error(i(198));var d=Pe;Oe=!1,Pe=null,Le||(Le=!0,ze=d)}}(r,t,void 0,e),e.currentTarget=null}function Lr(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var i=void 0;if(t)for(var s=r.length-1;0<=s;s--){var o=r[s],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==i&&a.isPropagationStopped())break e;Pr(a,o,u),i=l}else for(s=0;s<r.length;s++){if(l=(o=r[s]).instance,u=o.currentTarget,o=o.listener,l!==i&&a.isPropagationStopped())break e;Pr(a,o,u),i=l}}}if(Le)throw e=ze,Le=!1,ze=null,e}function zr(e,t){var n=t[ma];void 0===n&&(n=t[ma]=new Set);var r=e+"__bubble";n.has(r)||(Vr(t,e,2,!1),n.add(r))}function Br(e,t,n){var r=0;t&&(r|=4),Vr(n,e,r,t)}var Wr="_reactListening"+Math.random().toString(36).slice(2);function Ur(e){if(!e[Wr]){e[Wr]=!0,s.forEach((function(t){"selectionchange"!==t&&(Or.has(t)||Br(t,!1,e),Br(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Wr]||(t[Wr]=!0,Br("selectionchange",!1,t))}}function Vr(e,t,n,r){switch(Yt(t)){case 1:var a=Ht;break;case 4:a=jt;break;default:a=qt}n=a.bind(null,t,n,e),a=void 0,!Fe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Gr(e,t,n,r,a){var i=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var s=r.tag;if(3===s||4===s){var o=r.stateNode.containerInfo;if(o===a||8===o.nodeType&&o.parentNode===a)break;if(4===s)for(s=r.return;null!==s;){var l=s.tag;if((3===l||4===l)&&((l=s.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;s=s.return}for(;null!==o;){if(null===(s=ba(o)))return;if(5===(l=s.tag)||6===l){r=i=s;continue e}o=o.parentNode}}r=r.return}$e((function(){var r=i,a=we(n),s=[];e:{var o=Ar.get(e);if(void 0!==o){var l=dn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=_n;break;case"focusin":u="focus",l=gn;break;case"focusout":u="blur",l=gn;break;case"beforeblur":case"afterblur":l=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=En;break;case Tr:case _r:case Cr:l=yn;break;case Er:l=An;break;case"scroll":l=pn;break;case"wheel":l=Rn;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Cn}var d=0!==(4&t),c=!d&&"scroll"===e,p=d?null!==o?o+"Capture":null:o;d=[];for(var h,f=r;null!==f;){var m=(h=f).stateNode;if(5===h.tag&&null!==m&&(h=m,null!==p&&(null!=(m=Re(f,p))&&d.push(Hr(f,m,h)))),c)break;f=f.return}0<d.length&&(o=new l(o,u,null,n,a),s.push({event:o,listeners:d}))}}if(0===(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===xe||!(u=n.relatedTarget||n.fromElement)||!ba(u)&&!u[fa])&&(l||o)&&(o=a.window===a?a:(o=a.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?ba(u):null)&&(u!==(c=Ue(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(d=fn,m="onMouseLeave",p="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(d=Cn,m="onPointerLeave",p="onPointerEnter",f="pointer"),c=null==l?o:xa(l),h=null==u?o:xa(u),(o=new d(m,f+"leave",l,n,a)).target=c,o.relatedTarget=h,m=null,ba(a)===r&&((d=new d(p,f+"enter",u,n,a)).target=h,d.relatedTarget=c,m=d),c=m,l&&u)e:{for(p=u,f=0,h=d=l;h;h=qr(h))f++;for(h=0,m=p;m;m=qr(m))h++;for(;0<f-h;)d=qr(d),f--;for(;0<h-f;)p=qr(p),h--;for(;f--;){if(d===p||null!==p&&d===p.alternate)break e;d=qr(d),p=qr(p)}d=null}else d=null;null!==l&&Kr(s,o,l,d,!1),null!==u&&null!==c&&Kr(s,c,u,d,!0)}if("select"===(l=(o=r?xa(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Yn;else if(Gn(o))if(Qn)g=sr;else{g=ar;var y=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=ir);switch(g&&(g=g(e,r))?Hn(s,g,n,a):(y&&y(e,o,r),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=r?xa(r):window,e){case"focusin":(Gn(y)||"true"===y.contentEditable)&&(gr=y,yr=r,br=null);break;case"focusout":br=yr=gr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,xr(s,n,a);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":xr(s,n,a)}var b;if(Dn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Un?Bn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Pn&&"ko"!==n.locale&&(Un||"onCompositionStart"!==v?"onCompositionEnd"===v&&Un&&(b=en()):(Jt="value"in(Qt=a)?Qt.value:Qt.textContent,Un=!0)),0<(y=jr(r,v)).length&&(v=new xn(v,e,null,n,a),s.push({event:v,listeners:y}),b?v.data=b:null!==(b=Wn(n))&&(v.data=b))),(b=On?function(e,t){switch(e){case"compositionend":return Wn(t);case"keypress":return 32!==t.which?null:(zn=!0,Ln);case"textInput":return(e=t.data)===Ln&&zn?null:e;default:return null}}(e,n):function(e,t){if(Un)return"compositionend"===e||!Dn&&Bn(e,t)?(e=en(),Zt=Jt=Qt=null,Un=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Pn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(r=jr(r,"onBeforeInput")).length&&(a=new xn("onBeforeInput","beforeinput",null,n,a),s.push({event:a,listeners:r}),a.data=b))}Lr(s,t)}))}function Hr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function jr(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,i=a.stateNode;5===a.tag&&null!==i&&(a=i,null!=(i=Re(e,n))&&r.unshift(Hr(e,i,a)),null!=(i=Re(e,t))&&r.push(Hr(e,i,a))),e=e.return}return r}function qr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Kr(e,t,n,r,a){for(var i=t._reactName,s=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==u&&(o=u,a?null!=(l=Re(n,i))&&s.unshift(Hr(n,l,o)):a||null!=(l=Re(n,i))&&s.push(Hr(n,l,o))),n=n.return}0!==s.length&&e.push({event:t,listeners:s})}var Xr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Qr(e){return("string"===typeof e?e:""+e).replace(Xr,"\n").replace(Yr,"")}function Jr(e,t,n){if(t=Qr(t),Qr(e)!==t&&n)throw Error(i(425))}function Zr(){}var ea=null,ta=null;function na(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,ia="function"===typeof Promise?Promise:void 0,sa="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof ia?function(e){return ia.resolve(null).then(e).catch(oa)}:ra;function oa(e){setTimeout((function(){throw e}))}function la(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return e.removeChild(a),void Ut(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Ut(t)}function ua(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function da(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var ca=Math.random().toString(36).slice(2),pa="__reactFiber$"+ca,ha="__reactProps$"+ca,fa="__reactContainer$"+ca,ma="__reactEvents$"+ca,ga="__reactListeners$"+ca,ya="__reactHandles$"+ca;function ba(e){var t=e[pa];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fa]||n[pa]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=da(e);null!==e;){if(n=e[pa])return n;e=da(e)}return t}n=(e=n).parentNode}return null}function va(e){return!(e=e[pa]||e[fa])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function xa(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(i(33))}function wa(e){return e[ha]||null}var ka=[],Sa=-1;function Ia(e){return{current:e}}function Na(e){0>Sa||(e.current=ka[Sa],ka[Sa]=null,Sa--)}function Ta(e,t){Sa++,ka[Sa]=e.current,e.current=t}var _a={},Ca=Ia(_a),Ea=Ia(!1),Aa=_a;function $a(e,t){var n=e.type.contextTypes;if(!n)return _a;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a,i={};for(a in n)i[a]=t[a];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=i),i}function Ra(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Fa(){Na(Ea),Na(Ca)}function Da(e,t,n){if(Ca.current!==_a)throw Error(i(168));Ta(Ca,t),Ta(Ea,n)}function Ma(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in t))throw Error(i(108,V(e)||"Unknown",a));return P({},n,r)}function Oa(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||_a,Aa=Ca.current,Ta(Ca,e),Ta(Ea,Ea.current),!0}function Pa(e,t,n){var r=e.stateNode;if(!r)throw Error(i(169));n?(e=Ma(e,t,Aa),r.__reactInternalMemoizedMergedChildContext=e,Na(Ea),Na(Ca),Ta(Ca,e)):Na(Ea),Ta(Ea,n)}var La=null,za=!1,Ba=!1;function Wa(e){null===La?La=[e]:La.push(e)}function Ua(){if(!Ba&&null!==La){Ba=!0;var e=0,t=vt;try{var n=La;for(vt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}La=null,za=!1}catch(a){throw null!==La&&(La=La.slice(e+1)),qe(Ze,Ua),a}finally{vt=t,Ba=!1}}return null}var Va=[],Ga=0,Ha=null,ja=0,qa=[],Ka=0,Xa=null,Ya=1,Qa="";function Ja(e,t){Va[Ga++]=ja,Va[Ga++]=Ha,Ha=e,ja=t}function Za(e,t,n){qa[Ka++]=Ya,qa[Ka++]=Qa,qa[Ka++]=Xa,Xa=e;var r=Ya;e=Qa;var a=32-st(r)-1;r&=~(1<<a),n+=1;var i=32-st(t)+a;if(30<i){var s=a-a%5;i=(r&(1<<s)-1).toString(32),r>>=s,a-=s,Ya=1<<32-st(t)+a|n<<a|r,Qa=i+e}else Ya=1<<i|n<<a|r,Qa=e}function ei(e){null!==e.return&&(Ja(e,1),Za(e,1,0))}function ti(e){for(;e===Ha;)Ha=Va[--Ga],Va[Ga]=null,ja=Va[--Ga],Va[Ga]=null;for(;e===Xa;)Xa=qa[--Ka],qa[Ka]=null,Qa=qa[--Ka],qa[Ka]=null,Ya=qa[--Ka],qa[Ka]=null}var ni=null,ri=null,ai=!1,ii=null;function si(e,t){var n=$u(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function oi(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,ni=e,ri=ua(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,ni=e,ri=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Xa?{id:Ya,overflow:Qa}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=$u(18,null,null,0)).stateNode=t,n.return=e,e.child=n,ni=e,ri=null,!0);default:return!1}}function li(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function ui(e){if(ai){var t=ri;if(t){var n=t;if(!oi(e,t)){if(li(e))throw Error(i(418));t=ua(n.nextSibling);var r=ni;t&&oi(e,t)?si(r,n):(e.flags=-4097&e.flags|2,ai=!1,ni=e)}}else{if(li(e))throw Error(i(418));e.flags=-4097&e.flags|2,ai=!1,ni=e}}}function di(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ni=e}function ci(e){if(e!==ni)return!1;if(!ai)return di(e),ai=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!na(e.type,e.memoizedProps)),t&&(t=ri)){if(li(e))throw pi(),Error(i(418));for(;t;)si(e,t),t=ua(t.nextSibling)}if(di(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ri=ua(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ri=null}}else ri=ni?ua(e.stateNode.nextSibling):null;return!0}function pi(){for(var e=ri;e;)e=ua(e.nextSibling)}function hi(){ri=ni=null,ai=!1}function fi(e){null===ii?ii=[e]:ii.push(e)}var mi=x.ReactCurrentBatchConfig;function gi(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(i(309));var r=n.stateNode}if(!r)throw Error(i(147,e));var a=r,s=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===s?t.ref:(t=function(e){var t=a.refs;null===e?delete t[s]:t[s]=e},t._stringRef=s,t)}if("string"!==typeof e)throw Error(i(284));if(!n._owner)throw Error(i(290,e))}return e}function yi(e,t){throw e=Object.prototype.toString.call(t),Error(i(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function bi(e){return(0,e._init)(e._payload)}function vi(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function a(e,t){return(e=Fu(e,t)).index=0,e.sibling=null,e}function s(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Pu(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function u(e,t,n,r){var i=n.type;return i===S?c(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===i||"object"===typeof i&&null!==i&&i.$$typeof===R&&bi(i)===t.type)?((r=a(t,n.props)).ref=gi(e,t,n),r.return=e,r):((r=Du(n.type,n.key,n.props,null,e.mode,r)).ref=gi(e,t,n),r.return=e,r)}function d(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Lu(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function c(e,t,n,r,i){return null===t||7!==t.tag?((t=Mu(n,e.mode,r,i)).return=e,t):((t=a(t,n)).return=e,t)}function p(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Pu(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Du(t.type,t.key,t.props,null,e.mode,n)).ref=gi(e,null,t),n.return=e,n;case k:return(t=Lu(t,e.mode,n)).return=e,t;case R:return p(e,(0,t._init)(t._payload),n)}if(te(t)||M(t))return(t=Mu(t,e.mode,n,null)).return=e,t;yi(e,t)}return null}function h(e,t,n,r){var a=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===a?u(e,t,n,r):null;case k:return n.key===a?d(e,t,n,r):null;case R:return h(e,t,(a=n._init)(n._payload),r)}if(te(n)||M(n))return null!==a?null:c(e,t,n,r,null);yi(e,n)}return null}function f(e,t,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return l(t,e=e.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case w:return u(t,e=e.get(null===r.key?n:r.key)||null,r,a);case k:return d(t,e=e.get(null===r.key?n:r.key)||null,r,a);case R:return f(e,t,n,(0,r._init)(r._payload),a)}if(te(r)||M(r))return c(t,e=e.get(n)||null,r,a,null);yi(t,r)}return null}function m(a,i,o,l){for(var u=null,d=null,c=i,m=i=0,g=null;null!==c&&m<o.length;m++){c.index>m?(g=c,c=null):g=c.sibling;var y=h(a,c,o[m],l);if(null===y){null===c&&(c=g);break}e&&c&&null===y.alternate&&t(a,c),i=s(y,i,m),null===d?u=y:d.sibling=y,d=y,c=g}if(m===o.length)return n(a,c),ai&&Ja(a,m),u;if(null===c){for(;m<o.length;m++)null!==(c=p(a,o[m],l))&&(i=s(c,i,m),null===d?u=c:d.sibling=c,d=c);return ai&&Ja(a,m),u}for(c=r(a,c);m<o.length;m++)null!==(g=f(c,a,m,o[m],l))&&(e&&null!==g.alternate&&c.delete(null===g.key?m:g.key),i=s(g,i,m),null===d?u=g:d.sibling=g,d=g);return e&&c.forEach((function(e){return t(a,e)})),ai&&Ja(a,m),u}function g(a,o,l,u){var d=M(l);if("function"!==typeof d)throw Error(i(150));if(null==(l=d.call(l)))throw Error(i(151));for(var c=d=null,m=o,g=o=0,y=null,b=l.next();null!==m&&!b.done;g++,b=l.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=h(a,m,b.value,u);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(a,m),o=s(v,o,g),null===c?d=v:c.sibling=v,c=v,m=y}if(b.done)return n(a,m),ai&&Ja(a,g),d;if(null===m){for(;!b.done;g++,b=l.next())null!==(b=p(a,b.value,u))&&(o=s(b,o,g),null===c?d=b:c.sibling=b,c=b);return ai&&Ja(a,g),d}for(m=r(a,m);!b.done;g++,b=l.next())null!==(b=f(m,a,g,b.value,u))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=s(b,o,g),null===c?d=b:c.sibling=b,c=b);return e&&m.forEach((function(e){return t(a,e)})),ai&&Ja(a,g),d}return function e(r,i,s,l){if("object"===typeof s&&null!==s&&s.type===S&&null===s.key&&(s=s.props.children),"object"===typeof s&&null!==s){switch(s.$$typeof){case w:e:{for(var u=s.key,d=i;null!==d;){if(d.key===u){if((u=s.type)===S){if(7===d.tag){n(r,d.sibling),(i=a(d,s.props.children)).return=r,r=i;break e}}else if(d.elementType===u||"object"===typeof u&&null!==u&&u.$$typeof===R&&bi(u)===d.type){n(r,d.sibling),(i=a(d,s.props)).ref=gi(r,d,s),i.return=r,r=i;break e}n(r,d);break}t(r,d),d=d.sibling}s.type===S?((i=Mu(s.props.children,r.mode,l,s.key)).return=r,r=i):((l=Du(s.type,s.key,s.props,null,r.mode,l)).ref=gi(r,i,s),l.return=r,r=l)}return o(r);case k:e:{for(d=s.key;null!==i;){if(i.key===d){if(4===i.tag&&i.stateNode.containerInfo===s.containerInfo&&i.stateNode.implementation===s.implementation){n(r,i.sibling),(i=a(i,s.children||[])).return=r,r=i;break e}n(r,i);break}t(r,i),i=i.sibling}(i=Lu(s,r.mode,l)).return=r,r=i}return o(r);case R:return e(r,i,(d=s._init)(s._payload),l)}if(te(s))return m(r,i,s,l);if(M(s))return g(r,i,s,l);yi(r,s)}return"string"===typeof s&&""!==s||"number"===typeof s?(s=""+s,null!==i&&6===i.tag?(n(r,i.sibling),(i=a(i,s)).return=r,r=i):(n(r,i),(i=Pu(s,r.mode,l)).return=r,r=i),o(r)):n(r,i)}}var xi=vi(!0),wi=vi(!1),ki=Ia(null),Si=null,Ii=null,Ni=null;function Ti(){Ni=Ii=Si=null}function _i(e){var t=ki.current;Na(ki),e._currentValue=t}function Ci(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Ei(e,t){Si=e,Ni=Ii=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(vo=!0),e.firstContext=null)}function Ai(e){var t=e._currentValue;if(Ni!==e)if(e={context:e,memoizedValue:t,next:null},null===Ii){if(null===Si)throw Error(i(308));Ii=e,Si.dependencies={lanes:0,firstContext:e}}else Ii=Ii.next=e;return t}var $i=null;function Ri(e){null===$i?$i=[e]:$i.push(e)}function Fi(e,t,n,r){var a=t.interleaved;return null===a?(n.next=n,Ri(t)):(n.next=a.next,a.next=n),t.interleaved=n,Di(e,r)}function Di(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Mi=!1;function Oi(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Pi(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Li(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function zi(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Cl)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,Di(e,n)}return null===(a=r.interleaved)?(t.next=t,Ri(r)):(t.next=a.next,a.next=t),r.interleaved=t,Di(e,n)}function Bi(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Wi(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,i=null;if(null!==(n=n.firstBaseUpdate)){do{var s={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===i?a=i=s:i=i.next=s,n=n.next}while(null!==n);null===i?a=i=t:i=i.next=t}else a=i=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:i,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Ui(e,t,n,r){var a=e.updateQueue;Mi=!1;var i=a.firstBaseUpdate,s=a.lastBaseUpdate,o=a.shared.pending;if(null!==o){a.shared.pending=null;var l=o,u=l.next;l.next=null,null===s?i=u:s.next=u,s=l;var d=e.alternate;null!==d&&((o=(d=d.updateQueue).lastBaseUpdate)!==s&&(null===o?d.firstBaseUpdate=u:o.next=u,d.lastBaseUpdate=l))}if(null!==i){var c=a.baseState;for(s=0,d=u=l=null,o=i;;){var p=o.lane,h=o.eventTime;if((r&p)===p){null!==d&&(d=d.next={eventTime:h,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(p=t,h=n,m.tag){case 1:if("function"===typeof(f=m.payload)){c=f.call(h,c,p);break e}c=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(p="function"===typeof(f=m.payload)?f.call(h,c,p):f)||void 0===p)break e;c=P({},c,p);break e;case 2:Mi=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(p=a.effects)?a.effects=[o]:p.push(o))}else h={eventTime:h,lane:p,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===d?(u=d=h,l=c):d=d.next=h,s|=p;if(null===(o=o.next)){if(null===(o=a.shared.pending))break;o=(p=o).next,p.next=null,a.lastBaseUpdate=p,a.shared.pending=null}}if(null===d&&(l=c),a.baseState=l,a.firstBaseUpdate=u,a.lastBaseUpdate=d,null!==(t=a.shared.interleaved)){a=t;do{s|=a.lane,a=a.next}while(a!==t)}else null===i&&(a.shared.lanes=0);Ol|=s,e.lanes=s,e.memoizedState=c}}function Vi(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(i(191,a));a.call(r)}}}var Gi={},Hi=Ia(Gi),ji=Ia(Gi),qi=Ia(Gi);function Ki(e){if(e===Gi)throw Error(i(174));return e}function Xi(e,t){switch(Ta(qi,t),Ta(ji,e),Ta(Hi,Gi),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Na(Hi),Ta(Hi,t)}function Yi(){Na(Hi),Na(ji),Na(qi)}function Qi(e){Ki(qi.current);var t=Ki(Hi.current),n=le(t,e.type);t!==n&&(Ta(ji,e),Ta(Hi,n))}function Ji(e){ji.current===e&&(Na(Hi),Na(ji))}var Zi=Ia(0);function es(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ts=[];function ns(){for(var e=0;e<ts.length;e++)ts[e]._workInProgressVersionPrimary=null;ts.length=0}var rs=x.ReactCurrentDispatcher,as=x.ReactCurrentBatchConfig,is=0,ss=null,os=null,ls=null,us=!1,ds=!1,cs=0,ps=0;function hs(){throw Error(i(321))}function fs(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!or(e[n],t[n]))return!1;return!0}function ms(e,t,n,r,a,s){if(is=s,ss=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,rs.current=null===e||null===e.memoizedState?Js:Zs,e=n(r,a),ds){s=0;do{if(ds=!1,cs=0,25<=s)throw Error(i(301));s+=1,ls=os=null,t.updateQueue=null,rs.current=eo,e=n(r,a)}while(ds)}if(rs.current=Qs,t=null!==os&&null!==os.next,is=0,ls=os=ss=null,us=!1,t)throw Error(i(300));return e}function gs(){var e=0!==cs;return cs=0,e}function ys(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ls?ss.memoizedState=ls=e:ls=ls.next=e,ls}function bs(){if(null===os){var e=ss.alternate;e=null!==e?e.memoizedState:null}else e=os.next;var t=null===ls?ss.memoizedState:ls.next;if(null!==t)ls=t,os=e;else{if(null===e)throw Error(i(310));e={memoizedState:(os=e).memoizedState,baseState:os.baseState,baseQueue:os.baseQueue,queue:os.queue,next:null},null===ls?ss.memoizedState=ls=e:ls=ls.next=e}return ls}function vs(e,t){return"function"===typeof t?t(e):t}function xs(e){var t=bs(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var r=os,a=r.baseQueue,s=n.pending;if(null!==s){if(null!==a){var o=a.next;a.next=s.next,s.next=o}r.baseQueue=a=s,n.pending=null}if(null!==a){s=a.next,r=r.baseState;var l=o=null,u=null,d=s;do{var c=d.lane;if((is&c)===c)null!==u&&(u=u.next={lane:0,action:d.action,hasEagerState:d.hasEagerState,eagerState:d.eagerState,next:null}),r=d.hasEagerState?d.eagerState:e(r,d.action);else{var p={lane:c,action:d.action,hasEagerState:d.hasEagerState,eagerState:d.eagerState,next:null};null===u?(l=u=p,o=r):u=u.next=p,ss.lanes|=c,Ol|=c}d=d.next}while(null!==d&&d!==s);null===u?o=r:u.next=l,or(r,t.memoizedState)||(vo=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=u,n.lastRenderedState=r}if(null!==(e=n.interleaved)){a=e;do{s=a.lane,ss.lanes|=s,Ol|=s,a=a.next}while(a!==e)}else null===a&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function ws(e){var t=bs(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,s=t.memoizedState;if(null!==a){n.pending=null;var o=a=a.next;do{s=e(s,o.action),o=o.next}while(o!==a);or(s,t.memoizedState)||(vo=!0),t.memoizedState=s,null===t.baseQueue&&(t.baseState=s),n.lastRenderedState=s}return[s,r]}function ks(){}function Ss(e,t){var n=ss,r=bs(),a=t(),s=!or(r.memoizedState,a);if(s&&(r.memoizedState=a,vo=!0),r=r.queue,Ms(Ts.bind(null,n,r,e),[e]),r.getSnapshot!==t||s||null!==ls&&1&ls.memoizedState.tag){if(n.flags|=2048,As(9,Ns.bind(null,n,r,a,t),void 0,null),null===El)throw Error(i(349));0!==(30&is)||Is(n,t,a)}return a}function Is(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ss.updateQueue)?(t={lastEffect:null,stores:null},ss.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ns(e,t,n,r){t.value=n,t.getSnapshot=r,_s(t)&&Cs(e)}function Ts(e,t,n){return n((function(){_s(t)&&Cs(e)}))}function _s(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!or(e,n)}catch(r){return!0}}function Cs(e){var t=Di(e,1);null!==t&&nu(t,e,1,-1)}function Es(e){var t=ys();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vs,lastRenderedState:e},t.queue=e,e=e.dispatch=qs.bind(null,ss,e),[t.memoizedState,e]}function As(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=ss.updateQueue)?(t={lastEffect:null,stores:null},ss.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function $s(){return bs().memoizedState}function Rs(e,t,n,r){var a=ys();ss.flags|=e,a.memoizedState=As(1|t,n,void 0,void 0===r?null:r)}function Fs(e,t,n,r){var a=bs();r=void 0===r?null:r;var i=void 0;if(null!==os){var s=os.memoizedState;if(i=s.destroy,null!==r&&fs(r,s.deps))return void(a.memoizedState=As(t,n,i,r))}ss.flags|=e,a.memoizedState=As(1|t,n,i,r)}function Ds(e,t){return Rs(8390656,8,e,t)}function Ms(e,t){return Fs(2048,8,e,t)}function Os(e,t){return Fs(4,2,e,t)}function Ps(e,t){return Fs(4,4,e,t)}function Ls(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function zs(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Fs(4,4,Ls.bind(null,t,e),n)}function Bs(){}function Ws(e,t){var n=bs();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fs(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Us(e,t){var n=bs();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fs(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Vs(e,t,n){return 0===(21&is)?(e.baseState&&(e.baseState=!1,vo=!0),e.memoizedState=n):(or(n,t)||(n=mt(),ss.lanes|=n,Ol|=n,e.baseState=!0),t)}function Gs(e,t){var n=vt;vt=0!==n&&4>n?n:4,e(!0);var r=as.transition;as.transition={};try{e(!1),t()}finally{vt=n,as.transition=r}}function Hs(){return bs().memoizedState}function js(e,t,n){var r=tu(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ks(e))Xs(t,n);else if(null!==(n=Fi(e,t,n,r))){nu(n,e,r,eu()),Ys(n,t,r)}}function qs(e,t,n){var r=tu(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ks(e))Xs(t,a);else{var i=e.alternate;if(0===e.lanes&&(null===i||0===i.lanes)&&null!==(i=t.lastRenderedReducer))try{var s=t.lastRenderedState,o=i(s,n);if(a.hasEagerState=!0,a.eagerState=o,or(o,s)){var l=t.interleaved;return null===l?(a.next=a,Ri(t)):(a.next=l.next,l.next=a),void(t.interleaved=a)}}catch(u){}null!==(n=Fi(e,t,a,r))&&(nu(n,e,r,a=eu()),Ys(n,t,r))}}function Ks(e){var t=e.alternate;return e===ss||null!==t&&t===ss}function Xs(e,t){ds=us=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Ys(e,t,n){if(0!==(4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Qs={readContext:Ai,useCallback:hs,useContext:hs,useEffect:hs,useImperativeHandle:hs,useInsertionEffect:hs,useLayoutEffect:hs,useMemo:hs,useReducer:hs,useRef:hs,useState:hs,useDebugValue:hs,useDeferredValue:hs,useTransition:hs,useMutableSource:hs,useSyncExternalStore:hs,useId:hs,unstable_isNewReconciler:!1},Js={readContext:Ai,useCallback:function(e,t){return ys().memoizedState=[e,void 0===t?null:t],e},useContext:Ai,useEffect:Ds,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Rs(4194308,4,Ls.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Rs(4194308,4,e,t)},useInsertionEffect:function(e,t){return Rs(4,2,e,t)},useMemo:function(e,t){var n=ys();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=ys();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=js.bind(null,ss,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},ys().memoizedState=e},useState:Es,useDebugValue:Bs,useDeferredValue:function(e){return ys().memoizedState=e},useTransition:function(){var e=Es(!1),t=e[0];return e=Gs.bind(null,e[1]),ys().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=ss,a=ys();if(ai){if(void 0===n)throw Error(i(407));n=n()}else{if(n=t(),null===El)throw Error(i(349));0!==(30&is)||Is(r,t,n)}a.memoizedState=n;var s={value:n,getSnapshot:t};return a.queue=s,Ds(Ts.bind(null,r,s,e),[e]),r.flags|=2048,As(9,Ns.bind(null,r,s,n,t),void 0,null),n},useId:function(){var e=ys(),t=El.identifierPrefix;if(ai){var n=Qa;t=":"+t+"R"+(n=(Ya&~(1<<32-st(Ya)-1)).toString(32)+n),0<(n=cs++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=ps++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Zs={readContext:Ai,useCallback:Ws,useContext:Ai,useEffect:Ms,useImperativeHandle:zs,useInsertionEffect:Os,useLayoutEffect:Ps,useMemo:Us,useReducer:xs,useRef:$s,useState:function(){return xs(vs)},useDebugValue:Bs,useDeferredValue:function(e){return Vs(bs(),os.memoizedState,e)},useTransition:function(){return[xs(vs)[0],bs().memoizedState]},useMutableSource:ks,useSyncExternalStore:Ss,useId:Hs,unstable_isNewReconciler:!1},eo={readContext:Ai,useCallback:Ws,useContext:Ai,useEffect:Ms,useImperativeHandle:zs,useInsertionEffect:Os,useLayoutEffect:Ps,useMemo:Us,useReducer:ws,useRef:$s,useState:function(){return ws(vs)},useDebugValue:Bs,useDeferredValue:function(e){var t=bs();return null===os?t.memoizedState=e:Vs(t,os.memoizedState,e)},useTransition:function(){return[ws(vs)[0],bs().memoizedState]},useMutableSource:ks,useSyncExternalStore:Ss,useId:Hs,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=P({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:P({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ro={isMounted:function(e){return!!(e=e._reactInternals)&&Ue(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),i=Li(r,a);i.payload=t,void 0!==n&&null!==n&&(i.callback=n),null!==(t=zi(e,i,a))&&(nu(t,e,a,r),Bi(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),i=Li(r,a);i.tag=1,i.payload=t,void 0!==n&&null!==n&&(i.callback=n),null!==(t=zi(e,i,a))&&(nu(t,e,a,r),Bi(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=eu(),r=tu(e),a=Li(n,r);a.tag=2,void 0!==t&&null!==t&&(a.callback=t),null!==(t=zi(e,a,r))&&(nu(t,e,r,n),Bi(t,e,r))}};function ao(e,t,n,r,a,i,s){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,i,s):!t.prototype||!t.prototype.isPureReactComponent||(!lr(n,r)||!lr(a,i))}function io(e,t,n){var r=!1,a=_a,i=t.contextType;return"object"===typeof i&&null!==i?i=Ai(i):(a=Ra(t)?Aa:Ca.current,i=(r=null!==(r=t.contextTypes)&&void 0!==r)?$a(e,a):_a),t=new t(n,i),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ro,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=i),t}function so(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ro.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},Oi(e);var i=t.contextType;"object"===typeof i&&null!==i?a.context=Ai(i):(i=Ra(t)?Aa:Ca.current,a.context=$a(e,i)),a.state=e.memoizedState,"function"===typeof(i=t.getDerivedStateFromProps)&&(no(e,t,i,n),a.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(t=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),t!==a.state&&ro.enqueueReplaceState(a,a.state,null),Ui(e,n,a,r),a.state=e.memoizedState),"function"===typeof a.componentDidMount&&(e.flags|=4194308)}function lo(e,t){try{var n="",r=t;do{n+=W(r),r=r.return}while(r);var a=n}catch(i){a="\nError generating stack: "+i.message+"\n"+i.stack}return{value:e,source:t,stack:a,digest:null}}function uo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function co(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var po="function"===typeof WeakMap?WeakMap:Map;function ho(e,t,n){(n=Li(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Gl||(Gl=!0,Hl=r),co(0,t)},n}function fo(e,t,n){(n=Li(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"===typeof r){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){co(0,t)}}var i=e.stateNode;return null!==i&&"function"===typeof i.componentDidCatch&&(n.callback=function(){co(0,t),"function"!==typeof r&&(null===jl?jl=new Set([this]):jl.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mo(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new po;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=Nu.bind(null,e,t,n),t.then(e,e))}function go(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,r,a){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Li(-1,1)).tag=2,zi(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=a,e)}var bo=x.ReactCurrentOwner,vo=!1;function xo(e,t,n,r){t.child=null===e?wi(t,null,n,r):xi(t,e.child,n,r)}function wo(e,t,n,r,a){n=n.render;var i=t.ref;return Ei(t,a),r=ms(e,t,n,r,i,a),n=gs(),null===e||vo?(ai&&n&&ei(t),t.flags|=1,xo(e,t,r,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Go(e,t,a))}function ko(e,t,n,r,a){if(null===e){var i=n.type;return"function"!==typeof i||Ru(i)||void 0!==i.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Du(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=i,So(e,t,i,r,a))}if(i=e.child,0===(e.lanes&a)){var s=i.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(s,r)&&e.ref===t.ref)return Go(e,t,a)}return t.flags|=1,(e=Fu(i,r)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,r,a){if(null!==e){var i=e.memoizedProps;if(lr(i,r)&&e.ref===t.ref){if(vo=!1,t.pendingProps=r=i,0===(e.lanes&a))return t.lanes=e.lanes,Go(e,t,a);0!==(131072&e.flags)&&(vo=!0)}}return To(e,t,n,r,a)}function Io(e,t,n){var r=t.pendingProps,a=r.children,i=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ta(Fl,Rl),Rl|=n;else{if(0===(1073741824&n))return e=null!==i?i.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ta(Fl,Rl),Rl|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==i?i.baseLanes:n,Ta(Fl,Rl),Rl|=r}else null!==i?(r=i.baseLanes|n,t.memoizedState=null):r=n,Ta(Fl,Rl),Rl|=r;return xo(e,t,a,n),t.child}function No(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function To(e,t,n,r,a){var i=Ra(n)?Aa:Ca.current;return i=$a(t,i),Ei(t,a),n=ms(e,t,n,r,i,a),r=gs(),null===e||vo?(ai&&r&&ei(t),t.flags|=1,xo(e,t,n,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Go(e,t,a))}function _o(e,t,n,r,a){if(Ra(n)){var i=!0;Oa(t)}else i=!1;if(Ei(t,a),null===t.stateNode)Vo(e,t),io(t,n,r),oo(t,n,r,a),r=!0;else if(null===e){var s=t.stateNode,o=t.memoizedProps;s.props=o;var l=s.context,u=n.contextType;"object"===typeof u&&null!==u?u=Ai(u):u=$a(t,u=Ra(n)?Aa:Ca.current);var d=n.getDerivedStateFromProps,c="function"===typeof d||"function"===typeof s.getSnapshotBeforeUpdate;c||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(o!==r||l!==u)&&so(t,s,r,u),Mi=!1;var p=t.memoizedState;s.state=p,Ui(t,r,s,a),l=t.memoizedState,o!==r||p!==l||Ea.current||Mi?("function"===typeof d&&(no(t,n,d,r),l=t.memoizedState),(o=Mi||ao(t,n,o,r,p,l,u))?(c||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||("function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount()),"function"===typeof s.componentDidMount&&(t.flags|=4194308)):("function"===typeof s.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),s.props=r,s.state=l,s.context=u,r=o):("function"===typeof s.componentDidMount&&(t.flags|=4194308),r=!1)}else{s=t.stateNode,Pi(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:to(t.type,o),s.props=u,c=t.pendingProps,p=s.context,"object"===typeof(l=n.contextType)&&null!==l?l=Ai(l):l=$a(t,l=Ra(n)?Aa:Ca.current);var h=n.getDerivedStateFromProps;(d="function"===typeof h||"function"===typeof s.getSnapshotBeforeUpdate)||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(o!==c||p!==l)&&so(t,s,r,l),Mi=!1,p=t.memoizedState,s.state=p,Ui(t,r,s,a);var f=t.memoizedState;o!==c||p!==f||Ea.current||Mi?("function"===typeof h&&(no(t,n,h,r),f=t.memoizedState),(u=Mi||ao(t,n,u,r,p,f,l)||!1)?(d||"function"!==typeof s.UNSAFE_componentWillUpdate&&"function"!==typeof s.componentWillUpdate||("function"===typeof s.componentWillUpdate&&s.componentWillUpdate(r,f,l),"function"===typeof s.UNSAFE_componentWillUpdate&&s.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof s.componentDidUpdate&&(t.flags|=4),"function"===typeof s.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof s.componentDidUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),s.props=r,s.state=f,s.context=l,r=u):("function"!==typeof s.componentDidUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),r=!1)}return Co(e,t,n,r,i,a)}function Co(e,t,n,r,a,i){No(e,t);var s=0!==(128&t.flags);if(!r&&!s)return a&&Pa(t,n,!1),Go(e,t,i);r=t.stateNode,bo.current=t;var o=s&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&s?(t.child=xi(t,e.child,null,i),t.child=xi(t,null,o,i)):xo(e,t,o,i),t.memoizedState=r.state,a&&Pa(t,n,!0),t.child}function Eo(e){var t=e.stateNode;t.pendingContext?Da(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Da(0,t.context,!1),Xi(e,t.containerInfo)}function Ao(e,t,n,r,a){return hi(),fi(a),t.flags|=256,xo(e,t,n,r),t.child}var $o,Ro,Fo,Do,Mo={dehydrated:null,treeContext:null,retryLane:0};function Oo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Po(e,t,n){var r,a=t.pendingProps,s=Zi.current,o=!1,l=0!==(128&t.flags);if((r=l)||(r=(null===e||null!==e.memoizedState)&&0!==(2&s)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(s|=1),Ta(Zi,1&s),null===e)return ui(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(l=a.children,e=a.fallback,o?(a=t.mode,o=t.child,l={mode:"hidden",children:l},0===(1&a)&&null!==o?(o.childLanes=0,o.pendingProps=l):o=Ou(l,a,0,null),e=Mu(e,a,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Oo(n),t.memoizedState=Mo,e):Lo(t,l));if(null!==(s=e.memoizedState)&&null!==(r=s.dehydrated))return function(e,t,n,r,a,s,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,r=uo(Error(i(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(s=r.fallback,a=t.mode,r=Ou({mode:"visible",children:r.children},a,0,null),(s=Mu(s,a,o,null)).flags|=2,r.return=t,s.return=t,r.sibling=s,t.child=r,0!==(1&t.mode)&&xi(t,e.child,null,o),t.child.memoizedState=Oo(o),t.memoizedState=Mo,s);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var l=r.dgst;return r=l,zo(e,t,o,r=uo(s=Error(i(419)),r,void 0))}if(l=0!==(o&e.childLanes),vo||l){if(null!==(r=El)){switch(o&-o){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|o))?0:a)&&a!==s.retryLane&&(s.retryLane=a,Di(e,a),nu(r,e,a,-1))}return mu(),zo(e,t,o,r=uo(Error(i(421))))}return"$?"===a.data?(t.flags|=128,t.child=e.child,t=_u.bind(null,e),a._reactRetry=t,null):(e=s.treeContext,ri=ua(a.nextSibling),ni=t,ai=!0,ii=null,null!==e&&(qa[Ka++]=Ya,qa[Ka++]=Qa,qa[Ka++]=Xa,Ya=e.id,Qa=e.overflow,Xa=t),t=Lo(t,r.children),t.flags|=4096,t)}(e,t,l,a,r,s,n);if(o){o=a.fallback,l=t.mode,r=(s=e.child).sibling;var u={mode:"hidden",children:a.children};return 0===(1&l)&&t.child!==s?((a=t.child).childLanes=0,a.pendingProps=u,t.deletions=null):(a=Fu(s,u)).subtreeFlags=14680064&s.subtreeFlags,null!==r?o=Fu(r,o):(o=Mu(o,l,n,null)).flags|=2,o.return=t,a.return=t,a.sibling=o,t.child=a,a=o,o=t.child,l=null===(l=e.child.memoizedState)?Oo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Mo,a}return e=(o=e.child).sibling,a=Fu(o,{mode:"visible",children:a.children}),0===(1&t.mode)&&(a.lanes=n),a.return=t,a.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=a,t.memoizedState=null,a}function Lo(e,t){return(t=Ou({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,r){return null!==r&&fi(r),xi(t,e.child,null,n),(e=Lo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),Ci(e.return,t,n)}function Wo(e,t,n,r,a){var i=e.memoizedState;null===i?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=r,i.tail=n,i.tailMode=a)}function Uo(e,t,n){var r=t.pendingProps,a=r.revealOrder,i=r.tail;if(xo(e,t,r.children,n),0!==(2&(r=Zi.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Ta(Zi,r),0===(1&t.mode))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===es(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),Wo(t,!1,a,n,i);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===es(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}Wo(t,!0,n,null,i);break;case"together":Wo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Vo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Go(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ol|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(n=Fu(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Fu(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Ho(e,t){if(!ai)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function jo(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function qo(e,t,n){var r=t.pendingProps;switch(ti(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return jo(t),null;case 1:case 17:return Ra(t.type)&&Fa(),jo(t),null;case 3:return r=t.stateNode,Yi(),Na(Ea),Na(Ca),ns(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(ci(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==ii&&(su(ii),ii=null))),Ro(e,t),jo(t),null;case 5:Ji(t);var a=Ki(qi.current);if(n=t.type,null!==e&&null!=t.stateNode)Fo(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(i(166));return jo(t),null}if(e=Ki(Hi.current),ci(t)){r=t.stateNode,n=t.type;var s=t.memoizedProps;switch(r[pa]=t,r[ha]=s,e=0!==(1&t.mode),n){case"dialog":zr("cancel",r),zr("close",r);break;case"iframe":case"object":case"embed":zr("load",r);break;case"video":case"audio":for(a=0;a<Mr.length;a++)zr(Mr[a],r);break;case"source":zr("error",r);break;case"img":case"image":case"link":zr("error",r),zr("load",r);break;case"details":zr("toggle",r);break;case"input":Y(r,s),zr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!s.multiple},zr("invalid",r);break;case"textarea":ae(r,s),zr("invalid",r)}for(var l in be(n,s),a=null,s)if(s.hasOwnProperty(l)){var u=s[l];"children"===l?"string"===typeof u?r.textContent!==u&&(!0!==s.suppressHydrationWarning&&Jr(r.textContent,u,e),a=["children",u]):"number"===typeof u&&r.textContent!==""+u&&(!0!==s.suppressHydrationWarning&&Jr(r.textContent,u,e),a=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&zr("scroll",r)}switch(n){case"input":j(r),Z(r,s,!0);break;case"textarea":j(r),se(r);break;case"select":case"option":break;default:"function"===typeof s.onClick&&(r.onclick=Zr)}r=a,t.updateQueue=r,null!==r&&(t.flags|=4)}else{l=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof r.is?e=l.createElement(n,{is:r.is}):(e=l.createElement(n),"select"===n&&(l=e,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):e=l.createElementNS(e,n),e[pa]=t,e[ha]=r,$o(e,t,!1,!1),t.stateNode=e;e:{switch(l=ve(n,r),n){case"dialog":zr("cancel",e),zr("close",e),a=r;break;case"iframe":case"object":case"embed":zr("load",e),a=r;break;case"video":case"audio":for(a=0;a<Mr.length;a++)zr(Mr[a],e);a=r;break;case"source":zr("error",e),a=r;break;case"img":case"image":case"link":zr("error",e),zr("load",e),a=r;break;case"details":zr("toggle",e),a=r;break;case"input":Y(e,r),a=X(e,r),zr("invalid",e);break;case"option":default:a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=P({},r,{value:void 0}),zr("invalid",e);break;case"textarea":ae(e,r),a=re(e,r),zr("invalid",e)}for(s in be(n,a),u=a)if(u.hasOwnProperty(s)){var d=u[s];"style"===s?ge(e,d):"dangerouslySetInnerHTML"===s?null!=(d=d?d.__html:void 0)&&ce(e,d):"children"===s?"string"===typeof d?("textarea"!==n||""!==d)&&pe(e,d):"number"===typeof d&&pe(e,""+d):"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&"autoFocus"!==s&&(o.hasOwnProperty(s)?null!=d&&"onScroll"===s&&zr("scroll",e):null!=d&&v(e,s,d,l))}switch(n){case"input":j(e),Z(e,r,!1);break;case"textarea":j(e),se(e);break;case"option":null!=r.value&&e.setAttribute("value",""+G(r.value));break;case"select":e.multiple=!!r.multiple,null!=(s=r.value)?ne(e,!!r.multiple,s,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(e.onclick=Zr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return jo(t),null;case 6:if(e&&null!=t.stateNode)Do(e,t,e.memoizedProps,r);else{if("string"!==typeof r&&null===t.stateNode)throw Error(i(166));if(n=Ki(qi.current),Ki(Hi.current),ci(t)){if(r=t.stateNode,n=t.memoizedProps,r[pa]=t,(s=r.nodeValue!==n)&&null!==(e=ni))switch(e.tag){case 3:Jr(r.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Jr(r.nodeValue,n,0!==(1&e.mode))}s&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[pa]=t,t.stateNode=r}return jo(t),null;case 13:if(Na(Zi),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(ai&&null!==ri&&0!==(1&t.mode)&&0===(128&t.flags))pi(),hi(),t.flags|=98560,s=!1;else if(s=ci(t),null!==r&&null!==r.dehydrated){if(null===e){if(!s)throw Error(i(318));if(!(s=null!==(s=t.memoizedState)?s.dehydrated:null))throw Error(i(317));s[pa]=t}else hi(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;jo(t),s=!1}else null!==ii&&(su(ii),ii=null),s=!0;if(!s)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((r=null!==r)!==(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&Zi.current)?0===Dl&&(Dl=3):mu())),null!==t.updateQueue&&(t.flags|=4),jo(t),null);case 4:return Yi(),Ro(e,t),null===e&&Ur(t.stateNode.containerInfo),jo(t),null;case 10:return _i(t.type._context),jo(t),null;case 19:if(Na(Zi),null===(s=t.memoizedState))return jo(t),null;if(r=0!==(128&t.flags),null===(l=s.rendering))if(r)Ho(s,!1);else{if(0!==Dl||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(l=es(e))){for(t.flags|=128,Ho(s,!1),null!==(r=l.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(s=n).flags&=14680066,null===(l=s.alternate)?(s.childLanes=0,s.lanes=e,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=l.childLanes,s.lanes=l.lanes,s.child=l.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=l.memoizedProps,s.memoizedState=l.memoizedState,s.updateQueue=l.updateQueue,s.type=l.type,e=l.dependencies,s.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ta(Zi,1&Zi.current|2),t.child}e=e.sibling}null!==s.tail&&Qe()>Ul&&(t.flags|=128,r=!0,Ho(s,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=es(l))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Ho(s,!0),null===s.tail&&"hidden"===s.tailMode&&!l.alternate&&!ai)return jo(t),null}else 2*Qe()-s.renderingStartTime>Ul&&1073741824!==n&&(t.flags|=128,r=!0,Ho(s,!1),t.lanes=4194304);s.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=s.last)?n.sibling=l:t.child=l,s.last=l)}return null!==s.tail?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=Qe(),t.sibling=null,n=Zi.current,Ta(Zi,r?1&n|2:1&n),t):(jo(t),null);case 22:case 23:return cu(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&0!==(1&t.mode)?0!==(1073741824&Rl)&&(jo(t),6&t.subtreeFlags&&(t.flags|=8192)):jo(t),null;case 24:case 25:return null}throw Error(i(156,t.tag))}function Ko(e,t){switch(ti(t),t.tag){case 1:return Ra(t.type)&&Fa(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Yi(),Na(Ea),Na(Ca),ns(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Ji(t),null;case 13:if(Na(Zi),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(i(340));hi()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Na(Zi),null;case 4:return Yi(),null;case 10:return _i(t.type._context),null;case 22:case 23:return cu(),null;default:return null}}$o=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Ro=function(){},Fo=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,Ki(Hi.current);var i,s=null;switch(n){case"input":a=X(e,a),r=X(e,r),s=[];break;case"select":a=P({},a,{value:void 0}),r=P({},r,{value:void 0}),s=[];break;case"textarea":a=re(e,a),r=re(e,r),s=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(e.onclick=Zr)}for(d in be(n,r),n=null,a)if(!r.hasOwnProperty(d)&&a.hasOwnProperty(d)&&null!=a[d])if("style"===d){var l=a[d];for(i in l)l.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else"dangerouslySetInnerHTML"!==d&&"children"!==d&&"suppressContentEditableWarning"!==d&&"suppressHydrationWarning"!==d&&"autoFocus"!==d&&(o.hasOwnProperty(d)?s||(s=[]):(s=s||[]).push(d,null));for(d in r){var u=r[d];if(l=null!=a?a[d]:void 0,r.hasOwnProperty(d)&&u!==l&&(null!=u||null!=l))if("style"===d)if(l){for(i in l)!l.hasOwnProperty(i)||u&&u.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in u)u.hasOwnProperty(i)&&l[i]!==u[i]&&(n||(n={}),n[i]=u[i])}else n||(s||(s=[]),s.push(d,n)),n=u;else"dangerouslySetInnerHTML"===d?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(s=s||[]).push(d,u)):"children"===d?"string"!==typeof u&&"number"!==typeof u||(s=s||[]).push(d,""+u):"suppressContentEditableWarning"!==d&&"suppressHydrationWarning"!==d&&(o.hasOwnProperty(d)?(null!=u&&"onScroll"===d&&zr("scroll",e),s||l===u||(s=[])):(s=s||[]).push(d,u))}n&&(s=s||[]).push("style",n);var d=s;(t.updateQueue=d)&&(t.flags|=4)}},Do=function(e,t,n,r){n!==r&&(t.flags|=4)};var Xo=!1,Yo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Jo=null;function Zo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Iu(e,t,r)}else n.current=null}function el(e,t,n){try{n()}catch(r){Iu(e,t,r)}}var tl=!1;function nl(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&e)===e){var i=a.destroy;a.destroy=void 0,void 0!==i&&el(t,n,i)}a=a.next}while(a!==r)}}function rl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function al(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function il(e){var t=e.alternate;null!==t&&(e.alternate=null,il(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[pa],delete t[ha],delete t[ma],delete t[ga],delete t[ya])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function sl(e){return 5===e.tag||3===e.tag||4===e.tag}function ol(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||sl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Zr));else if(4!==r&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}function ul(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(ul(e,t,n),e=e.sibling;null!==e;)ul(e,t,n),e=e.sibling}var dl=null,cl=!1;function pl(e,t,n){for(n=n.child;null!==n;)hl(e,t,n),n=n.sibling}function hl(e,t,n){if(it&&"function"===typeof it.onCommitFiberUnmount)try{it.onCommitFiberUnmount(at,n)}catch(o){}switch(n.tag){case 5:Yo||Zo(n,t);case 6:var r=dl,a=cl;dl=null,pl(e,t,n),cl=a,null!==(dl=r)&&(cl?(e=dl,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):dl.removeChild(n.stateNode));break;case 18:null!==dl&&(cl?(e=dl,n=n.stateNode,8===e.nodeType?la(e.parentNode,n):1===e.nodeType&&la(e,n),Ut(e)):la(dl,n.stateNode));break;case 4:r=dl,a=cl,dl=n.stateNode.containerInfo,cl=!0,pl(e,t,n),dl=r,cl=a;break;case 0:case 11:case 14:case 15:if(!Yo&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var i=a,s=i.destroy;i=i.tag,void 0!==s&&(0!==(2&i)||0!==(4&i))&&el(n,t,s),a=a.next}while(a!==r)}pl(e,t,n);break;case 1:if(!Yo&&(Zo(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){Iu(n,t,o)}pl(e,t,n);break;case 21:pl(e,t,n);break;case 22:1&n.mode?(Yo=(r=Yo)||null!==n.memoizedState,pl(e,t,n),Yo=r):pl(e,t,n);break;default:pl(e,t,n)}}function fl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach((function(t){var r=Cu.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function ml(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var s=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:dl=l.stateNode,cl=!1;break e;case 3:case 4:dl=l.stateNode.containerInfo,cl=!0;break e}l=l.return}if(null===dl)throw Error(i(160));hl(s,o,a),dl=null,cl=!1;var u=a.alternate;null!==u&&(u.return=null),a.return=null}catch(d){Iu(a,t,d)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gl(t,e),t=t.sibling}function gl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ml(t,e),yl(e),4&r){try{nl(3,e,e.return),rl(3,e)}catch(g){Iu(e,e.return,g)}try{nl(5,e,e.return)}catch(g){Iu(e,e.return,g)}}break;case 1:ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return);break;case 5:if(ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return),32&e.flags){var a=e.stateNode;try{pe(a,"")}catch(g){Iu(e,e.return,g)}}if(4&r&&null!=(a=e.stateNode)){var s=e.memoizedProps,o=null!==n?n.memoizedProps:s,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===s.type&&null!=s.name&&Q(a,s),ve(l,o);var d=ve(l,s);for(o=0;o<u.length;o+=2){var c=u[o],p=u[o+1];"style"===c?ge(a,p):"dangerouslySetInnerHTML"===c?ce(a,p):"children"===c?pe(a,p):v(a,c,p,d)}switch(l){case"input":J(a,s);break;case"textarea":ie(a,s);break;case"select":var h=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!s.multiple;var f=s.value;null!=f?ne(a,!!s.multiple,f,!1):h!==!!s.multiple&&(null!=s.defaultValue?ne(a,!!s.multiple,s.defaultValue,!0):ne(a,!!s.multiple,s.multiple?[]:"",!1))}a[ha]=s}catch(g){Iu(e,e.return,g)}}break;case 6:if(ml(t,e),yl(e),4&r){if(null===e.stateNode)throw Error(i(162));a=e.stateNode,s=e.memoizedProps;try{a.nodeValue=s}catch(g){Iu(e,e.return,g)}}break;case 3:if(ml(t,e),yl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Ut(t.containerInfo)}catch(g){Iu(e,e.return,g)}break;case 4:default:ml(t,e),yl(e);break;case 13:ml(t,e),yl(e),8192&(a=e.child).flags&&(s=null!==a.memoizedState,a.stateNode.isHidden=s,!s||null!==a.alternate&&null!==a.alternate.memoizedState||(Wl=Qe())),4&r&&fl(e);break;case 22:if(c=null!==n&&null!==n.memoizedState,1&e.mode?(Yo=(d=Yo)||c,ml(t,e),Yo=d):ml(t,e),yl(e),8192&r){if(d=null!==e.memoizedState,(e.stateNode.isHidden=d)&&!c&&0!==(1&e.mode))for(Jo=e,c=e.child;null!==c;){for(p=Jo=c;null!==Jo;){switch(f=(h=Jo).child,h.tag){case 0:case 11:case 14:case 15:nl(4,h,h.return);break;case 1:Zo(h,h.return);var m=h.stateNode;if("function"===typeof m.componentWillUnmount){r=h,n=h.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Iu(r,n,g)}}break;case 5:Zo(h,h.return);break;case 22:if(null!==h.memoizedState){wl(p);continue}}null!==f?(f.return=h,Jo=f):wl(p)}c=c.sibling}e:for(c=null,p=e;;){if(5===p.tag){if(null===c){c=p;try{a=p.stateNode,d?"function"===typeof(s=a.style).setProperty?s.setProperty("display","none","important"):s.display="none":(l=p.stateNode,o=void 0!==(u=p.memoizedProps.style)&&null!==u&&u.hasOwnProperty("display")?u.display:null,l.style.display=me("display",o))}catch(g){Iu(e,e.return,g)}}}else if(6===p.tag){if(null===c)try{p.stateNode.nodeValue=d?"":p.memoizedProps}catch(g){Iu(e,e.return,g)}}else if((22!==p.tag&&23!==p.tag||null===p.memoizedState||p===e)&&null!==p.child){p.child.return=p,p=p.child;continue}if(p===e)break e;for(;null===p.sibling;){if(null===p.return||p.return===e)break e;c===p&&(c=null),p=p.return}c===p&&(c=null),p.sibling.return=p.return,p=p.sibling}}break;case 19:ml(t,e),yl(e),4&r&&fl(e);case 21:}}function yl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(sl(n)){var r=n;break e}n=n.return}throw Error(i(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(pe(a,""),r.flags&=-33),ul(e,ol(e),a);break;case 3:case 4:var s=r.stateNode.containerInfo;ll(e,ol(e),s);break;default:throw Error(i(161))}}catch(o){Iu(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bl(e,t,n){Jo=e,vl(e,t,n)}function vl(e,t,n){for(var r=0!==(1&e.mode);null!==Jo;){var a=Jo,i=a.child;if(22===a.tag&&r){var s=null!==a.memoizedState||Xo;if(!s){var o=a.alternate,l=null!==o&&null!==o.memoizedState||Yo;o=Xo;var u=Yo;if(Xo=s,(Yo=l)&&!u)for(Jo=a;null!==Jo;)l=(s=Jo).child,22===s.tag&&null!==s.memoizedState?kl(a):null!==l?(l.return=s,Jo=l):kl(a);for(;null!==i;)Jo=i,vl(i,t,n),i=i.sibling;Jo=a,Xo=o,Yo=u}xl(e)}else 0!==(8772&a.subtreeFlags)&&null!==i?(i.return=a,Jo=i):xl(e)}}function xl(e){for(;null!==Jo;){var t=Jo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yo||rl(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Yo)if(null===n)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var s=t.updateQueue;null!==s&&Vi(t,s,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Vi(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var d=t.alternate;if(null!==d){var c=d.memoizedState;if(null!==c){var p=c.dehydrated;null!==p&&Ut(p)}}}break;default:throw Error(i(163))}Yo||512&t.flags&&al(t)}catch(h){Iu(t,t.return,h)}}if(t===e){Jo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Jo=n;break}Jo=t.return}}function wl(e){for(;null!==Jo;){var t=Jo;if(t===e){Jo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Jo=n;break}Jo=t.return}}function kl(e){for(;null!==Jo;){var t=Jo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{rl(4,t)}catch(l){Iu(t,n,l)}break;case 1:var r=t.stateNode;if("function"===typeof r.componentDidMount){var a=t.return;try{r.componentDidMount()}catch(l){Iu(t,a,l)}}var i=t.return;try{al(t)}catch(l){Iu(t,i,l)}break;case 5:var s=t.return;try{al(t)}catch(l){Iu(t,s,l)}}}catch(l){Iu(t,t.return,l)}if(t===e){Jo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Jo=o;break}Jo=t.return}}var Sl,Il=Math.ceil,Nl=x.ReactCurrentDispatcher,Tl=x.ReactCurrentOwner,_l=x.ReactCurrentBatchConfig,Cl=0,El=null,Al=null,$l=0,Rl=0,Fl=Ia(0),Dl=0,Ml=null,Ol=0,Pl=0,Ll=0,zl=null,Bl=null,Wl=0,Ul=1/0,Vl=null,Gl=!1,Hl=null,jl=null,ql=!1,Kl=null,Xl=0,Yl=0,Ql=null,Jl=-1,Zl=0;function eu(){return 0!==(6&Cl)?Qe():-1!==Jl?Jl:Jl=Qe()}function tu(e){return 0===(1&e.mode)?1:0!==(2&Cl)&&0!==$l?$l&-$l:null!==mi.transition?(0===Zl&&(Zl=mt()),Zl):0!==(e=vt)?e:e=void 0===(e=window.event)?16:Yt(e.type)}function nu(e,t,n,r){if(50<Yl)throw Yl=0,Ql=null,Error(i(185));yt(e,n,r),0!==(2&Cl)&&e===El||(e===El&&(0===(2&Cl)&&(Pl|=n),4===Dl&&ou(e,$l)),ru(e,r),1===n&&0===Cl&&0===(1&t.mode)&&(Ul=Qe()+500,za&&Ua()))}function ru(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,i=e.pendingLanes;0<i;){var s=31-st(i),o=1<<s,l=a[s];-1===l?0!==(o&n)&&0===(o&r)||(a[s]=ht(o,t)):l<=t&&(e.expiredLanes|=o),i&=~o}}(e,t);var r=pt(e,e===El?$l:0);if(0===r)null!==n&&Ke(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Ke(n),1===t)0===e.tag?function(e){za=!0,Wa(e)}(lu.bind(null,e)):Wa(lu.bind(null,e)),sa((function(){0===(6&Cl)&&Ua()})),n=null;else{switch(xt(r)){case 1:n=Ze;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=Eu(n,au.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function au(e,t){if(Jl=-1,Zl=0,0!==(6&Cl))throw Error(i(327));var n=e.callbackNode;if(ku()&&e.callbackNode!==n)return null;var r=pt(e,e===El?$l:0);if(0===r)return null;if(0!==(30&r)||0!==(r&e.expiredLanes)||t)t=gu(e,r);else{t=r;var a=Cl;Cl|=2;var s=fu();for(El===e&&$l===t||(Vl=null,Ul=Qe()+500,pu(e,t));;)try{bu();break}catch(l){hu(e,l)}Ti(),Nl.current=s,Cl=a,null!==Al?t=0:(El=null,$l=0,t=Dl)}if(0!==t){if(2===t&&(0!==(a=ft(e))&&(r=a,t=iu(e,a))),1===t)throw n=Ml,pu(e,0),ou(e,r),ru(e,Qe()),n;if(6===t)ou(e,r);else{if(a=e.current.alternate,0===(30&r)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],i=a.getSnapshot;a=a.value;try{if(!or(i(),a))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(a)&&(2===(t=gu(e,r))&&(0!==(s=ft(e))&&(r=s,t=iu(e,s))),1===t))throw n=Ml,pu(e,0),ou(e,r),ru(e,Qe()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(i(345));case 2:case 5:wu(e,Bl,Vl);break;case 3:if(ou(e,r),(130023424&r)===r&&10<(t=Wl+500-Qe())){if(0!==pt(e,0))break;if(((a=e.suspendedLanes)&r)!==r){eu(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=ra(wu.bind(null,e,Bl,Vl),t);break}wu(e,Bl,Vl);break;case 4:if(ou(e,r),(4194240&r)===r)break;for(t=e.eventTimes,a=-1;0<r;){var o=31-st(r);s=1<<o,(o=t[o])>a&&(a=o),r&=~s}if(r=a,10<(r=(120>(r=Qe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Il(r/1960))-r)){e.timeoutHandle=ra(wu.bind(null,e,Bl,Vl),r);break}wu(e,Bl,Vl);break;default:throw Error(i(329))}}}return ru(e,Qe()),e.callbackNode===n?au.bind(null,e):null}function iu(e,t){var n=zl;return e.current.memoizedState.isDehydrated&&(pu(e,t).flags|=256),2!==(e=gu(e,t))&&(t=Bl,Bl=n,null!==t&&su(t)),e}function su(e){null===Bl?Bl=e:Bl.push.apply(Bl,e)}function ou(e,t){for(t&=~Ll,t&=~Pl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-st(t),r=1<<n;e[n]=-1,t&=~r}}function lu(e){if(0!==(6&Cl))throw Error(i(327));ku();var t=pt(e,0);if(0===(1&t))return ru(e,Qe()),null;var n=gu(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=iu(e,r))}if(1===n)throw n=Ml,pu(e,0),ou(e,t),ru(e,Qe()),n;if(6===n)throw Error(i(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wu(e,Bl,Vl),ru(e,Qe()),null}function uu(e,t){var n=Cl;Cl|=1;try{return e(t)}finally{0===(Cl=n)&&(Ul=Qe()+500,za&&Ua())}}function du(e){null!==Kl&&0===Kl.tag&&0===(6&Cl)&&ku();var t=Cl;Cl|=1;var n=_l.transition,r=vt;try{if(_l.transition=null,vt=1,e)return e()}finally{vt=r,_l.transition=n,0===(6&(Cl=t))&&Ua()}}function cu(){Rl=Fl.current,Na(Fl)}function pu(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,aa(n)),null!==Al)for(n=Al.return;null!==n;){var r=n;switch(ti(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Fa();break;case 3:Yi(),Na(Ea),Na(Ca),ns();break;case 5:Ji(r);break;case 4:Yi();break;case 13:case 19:Na(Zi);break;case 10:_i(r.type._context);break;case 22:case 23:cu()}n=n.return}if(El=e,Al=e=Fu(e.current,null),$l=Rl=t,Dl=0,Ml=null,Ll=Pl=Ol=0,Bl=zl=null,null!==$i){for(t=0;t<$i.length;t++)if(null!==(r=(n=$i[t]).interleaved)){n.interleaved=null;var a=r.next,i=n.pending;if(null!==i){var s=i.next;i.next=a,r.next=s}n.pending=r}$i=null}return e}function hu(e,t){for(;;){var n=Al;try{if(Ti(),rs.current=Qs,us){for(var r=ss.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}us=!1}if(is=0,ls=os=ss=null,ds=!1,cs=0,Tl.current=null,null===n||null===n.return){Dl=1,Ml=t,Al=null;break}e:{var s=e,o=n.return,l=n,u=t;if(t=$l,l.flags|=32768,null!==u&&"object"===typeof u&&"function"===typeof u.then){var d=u,c=l,p=c.tag;if(0===(1&c.mode)&&(0===p||11===p||15===p)){var h=c.alternate;h?(c.updateQueue=h.updateQueue,c.memoizedState=h.memoizedState,c.lanes=h.lanes):(c.updateQueue=null,c.memoizedState=null)}var f=go(o);if(null!==f){f.flags&=-257,yo(f,o,l,0,t),1&f.mode&&mo(s,d,t),u=d;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(u),t.updateQueue=g}else m.add(u);break e}if(0===(1&t)){mo(s,d,t),mu();break e}u=Error(i(426))}else if(ai&&1&l.mode){var y=go(o);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yo(y,o,l,0,t),fi(lo(u,l));break e}}s=u=lo(u,l),4!==Dl&&(Dl=2),null===zl?zl=[s]:zl.push(s),s=o;do{switch(s.tag){case 3:s.flags|=65536,t&=-t,s.lanes|=t,Wi(s,ho(0,u,t));break e;case 1:l=u;var b=s.type,v=s.stateNode;if(0===(128&s.flags)&&("function"===typeof b.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===jl||!jl.has(v)))){s.flags|=65536,t&=-t,s.lanes|=t,Wi(s,fo(s,l,t));break e}}s=s.return}while(null!==s)}xu(n)}catch(x){t=x,Al===n&&null!==n&&(Al=n=n.return);continue}break}}function fu(){var e=Nl.current;return Nl.current=Qs,null===e?Qs:e}function mu(){0!==Dl&&3!==Dl&&2!==Dl||(Dl=4),null===El||0===(268435455&Ol)&&0===(268435455&Pl)||ou(El,$l)}function gu(e,t){var n=Cl;Cl|=2;var r=fu();for(El===e&&$l===t||(Vl=null,pu(e,t));;)try{yu();break}catch(a){hu(e,a)}if(Ti(),Cl=n,Nl.current=r,null!==Al)throw Error(i(261));return El=null,$l=0,Dl}function yu(){for(;null!==Al;)vu(Al)}function bu(){for(;null!==Al&&!Xe();)vu(Al)}function vu(e){var t=Sl(e.alternate,e,Rl);e.memoizedProps=e.pendingProps,null===t?xu(e):Al=t,Tl.current=null}function xu(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qo(n,t,Rl)))return void(Al=n)}else{if(null!==(n=Ko(n,t)))return n.flags&=32767,void(Al=n);if(null===e)return Dl=6,void(Al=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(Al=t);Al=t=e}while(null!==t);0===Dl&&(Dl=5)}function wu(e,t,n){var r=vt,a=_l.transition;try{_l.transition=null,vt=1,function(e,t,n,r){do{ku()}while(null!==Kl);if(0!==(6&Cl))throw Error(i(327));n=e.finishedWork;var a=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(i(177));e.callbackNode=null,e.callbackPriority=0;var s=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-st(n),i=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~i}}(e,s),e===El&&(Al=El=null,$l=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||ql||(ql=!0,Eu(tt,(function(){return ku(),null}))),s=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||s){s=_l.transition,_l.transition=null;var o=vt;vt=1;var l=Cl;Cl|=4,Tl.current=null,function(e,t){if(ea=Gt,hr(e=pr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,s=r.focusNode;r=r.focusOffset;try{n.nodeType,s.nodeType}catch(w){n=null;break e}var o=0,l=-1,u=-1,d=0,c=0,p=e,h=null;t:for(;;){for(var f;p!==n||0!==a&&3!==p.nodeType||(l=o+a),p!==s||0!==r&&3!==p.nodeType||(u=o+r),3===p.nodeType&&(o+=p.nodeValue.length),null!==(f=p.firstChild);)h=p,p=f;for(;;){if(p===e)break t;if(h===n&&++d===a&&(l=o),h===s&&++c===r&&(u=o),null!==(f=p.nextSibling))break;h=(p=h).parentNode}p=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ta={focusedElem:e,selectionRange:n},Gt=!1,Jo=t;null!==Jo;)if(e=(t=Jo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Jo=e;else for(;null!==Jo;){t=Jo;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,v=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var x=t.stateNode.containerInfo;1===x.nodeType?x.textContent="":9===x.nodeType&&x.documentElement&&x.removeChild(x.documentElement);break;default:throw Error(i(163))}}catch(w){Iu(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Jo=e;break}Jo=t.return}m=tl,tl=!1}(e,n),gl(n,e),fr(ta),Gt=!!ea,ta=ea=null,e.current=n,bl(n,e,a),Ye(),Cl=l,vt=o,_l.transition=s}else e.current=n;if(ql&&(ql=!1,Kl=e,Xl=a),s=e.pendingLanes,0===s&&(jl=null),function(e){if(it&&"function"===typeof it.onCommitFiberRoot)try{it.onCommitFiberRoot(at,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),ru(e,Qe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(Gl)throw Gl=!1,e=Hl,Hl=null,e;0!==(1&Xl)&&0!==e.tag&&ku(),s=e.pendingLanes,0!==(1&s)?e===Ql?Yl++:(Yl=0,Ql=e):Yl=0,Ua()}(e,t,n,r)}finally{_l.transition=a,vt=r}return null}function ku(){if(null!==Kl){var e=xt(Xl),t=_l.transition,n=vt;try{if(_l.transition=null,vt=16>e?16:e,null===Kl)var r=!1;else{if(e=Kl,Kl=null,Xl=0,0!==(6&Cl))throw Error(i(331));var a=Cl;for(Cl|=4,Jo=e.current;null!==Jo;){var s=Jo,o=s.child;if(0!==(16&Jo.flags)){var l=s.deletions;if(null!==l){for(var u=0;u<l.length;u++){var d=l[u];for(Jo=d;null!==Jo;){var c=Jo;switch(c.tag){case 0:case 11:case 15:nl(8,c,s)}var p=c.child;if(null!==p)p.return=c,Jo=p;else for(;null!==Jo;){var h=(c=Jo).sibling,f=c.return;if(il(c),c===d){Jo=null;break}if(null!==h){h.return=f,Jo=h;break}Jo=f}}}var m=s.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Jo=s}}if(0!==(2064&s.subtreeFlags)&&null!==o)o.return=s,Jo=o;else e:for(;null!==Jo;){if(0!==(2048&(s=Jo).flags))switch(s.tag){case 0:case 11:case 15:nl(9,s,s.return)}var b=s.sibling;if(null!==b){b.return=s.return,Jo=b;break e}Jo=s.return}}var v=e.current;for(Jo=v;null!==Jo;){var x=(o=Jo).child;if(0!==(2064&o.subtreeFlags)&&null!==x)x.return=o,Jo=x;else e:for(o=v;null!==Jo;){if(0!==(2048&(l=Jo).flags))try{switch(l.tag){case 0:case 11:case 15:rl(9,l)}}catch(k){Iu(l,l.return,k)}if(l===o){Jo=null;break e}var w=l.sibling;if(null!==w){w.return=l.return,Jo=w;break e}Jo=l.return}}if(Cl=a,Ua(),it&&"function"===typeof it.onPostCommitFiberRoot)try{it.onPostCommitFiberRoot(at,e)}catch(k){}r=!0}return r}finally{vt=n,_l.transition=t}}return!1}function Su(e,t,n){e=zi(e,t=ho(0,t=lo(n,t),1),1),t=eu(),null!==e&&(yt(e,1,t),ru(e,t))}function Iu(e,t,n){if(3===e.tag)Su(e,e,n);else for(;null!==t;){if(3===t.tag){Su(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===jl||!jl.has(r))){t=zi(t,e=fo(t,e=lo(n,e),1),1),e=eu(),null!==t&&(yt(t,1,e),ru(t,e));break}}t=t.return}}function Nu(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=eu(),e.pingedLanes|=e.suspendedLanes&n,El===e&&($l&n)===n&&(4===Dl||3===Dl&&(130023424&$l)===$l&&500>Qe()-Wl?pu(e,0):Ll|=n),ru(e,t)}function Tu(e,t){0===t&&(0===(1&e.mode)?t=1:(t=dt,0===(130023424&(dt<<=1))&&(dt=4194304)));var n=eu();null!==(e=Di(e,t))&&(yt(e,t,n),ru(e,n))}function _u(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Tu(e,n)}function Cu(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(i(314))}null!==r&&r.delete(t),Tu(e,n)}function Eu(e,t){return qe(e,t)}function Au(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function $u(e,t,n,r){return new Au(e,t,n,r)}function Ru(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Fu(e,t){var n=e.alternate;return null===n?((n=$u(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Du(e,t,n,r,a,s){var o=2;if(r=e,"function"===typeof e)Ru(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Mu(n.children,a,s,t);case I:o=8,a|=8;break;case N:return(e=$u(12,n,t,2|a)).elementType=N,e.lanes=s,e;case E:return(e=$u(13,n,t,a)).elementType=E,e.lanes=s,e;case A:return(e=$u(19,n,t,a)).elementType=A,e.lanes=s,e;case F:return Ou(n,a,s,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case T:o=10;break e;case _:o=9;break e;case C:o=11;break e;case $:o=14;break e;case R:o=16,r=null;break e}throw Error(i(130,null==e?e:typeof e,""))}return(t=$u(o,n,t,a)).elementType=e,t.type=r,t.lanes=s,t}function Mu(e,t,n,r){return(e=$u(7,e,r,t)).lanes=n,e}function Ou(e,t,n,r){return(e=$u(22,e,r,t)).elementType=F,e.lanes=n,e.stateNode={isHidden:!1},e}function Pu(e,t,n){return(e=$u(6,e,null,t)).lanes=n,e}function Lu(e,t,n){return(t=$u(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zu(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Bu(e,t,n,r,a,i,s,o,l){return e=new zu(e,t,n,o,l),1===t?(t=1,!0===i&&(t|=8)):t=0,i=$u(3,null,null,t),e.current=i,i.stateNode=e,i.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Oi(i),e}function Wu(e){if(!e)return _a;e:{if(Ue(e=e._reactInternals)!==e||1!==e.tag)throw Error(i(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ra(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(i(171))}if(1===e.tag){var n=e.type;if(Ra(n))return Ma(e,n,t)}return t}function Uu(e,t,n,r,a,i,s,o,l){return(e=Bu(n,r,!0,e,0,i,0,o,l)).context=Wu(null),n=e.current,(i=Li(r=eu(),a=tu(n))).callback=void 0!==t&&null!==t?t:null,zi(n,i,a),e.current.lanes=a,yt(e,a,r),ru(e,r),e}function Vu(e,t,n,r){var a=t.current,i=eu(),s=tu(a);return n=Wu(n),null===t.context?t.context=n:t.pendingContext=n,(t=Li(i,s)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=zi(a,t,s))&&(nu(e,a,s,i),Bi(e,a,s)),s}function Gu(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function ju(e,t){Hu(e,t),(e=e.alternate)&&Hu(e,t)}Sl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Ea.current)vo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return vo=!1,function(e,t,n){switch(t.tag){case 3:Eo(t),hi();break;case 5:Qi(t);break;case 1:Ra(t.type)&&Oa(t);break;case 4:Xi(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Ta(ki,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Ta(Zi,1&Zi.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Po(e,t,n):(Ta(Zi,1&Zi.current),null!==(e=Go(e,t,n))?e.sibling:null);Ta(Zi,1&Zi.current);break;case 19:if(r=0!==(n&t.childLanes),0!==(128&e.flags)){if(r)return Uo(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Ta(Zi,Zi.current),r)break;return null;case 22:case 23:return t.lanes=0,Io(e,t,n)}return Go(e,t,n)}(e,t,n);vo=0!==(131072&e.flags)}else vo=!1,ai&&0!==(1048576&t.flags)&&Za(t,ja,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Vo(e,t),e=t.pendingProps;var a=$a(t,Ca.current);Ei(t,n),a=ms(null,t,r,e,a,n);var s=gs();return t.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ra(r)?(s=!0,Oa(t)):s=!1,t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Oi(t),a.updater=ro,t.stateNode=a,a._reactInternals=t,oo(t,r,e,n),t=Co(null,t,r,!0,s,n)):(t.tag=0,ai&&s&&ei(t),xo(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Vo(e,t),e=t.pendingProps,r=(a=r._init)(r._payload),t.type=r,a=t.tag=function(e){if("function"===typeof e)return Ru(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===C)return 11;if(e===$)return 14}return 2}(r),e=to(r,e),a){case 0:t=To(null,t,r,e,n);break e;case 1:t=_o(null,t,r,e,n);break e;case 11:t=wo(null,t,r,e,n);break e;case 14:t=ko(null,t,r,to(r.type,e),n);break e}throw Error(i(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,To(e,t,r,a=t.elementType===r?a:to(r,a),n);case 1:return r=t.type,a=t.pendingProps,_o(e,t,r,a=t.elementType===r?a:to(r,a),n);case 3:e:{if(Eo(t),null===e)throw Error(i(387));r=t.pendingProps,a=(s=t.memoizedState).element,Pi(e,t),Ui(t,r,null,n);var o=t.memoizedState;if(r=o.element,s.isDehydrated){if(s={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=s,t.memoizedState=s,256&t.flags){t=Ao(e,t,r,n,a=lo(Error(i(423)),t));break e}if(r!==a){t=Ao(e,t,r,n,a=lo(Error(i(424)),t));break e}for(ri=ua(t.stateNode.containerInfo.firstChild),ni=t,ai=!0,ii=null,n=wi(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(hi(),r===a){t=Go(e,t,n);break e}xo(e,t,r,n)}t=t.child}return t;case 5:return Qi(t),null===e&&ui(t),r=t.type,a=t.pendingProps,s=null!==e?e.memoizedProps:null,o=a.children,na(r,a)?o=null:null!==s&&na(r,s)&&(t.flags|=32),No(e,t),xo(e,t,o,n),t.child;case 6:return null===e&&ui(t),null;case 13:return Po(e,t,n);case 4:return Xi(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=xi(t,null,r,n):xo(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,wo(e,t,r,a=t.elementType===r?a:to(r,a),n);case 7:return xo(e,t,t.pendingProps,n),t.child;case 8:case 12:return xo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,s=t.memoizedProps,o=a.value,Ta(ki,r._currentValue),r._currentValue=o,null!==s)if(or(s.value,o)){if(s.children===a.children&&!Ea.current){t=Go(e,t,n);break e}}else for(null!==(s=t.child)&&(s.return=t);null!==s;){var l=s.dependencies;if(null!==l){o=s.child;for(var u=l.firstContext;null!==u;){if(u.context===r){if(1===s.tag){(u=Li(-1,n&-n)).tag=2;var d=s.updateQueue;if(null!==d){var c=(d=d.shared).pending;null===c?u.next=u:(u.next=c.next,c.next=u),d.pending=u}}s.lanes|=n,null!==(u=s.alternate)&&(u.lanes|=n),Ci(s.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===s.tag)o=s.type===t.type?null:s.child;else if(18===s.tag){if(null===(o=s.return))throw Error(i(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),Ci(o,n,t),o=s.sibling}else o=s.child;if(null!==o)o.return=s;else for(o=s;null!==o;){if(o===t){o=null;break}if(null!==(s=o.sibling)){s.return=o.return,o=s;break}o=o.return}s=o}xo(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,Ei(t,n),r=r(a=Ai(a)),t.flags|=1,xo(e,t,r,n),t.child;case 14:return a=to(r=t.type,t.pendingProps),ko(e,t,r,a=to(r.type,a),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:to(r,a),Vo(e,t),t.tag=1,Ra(r)?(e=!0,Oa(t)):e=!1,Ei(t,n),io(t,r,a),oo(t,r,a,n),Co(null,t,r,!0,e,n);case 19:return Uo(e,t,n);case 22:return Io(e,t,n)}throw Error(i(156,t.tag))};var qu="function"===typeof reportError?reportError:function(e){console.error(e)};function Ku(e){this._internalRoot=e}function Xu(e){this._internalRoot=e}function Yu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Ju(){}function Zu(e,t,n,r,a){var i=n._reactRootContainer;if(i){var s=i;if("function"===typeof a){var o=a;a=function(){var e=Gu(s);o.call(e)}}Vu(t,s,e,a)}else s=function(e,t,n,r,a){if(a){if("function"===typeof r){var i=r;r=function(){var e=Gu(s);i.call(e)}}var s=Uu(t,r,e,0,null,!1,0,"",Ju);return e._reactRootContainer=s,e[fa]=s.current,Ur(8===e.nodeType?e.parentNode:e),du(),s}for(;a=e.lastChild;)e.removeChild(a);if("function"===typeof r){var o=r;r=function(){var e=Gu(l);o.call(e)}}var l=Bu(e,0,!1,null,0,!1,0,"",Ju);return e._reactRootContainer=l,e[fa]=l.current,Ur(8===e.nodeType?e.parentNode:e),du((function(){Vu(t,l,n,r)})),l}(n,t,e,a,r);return Gu(s)}Xu.prototype.render=Ku.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(i(409));Vu(e,t,null,null)},Xu.prototype.unmount=Ku.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;du((function(){Vu(null,e,null,null)})),t[fa]=null}},Xu.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Ft.length&&0!==t&&t<Ft[n].priority;n++);Ft.splice(n,0,e),0===n&&Pt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=ct(t.pendingLanes);0!==n&&(bt(t,1|n),ru(t,Qe()),0===(6&Cl)&&(Ul=Qe()+500,Ua()))}break;case 13:du((function(){var t=Di(e,1);if(null!==t){var n=eu();nu(t,e,1,n)}})),ju(e,1)}},kt=function(e){if(13===e.tag){var t=Di(e,134217728);if(null!==t)nu(t,e,134217728,eu());ju(e,134217728)}},St=function(e){if(13===e.tag){var t=tu(e),n=Di(e,t);if(null!==n)nu(n,e,t,eu());ju(e,t)}},It=function(){return vt},Nt=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}},ke=function(e,t,n){switch(t){case"input":if(J(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=wa(r);if(!a)throw Error(i(90));q(r),J(r,a)}}}break;case"textarea":ie(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ce=uu,Ee=du;var ed={usingClientEntryPoint:!1,Events:[va,xa,wa,Te,_e,uu]},td={findFiberByHostInstance:ba,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nd={bundleType:td.bundleType,version:td.version,rendererPackageName:td.rendererPackageName,rendererConfig:td.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:x.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=He(e))?null:e.stateNode},findFiberByHostInstance:td.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rd=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rd.isDisabled&&rd.supportsFiber)try{at=rd.inject(nd),it=rd}catch(de){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ed,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yu(t))throw Error(i(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yu(e))throw Error(i(299));var n=!1,r="",a=qu;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(a=t.onRecoverableError)),t=Bu(e,1,!1,null,0,n,0,r,a),e[fa]=t.current,Ur(8===e.nodeType?e.parentNode:e),new Ku(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw e=Object.keys(e).join(","),Error(i(268,e))}return e=null===(e=He(t))?null:e.stateNode},t.flushSync=function(e){return du(e)},t.hydrate=function(e,t,n){if(!Qu(t))throw Error(i(200));return Zu(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yu(e))throw Error(i(405));var r=null!=n&&n.hydratedSources||null,a=!1,s="",o=qu;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(s=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Uu(t,null,e,1,null!=n?n:null,a,0,s,o),e[fa]=t.current,Ur(e),r)for(e=0;e<r.length;e++)a=(a=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new Xu(t)},t.render=function(e,t,n){if(!Qu(t))throw Error(i(200));return Zu(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Qu(e))throw Error(i(40));return!!e._reactRootContainer&&(du((function(){Zu(null,null,e,!1,(function(){e._reactRootContainer=null,e[fa]=null}))})),!0)},t.unstable_batchedUpdates=uu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Qu(n))throw Error(i(200));if(null==e||void 0===e._reactInternals)throw Error(i(38));return Zu(e,t,n,!1,r)},t.version="18.3.1-next-f1338f8080-20240426"},391:(e,t,n)=>{"use strict";var r=n(950);t.createRoot=r.createRoot,t.hydrateRoot=r.hydrateRoot},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},153:(e,t,n)=>{"use strict";var r=n(43),a=Symbol.for("react.element"),i=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var r,i={},u=null,d=null;for(r in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(d=t.ref),t)s.call(t,r)&&!l.hasOwnProperty(r)&&(i[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===i[r]&&(i[r]=t[r]);return{$$typeof:a,type:e,key:u,ref:d,props:i,_owner:o.current}}t.Fragment=i,t.jsx=u,t.jsxs=u},202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),d=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),p=Symbol.for("react.lazy"),h=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function N(e,t,r){var a,i={},s=null,o=null;if(null!=t)for(a in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(s=""+t.key),t)k.call(t,a)&&!I.hasOwnProperty(a)&&(i[a]=t[a]);var l=arguments.length-2;if(1===l)i.children=r;else if(1<l){for(var u=Array(l),d=0;d<l;d++)u[d]=arguments[d+2];i.children=u}if(e&&e.defaultProps)for(a in l=e.defaultProps)void 0===i[a]&&(i[a]=l[a]);return{$$typeof:n,type:e,key:s,ref:o,props:i,_owner:S.current}}function T(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var _=/\/+/g;function C(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function E(e,t,a,i,s){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0}}if(l)return s=s(l=e),e=""===i?"."+C(l,0):i,w(s)?(a="",null!=e&&(a=e.replace(_,"$&/")+"/"),E(s,t,a,"",(function(e){return e}))):null!=s&&(T(s)&&(s=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(s,a+(!s.key||l&&l.key===s.key?"":(""+s.key).replace(_,"$&/")+"/")+e)),t.push(s)),1;if(l=0,i=""===i?".":i+":",w(e))for(var u=0;u<e.length;u++){var d=i+C(o=e[u],u);l+=E(o,t,a,d,s)}else if(d=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=h&&e[h]||e["@@iterator"])?e:null}(e),"function"===typeof d)for(e=d.call(e),u=0;!(o=e.next()).done;)l+=E(o=o.value,t,a,d=i+C(o,u++),s);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function A(e,t,n){if(null==e)return e;var r=[],a=0;return E(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function $(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var R={current:null},F={transition:null},D={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:F,ReactCurrentOwner:S};function M(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:A,forEach:function(e,t,n){A(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return A(e,(function(){t++})),t},toArray:function(e){return A(e,(function(e){return e}))||[]},only:function(e){if(!T(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=a,t.Profiler=s,t.PureComponent=v,t.StrictMode=i,t.Suspense=d,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=M,t.cloneElement=function(e,t,r){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var a=m({},e.props),i=e.key,s=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,o=S.current),void 0!==t.key&&(i=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)k.call(t,u)&&!I.hasOwnProperty(u)&&(a[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)a.children=r;else if(1<u){l=Array(u);for(var d=0;d<u;d++)l[d]=arguments[d+2];a.children=l}return{$$typeof:n,type:e.type,key:i,ref:s,props:a,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=N,t.createFactory=function(e){var t=N.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=T,t.lazy=function(e){return{$$typeof:p,_payload:{_status:-1,_result:e},_init:$}},t.memo=function(e,t){return{$$typeof:c,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=F.transition;F.transition={};try{e()}finally{F.transition=t}},t.unstable_act=M,t.useCallback=function(e,t){return R.current.useCallback(e,t)},t.useContext=function(e){return R.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return R.current.useDeferredValue(e)},t.useEffect=function(e,t){return R.current.useEffect(e,t)},t.useId=function(){return R.current.useId()},t.useImperativeHandle=function(e,t,n){return R.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return R.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return R.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return R.current.useMemo(e,t)},t.useReducer=function(e,t,n){return R.current.useReducer(e,t,n)},t.useRef=function(e){return R.current.useRef(e)},t.useState=function(e){return R.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return R.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return R.current.useTransition()},t.version="18.3.1"},43:(e,t,n)=>{"use strict";e.exports=n(202)},579:(e,t,n)=>{"use strict";e.exports=n(153)},234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<i(a,t)))break e;e[r]=t,e[n]=a,n=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,s=a>>>1;r<s;){var o=2*(r+1)-1,l=e[o],u=o+1,d=e[u];if(0>i(l,n))u<a&&0>i(d,l)?(e[r]=d,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<a&&0>i(d,n)))break e;e[r]=d,e[u]=n,r=u}}}return t}function i(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var s=performance;t.unstable_now=function(){return s.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],d=[],c=1,p=null,h=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function x(e){for(var t=r(d);null!==t;){if(null===t.callback)a(d);else{if(!(t.startTime<=e))break;a(d),t.sortIndex=t.expirationTime,n(u,t)}t=r(d)}}function w(e){if(g=!1,x(e),!m)if(null!==r(u))m=!0,F(k);else{var t=r(d);null!==t&&D(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(T),T=-1),f=!0;var i=h;try{for(x(n),p=r(u);null!==p&&(!(p.expirationTime>n)||e&&!E());){var s=p.callback;if("function"===typeof s){p.callback=null,h=p.priorityLevel;var o=s(p.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?p.callback=o:p===r(u)&&a(u),x(n)}else a(u);p=r(u)}if(null!==p)var l=!0;else{var c=r(d);null!==c&&D(w,c.startTime-n),l=!1}return l}finally{p=null,h=i,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,N=null,T=-1,_=5,C=-1;function E(){return!(t.unstable_now()-C<_)}function A(){if(null!==N){var e=t.unstable_now();C=e;var n=!0;try{n=N(!0,e)}finally{n?S():(I=!1,N=null)}}else I=!1}if("function"===typeof v)S=function(){v(A)};else if("undefined"!==typeof MessageChannel){var $=new MessageChannel,R=$.port2;$.port1.onmessage=A,S=function(){R.postMessage(null)}}else S=function(){y(A,0)};function F(e){N=e,I||(I=!0,S())}function D(e,n){T=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,F(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):_=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return h},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(h){case 1:case 2:case 3:var t=3;break;default:t=h}var n=h;h=t;try{return e()}finally{h=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=h;h=e;try{return t()}finally{h=n}},t.unstable_scheduleCallback=function(e,a,i){var s=t.unstable_now();switch("object"===typeof i&&null!==i?i="number"===typeof(i=i.delay)&&0<i?s+i:s:i=s,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:c++,callback:a,priorityLevel:e,startTime:i,expirationTime:o=i+o,sortIndex:-1},i>s?(e.sortIndex=i,n(d,e),null===r(u)&&e===r(d)&&(g?(b(T),T=-1):g=!0,D(w,i-s))):(e.sortIndex=o,n(u,e),m||f||(m=!0,F(k))),e},t.unstable_shouldYield=E,t.unstable_wrapCallback=function(e){var t=h;return function(){var n=h;h=t;try{return e.apply(this,arguments)}finally{h=n}}}},853:(e,t,n)=>{"use strict";e.exports=n(234)}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}n.amdO={},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.p="https://AnastasiaVerich.github.io/app_check_face/",(()=>{"use strict";var e={};n.r(e),n.d(e,{hasBrowserEnv:()=>P1,hasStandardBrowserEnv:()=>z1,hasStandardBrowserWebWorkerEnv:()=>B1,navigator:()=>L1,origin:()=>W1});var t=n(43),r=n(391);const a=(e,t)=>{const n=atob(e.split(",")[1]),r=new ArrayBuffer(n.length),a=new Uint8Array(r);for(let i=0;i<n.length;i++)a[i]=n.charCodeAt(i);return new Blob([a],{type:t})};function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return[e,...(arguments.length>2&&void 0!==arguments[2]?arguments[2]:[]).filter(Boolean),...Object.entries(t).filter((e=>{let[t,n]=e;return Boolean(n)})).map((e=>{let[t]=e;return t}))].join(" ")}var s=n(579);const o=e=>{const{children:t,className:n,clickable:r,disabled:a,onClick:o=()=>{},max:l}=e,u={max:l,clickable:r,disabled:a};return(0,s.jsx)("div",{className:i("section",u,[n]),onClick:o,children:t})},l=e=>{let{videoRef:n,isShow:r,isFaceDetected:a,canvasRef:i}=e;const[l,u]=(0,t.useState)(!1);return(0,s.jsxs)(o,{className:"video_box'}",children:[(0,s.jsx)("video",{className:"video_online "+(l?"":"hide"),ref:n,playsInline:!0,autoPlay:!0,muted:!0,controls:!1,onLoadedMetadata:()=>{u(!0)}}),(0,s.jsx)("canvas",{ref:i,className:"canvas"}),(0,s.jsx)("div",{className:"face_overlay "+(a?"ok":"err")})]})},u=e=>{let{photoUrl:t}=e;return t?(0,s.jsx)("div",{className:"img_box",children:(0,s.jsx)("img",{className:"img",src:null!==t&&void 0!==t?t:"",alt:"\u0421\u0434\u0435\u043b\u0430\u043d\u043d\u043e\u0435 \u0444\u043e\u0442\u043e"})}):(0,s.jsx)(s.Fragment,{})};var d="/index.js",c=Object.defineProperty,p=n(291),h=(e,t)=>{for(var n in t)c(e,n,{get:t[n],enumerable:!0})};h({},{Abs:()=>Xe,Acos:()=>Ye,Acosh:()=>Qe,AdadeltaOptimizer:()=>Lh,AdagradOptimizer:()=>zh,AdamOptimizer:()=>Bh,AdamaxOptimizer:()=>Wh,Add:()=>Je,AddN:()=>Ze,All:()=>et,Any:()=>tt,ArgMax:()=>nt,ArgMin:()=>rt,Asin:()=>at,Asinh:()=>it,Atan:()=>st,Atan2:()=>lt,Atanh:()=>ot,AvgPool:()=>ut,AvgPool3D:()=>ct,AvgPool3DGrad:()=>pt,AvgPoolGrad:()=>dt,BackendWasm:()=>kQ,BatchMatMul:()=>ht,BatchToSpaceND:()=>ft,Bincount:()=>mt,BitwiseAnd:()=>gt,BroadcastArgs:()=>bt,BroadcastTo:()=>yt,Callback:()=>bT,CallbackList:()=>Zx,Cast:()=>vt,Ceil:()=>xt,ClipByValue:()=>wt,Complex:()=>kt,ComplexAbs:()=>St,Concat:()=>It,Conv2D:()=>Nt,Conv2DBackpropFilter:()=>Tt,Conv2DBackpropInput:()=>_t,Conv3D:()=>Ct,Conv3DBackpropFilterV2:()=>Et,Conv3DBackpropInputV2:()=>At,Cos:()=>$t,Cosh:()=>Rt,CropAndResize:()=>Mt,Cumprod:()=>Ft,Cumsum:()=>Dt,CustomCallback:()=>nw,DataStorage:()=>G,DenseBincount:()=>Ot,DepthToSpace:()=>Pt,DepthwiseConv2dNative:()=>Lt,DepthwiseConv2dNativeBackpropFilter:()=>zt,DepthwiseConv2dNativeBackpropInput:()=>Bt,Diag:()=>Wt,Dilation2D:()=>Ut,Dilation2DBackpropFilter:()=>Gt,Dilation2DBackpropInput:()=>Vt,Draw:()=>Ht,ENV:()=>je,EarlyStopping:()=>wT,Einsum:()=>qt,Elu:()=>Kt,EluGrad:()=>Xt,Environment:()=>Ue,Equal:()=>Qt,Erf:()=>Yt,Exp:()=>Jt,ExpandDims:()=>Zt,Expm1:()=>en,FFT:()=>tn,Fill:()=>nn,FlipLeftRight:()=>rn,Floor:()=>an,FloorDiv:()=>sn,FromPixels:()=>ua,FusedBatchNorm:()=>on,FusedConv2D:()=>pa,FusedDepthwiseConv2D:()=>ha,GPGPUContext:()=>xL,GatherNd:()=>un,GatherV2:()=>ln,GraphModel:()=>uC,Greater:()=>dn,GreaterEqual:()=>cn,History:()=>tw,IFFT:()=>hn,Identity:()=>pn,Imag:()=>fn,InputSpec:()=>tx,IsFinite:()=>mn,IsInf:()=>gn,IsNan:()=>yn,KernelBackend:()=>H,LRN:()=>An,LRNGrad:()=>$n,LayerVariable:()=>Jv,LayersModel:()=>rk,LeakyRelu:()=>bn,Less:()=>vn,LessEqual:()=>xn,LinSpace:()=>wn,Log:()=>kn,Log1p:()=>Sn,LogSoftmax:()=>Cn,LogicalAnd:()=>In,LogicalNot:()=>Nn,LogicalOr:()=>Tn,LogicalXor:()=>_n,LowerBound:()=>En,MathBackendCPU:()=>CE,MathBackendWebGL:()=>Mz,MatrixBandPart:()=>Rn,Max:()=>Fn,MaxPool:()=>Mn,MaxPool3D:()=>Pn,MaxPool3DGrad:()=>Ln,MaxPoolGrad:()=>On,MaxPoolWithArgmax:()=>zn,Maximum:()=>Dn,Mean:()=>Bn,Min:()=>Wn,Minimum:()=>Un,MirrorPad:()=>Vn,Mod:()=>Gn,MomentumOptimizer:()=>Vh,Multinomial:()=>Hn,Multiply:()=>jn,Neg:()=>qn,NonMaxSuppressionV3:()=>Xn,NonMaxSuppressionV4:()=>Yn,NonMaxSuppressionV5:()=>Qn,NotEqual:()=>Kn,OP_SCOPE_SUFFIX:()=>Hi,OneHot:()=>Zn,OnesLike:()=>Jn,Optimizer:()=>Ph,OptimizerConstructors:()=>Xf,Pack:()=>er,PadV2:()=>tr,Pool:()=>nr,Pow:()=>rr,Prelu:()=>ar,Prod:()=>ir,RMSPropOptimizer:()=>Gh,RNN:()=>cS,RaggedGather:()=>sr,RaggedRange:()=>or,RaggedTensorToTensor:()=>lr,Range:()=>ur,Rank:()=>ci,Real:()=>dr,RealDiv:()=>jt,Reciprocal:()=>cr,Reduction:()=>ah,Relu:()=>pr,Relu6:()=>br,Reshape:()=>hr,ResizeBilinear:()=>gr,ResizeBilinearGrad:()=>yr,ResizeNearestNeighbor:()=>fr,ResizeNearestNeighborGrad:()=>mr,Reverse:()=>vr,RotateWithOffset:()=>da,Round:()=>xr,Rsqrt:()=>wr,SGDOptimizer:()=>Uh,ScatterNd:()=>kr,SearchSorted:()=>Ir,Select:()=>Nr,Selu:()=>Tr,Sequential:()=>ok,Sigmoid:()=>$r,Sign:()=>Ar,Sin:()=>Cr,Sinh:()=>Er,Slice:()=>_r,Softmax:()=>Pr,Softplus:()=>Rr,SpaceToBatchND:()=>Mr,SparseFillEmptyRows:()=>Lr,SparseReshape:()=>zr,SparseSegmentMean:()=>Br,SparseSegmentSum:()=>Wr,SparseToDense:()=>Ur,SplitV:()=>Or,Sqrt:()=>Fr,Square:()=>Gr,SquaredDifference:()=>Vr,StaticRegexReplace:()=>Hr,Step:()=>la,StridedSlice:()=>jr,StringNGrams:()=>qr,StringSplit:()=>Kr,StringToHashBucketFast:()=>Xr,Sub:()=>Yr,Sum:()=>Dr,SymbolicTensor:()=>nx,Tan:()=>Qr,Tanh:()=>Jr,Tensor:()=>li,TensorBuffer:()=>ii,TensorScatterUpdate:()=>Sr,Tile:()=>Zr,TopK:()=>ea,Transform:()=>ta,Transpose:()=>na,Unique:()=>ra,Unpack:()=>aa,UnsortedSegmentSum:()=>ia,UpperBound:()=>sa,Variable:()=>di,ZerosLike:()=>oa,_FusedMatMul:()=>ca,abs:()=>No,acos:()=>To,acosh:()=>_o,add:()=>wo,addN:()=>Co,all:()=>Eo,any:()=>Ao,argMax:()=>$o,argMin:()=>Ro,asin:()=>Fo,asinh:()=>Do,atan:()=>Mo,atan2:()=>Oo,atanh:()=>Po,avgPool:()=>el,avgPool3d:()=>tl,backend:()=>ys,backend_util:()=>em,basicLSTMCell:()=>ol,batchNorm:()=>dl,batchNorm2d:()=>cl,batchNorm3d:()=>pl,batchNorm4d:()=>hl,batchToSpaceND:()=>ll,bincount:()=>fl,bitwiseAnd:()=>ml,booleanMaskAsync:()=>ip,broadcastArgs:()=>gl,broadcastTo:()=>yl,broadcast_util:()=>Wl,browser:()=>gf,buffer:()=>yo,callbacks:()=>IT,cast:()=>bo,ceil:()=>bl,clipByValue:()=>xl,clone:()=>vo,complex:()=>qi,concat:()=>nl,concat1d:()=>wl,concat2d:()=>kl,concat3d:()=>Sl,concat4d:()=>Il,constraints:()=>yx,conv1d:()=>Tl,conv2d:()=>Nl,conv2dTranspose:()=>Cl,conv3d:()=>El,conv3dTranspose:()=>$l,copyRegisteredKernels:()=>Na,cos:()=>Rl,cosh:()=>Fl,cosineWindow:()=>hp,cumprod:()=>Dl,cumsum:()=>Ml,customGrad:()=>Vu,data:()=>hC,denseBincount:()=>Ol,deprecationWarn:()=>ts,depthToSpace:()=>Pl,depthwiseConv2d:()=>Ll,deregisterOp:()=>CT,device_util:()=>Mi,diag:()=>zl,dilation2d:()=>Bl,disableDeprecationWarnings:()=>es,dispose:()=>os,disposeVariables:()=>ns,div:()=>So,divNoNan:()=>Kl,dot:()=>Xl,dropout:()=>cp,einsum:()=>Yl,elu:()=>Ql,enableDebugMode:()=>Zi,enableProdMode:()=>Ji,enclosingPowerOfTwo:()=>pp,engine:()=>rs,ensureShape:()=>Jl,env:()=>Ge,equal:()=>Hl,erf:()=>Zl,euclideanNorm:()=>yu,exp:()=>bu,expandDims:()=>vu,expm1:()=>xu,eye:()=>ku,fft:()=>Cc,fill:()=>vl,findBackend:()=>fs,findBackendFactory:()=>ms,floor:()=>Su,floorDiv:()=>ko,forceHalfFloat:()=>Pz,fused:()=>mp,gather:()=>Iu,gatherND:()=>dp,gather_util:()=>Tf,getBackend:()=>ps,getGradient:()=>va,getKernel:()=>ba,getKernelsForBackend:()=>xa,getThreadsCount:()=>OQ,gpgpu_util:()=>QP,grad:()=>Lu,grads:()=>zu,greater:()=>Nu,greaterEqual:()=>Tu,ifft:()=>Ec,imag:()=>_u,image:()=>Nh,inTopKAsync:()=>fp,initializers:()=>Rx,input:()=>dk,io:()=>jh,irfft:()=>Ac,isFinite:()=>Cu,isInf:()=>Eu,isNaN:()=>Au,keep:()=>ls,kernel_impls:()=>sg,layers:()=>Xx,leakyRelu:()=>$u,less:()=>Ru,lessEqual:()=>Fu,linalg:()=>Th,linspace:()=>Du,loadGraphModel:()=>dC,loadGraphModelSync:()=>cC,loadLayersModel:()=>sk,localResponseNormalization:()=>Mu,log:()=>Ou,log1p:()=>Pu,logSigmoid:()=>qu,logSoftmax:()=>Xu,logSumExp:()=>Yu,logicalAnd:()=>Qu,logicalNot:()=>Ju,logicalOr:()=>Zu,logicalXor:()=>ed,losses:()=>_h,lowerBound:()=>rd,matMul:()=>rl,math:()=>ff,max:()=>lu,maxPool:()=>ad,maxPool3d:()=>id,maxPoolWithArgmax:()=>sd,maximum:()=>od,mean:()=>ld,memory:()=>as,meshgrid:()=>cd,metrics:()=>YN,min:()=>uu,minimum:()=>pd,mirrorPad:()=>hd,mod:()=>fd,model:()=>lk,models:()=>hT,moments:()=>md,movingAverage:()=>op,mul:()=>Io,multiRNNCell:()=>gd,multinomial:()=>yd,neg:()=>Hu,nextFrame:()=>Jf,norm:()=>gu,notEqual:()=>bd,oneHot:()=>vd,ones:()=>dd,onesLike:()=>xd,op:()=>ji,outerProduct:()=>wd,pad:()=>kd,pad1d:()=>Sd,pad2d:()=>Id,pad3d:()=>Nd,pad4d:()=>Td,pool:()=>Cd,pow:()=>du,prelu:()=>Ed,print:()=>xo,prod:()=>Ad,profile:()=>is,raggedGather:()=>$d,raggedRange:()=>Rd,raggedTensorToTensor:()=>Fd,rand:()=>Dd,randomGamma:()=>ec,randomNormal:()=>tc,randomStandardNormal:()=>nc,randomUniform:()=>rc,randomUniformInt:()=>ac,range:()=>ic,ready:()=>cs,real:()=>sc,reciprocal:()=>oc,registerBackend:()=>gs,registerCallbackConstructor:()=>ck,registerGradient:()=>ka,registerKernel:()=>wa,registerOp:()=>TT,regularizers:()=>fT,relu:()=>lc,relu6:()=>uc,removeBackend:()=>hs,reshape:()=>Zo,reverse:()=>dc,reverse1d:()=>cc,reverse2d:()=>pc,reverse3d:()=>hc,reverse4d:()=>fc,rfft:()=>Rc,round:()=>mc,rsqrt:()=>gc,scalar:()=>cu,scatterND:()=>lp,scatter_util:()=>Hc,searchSorted:()=>nd,selu:()=>yc,separableConv2d:()=>bc,sequential:()=>uk,serialization:()=>Ah,setBackend:()=>ds,setPlatform:()=>bs,setThreadsCount:()=>MQ,setWasmPath:()=>$Q,setWasmPaths:()=>RQ,setWebGLContext:()=>mO,setdiff1dAsync:()=>vc,shared:()=>EE,sigmoid:()=>al,sign:()=>xc,signal:()=>Ih,sin:()=>wc,sinh:()=>kc,slice:()=>il,slice1d:()=>Sc,slice2d:()=>Ic,slice3d:()=>Nc,slice4d:()=>Tc,slice_util:()=>Cf,softmax:()=>_c,softplus:()=>ju,spaceToBatchND:()=>_d,sparse:()=>Ch,sparseToDense:()=>up,spectral:()=>Sh,split:()=>$c,sqrt:()=>pu,square:()=>hu,squaredDifference:()=>Fc,squeeze:()=>Dc,stack:()=>Mc,step:()=>Oc,stridedSlice:()=>Pc,string:()=>Eh,sub:()=>Ku,sum:()=>fu,sumOutType:()=>xi,tan:()=>Lc,tanh:()=>sl,tensor:()=>Xi,tensor1d:()=>zc,tensor2d:()=>Bc,tensor3d:()=>Wc,tensor4d:()=>Uc,tensor5d:()=>Vc,tensor6d:()=>Gc,tensorScatterUpdate:()=>Xc,tensor_util:()=>yi,test_util:()=>Od,tidy:()=>ss,tile:()=>wu,time:()=>us,topk:()=>Yc,train:()=>Yf,transpose:()=>sp,truncatedNormal:()=>Qc,unique:()=>Jc,unregisterGradient:()=>Ia,unregisterKernel:()=>Sa,unsortedSegmentSum:()=>Zc,unstack:()=>ep,upcastType:()=>vi,upperBound:()=>tp,util:()=>_a,valueAndGrad:()=>Bu,valueAndGrads:()=>Wu,variable:()=>np,variableGrads:()=>Uu,version:()=>zQ,version_converter:()=>pC,version_core:()=>Kf,version_cpu:()=>nR,version_layers:()=>Lw,version_wasm:()=>PQ,version_webgl:()=>Oz,webgl:()=>Lz,webgl_util:()=>uO,where:()=>jl,whereAsync:()=>ap,zeros:()=>ud,zerosLike:()=>ql});var f=Object.create,m=Object.defineProperty,g=Object.getOwnPropertyDescriptor,y=Object.getOwnPropertyNames,b=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty,x=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),w=(e,t)=>{for(var n in t)m(e,n,{get:t[n],enumerable:!0})},k=(e,t,n)=>(n=null!=e?f(b(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of y(t))!v.call(e,a)&&a!==n&&m(e,a,{get:()=>t[a],enumerable:!(r=g(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:m(n,"default",{value:e,enumerable:!0}),e)),S=x(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(T){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var i={},s={};function o(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=s[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(s[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=i[e])?r:(n=u(e,e<0?-1:0,!1),a&&(i[e]=n),n)}function l(e,t){if(isNaN(e))return t?b:y;if(t){if(e<0)return b;if(e>=f)return S}else{if(e<=-m)return I;if(e+1>=m)return k}return e<0?l(-e,t).neg():u(e%h|0,e/h|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var d=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return y;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=l(d(n,8)),i=y,s=0;s<e.length;s+=8){var o=Math.min(8,e.length-s),u=parseInt(e.substring(s,s+o),n);if(o<8){var p=l(d(n,o));i=i.mul(p).add(l(u))}else i=(i=i.mul(a)).add(l(u))}return i.unsigned=t,i}function p(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=c,r.fromValue=p;var h=4294967296,f=h*h,m=f/2,g=o(1<<24),y=o(0);r.ZERO=y;var b=o(0,!0);r.UZERO=b;var v=o(1);r.ONE=v;var x=o(1,!0);r.UONE=x;var w=o(-1);r.NEG_ONE=w;var k=u(-1,2147483647,!1);r.MAX_VALUE=k;var S=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=S;var I=u(0,-2147483648,!1);r.MIN_VALUE=I;var N=r.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(d(e,6),this.unsigned),i=this,s="";;){var o=i.div(a),u=(i.sub(o.mul(a)).toInt()>>>0).toString(e);if((i=o).isZero())return u+s;for(;u.length<6;)u="0"+u;s=""+u+s}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1===(1&this.low)},N.isEven=function(){return 0===(1&this.low)},N.equals=function(e){return a(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(a(e)||(e=p(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(v)},N.neg=N.negate,N.add=function(e){a(e)||(e=p(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,i=65535&this.low,s=e.high>>>16,o=65535&e.high,l=e.low>>>16,d=0,c=0,h=0,f=0;return h+=(f+=i+(65535&e.low))>>>16,c+=(h+=r+l)>>>16,d+=(c+=n+o)>>>16,d+=t+s,u((h&=65535)<<16|(f&=65535),(d&=65535)<<16|(c&=65535),this.unsigned)},N.subtract=function(e){return a(e)||(e=p(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return y;if(a(e)||(e=p(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return y;if(this.eq(I))return e.isOdd()?I:y;if(e.eq(I))return this.isOdd()?I:y;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,i=this.low>>>16,s=65535&this.low,o=e.high>>>16,d=65535&e.high,c=e.low>>>16,h=65535&e.low,f=0,m=0,b=0,v=0;return b+=(v+=s*h)>>>16,m+=(b+=i*h)>>>16,b&=65535,m+=(b+=s*c)>>>16,f+=(m+=r*h)>>>16,m&=65535,f+=(m+=i*c)>>>16,m&=65535,f+=(m+=s*d)>>>16,f+=t*h+r*c+i*d+s*o,u((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(a(e)||(e=p(e)),e.isZero())throw Error("division by zero");var t,r,i;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:y;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;i=b}else{if(this.eq(I))return e.eq(v)||e.eq(w)?I:e.eq(I)?v:(t=this.shr(1).div(e).shl(1)).eq(y)?e.isNegative()?v:w:(r=this.sub(e.mul(t)),i=t.add(r.div(e)));if(e.eq(I))return this.unsigned?b:y;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=y}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(t)/Math.LN2),o=s<=48?1:d(2,s-48),c=l(t),h=c.mul(e);h.isNegative()||h.gt(r);)h=(c=l(t-=o,this.unsigned)).mul(e);c.isZero()&&(c=v),i=i.add(c),r=r.sub(h)}return i},N.div=N.divide,N.modulo=function(e){return a(e)||(e=p(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return u(~this.low,~this.high,this.unsigned)},N.and=function(e){return a(e)||(e=p(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return a(e)||(e=p(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return a(e)||(e=p(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),I=x((()=>{})),N=x((()=>{})),T=x(((e,t)=>{!function(e,t,n){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function i(e,t){var n=new r(e),i=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,i&&("object"==typeof i&&a(i,n),s.state=function(){return a(n,{})}),s}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.alea=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),_=x(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function i(e,t){var n=new r(e),i=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,i&&("object"==typeof i&&a(i,n),s.state=function(){return a(n,{})}),s}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xor128=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),C=x(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function i(e,t){var n=new r(e),i=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,i&&("object"==typeof i&&a(i,n),s.state=function(){return a(n,{})}),s}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xorwow=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),E=x(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function i(e,t){null==e&&(e=+new Date);var n=new r(e),i=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,i&&(i.x&&a(i,n),s.state=function(){return a(n,{})}),s}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xorshift7=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),A=x(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,i=t.i;return t.w=r=r+1640531527|0,n=a[i+34&127],e=a[i=i+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[i]=n^e,t.i=i,n+(r^r>>>16)|0},function(e,t){var n,r,a,i,s,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,i=-32;i<l;++i)t&&(r^=t.charCodeAt((i+32)%t.length)),0===i&&(s=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(s=s+1640531527|0,a=0==(n=o[127&i]^=r+s)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,i=512;i>0;--i)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=s,e.X=o,e.i=a}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function i(e,t){null==e&&(e=+new Date);var n=new r(e),i=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,i&&(i.X&&a(i,n),s.state=function(){return a(n,{})}),s}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xor4096=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),$=x(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function i(e,t){var n=new r(e),i=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,i&&("object"==typeof i&&a(i,n),s.state=function(){return a(n,{})}),s}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.tychei=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),R=x((()=>{})),F=x(((e,t)=>{!function(e,r,a){var i,s=256,o="random",l=a.pow(s,6),u=a.pow(2,52),d=2*u,c=255;function p(t,n,c){var p=[],b=g(m((n=1==n?{entropy:!0}:n||{}).entropy?[t,y(r)]:null==t?function(){try{var t;return i&&(t=i.randomBytes)?t=t(s):(t=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(t)),y(t)}catch(p){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,y(r)]}}():t,3),p),v=new h(p),x=function(){for(var e=v.g(6),t=l,n=0;e<u;)e=(e+n)*s,t*=s,n=v.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|v.g(4)},x.quick=function(){return v.g(4)/4294967296},x.double=x,g(y(v.S),r),(n.pass||c||function(e,t,n,r){return r&&(r.S&&f(r,v),e.state=function(){return f(v,{})}),n?(a[o]=e,t):e})(x,b,"global"in n?n.global:this==a,n.state)}function h(e){var t,n=e.length,r=this,a=0,i=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<s;)o[a]=a++;for(a=0;a<s;a++)o[a]=o[i=c&i+e[a%n]+(t=o[a])],o[i]=t;(r.g=function(e){for(var t,n=0,a=r.i,i=r.j,o=r.S;e--;)t=o[a=c&a+1],n=n*s+o[c&(o[a]=o[i=c&i+t])+(o[i]=t)];return r.i=a,r.j=i,n})(s)}function f(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(m(e[n],t-1))}catch(i){}return r.length?r:"string"==a?e:e+"\0"}function g(e,t){for(var n,r=e+"",a=0;a<r.length;)t[c&a]=c&(n^=19*t[c&a])+r.charCodeAt(a++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(g(a.random(),r),"object"==typeof t&&t.exports){t.exports=p;try{i=R()}catch(b){}}else"function"==typeof define&&n.amdO?define((function(){return p})):a["seed"+o]=p}("undefined"!=typeof self?self:e,[],Math)})),D=x(((e,t)=>{var n=T(),r=_(),a=C(),i=E(),s=A(),o=$(),l=F();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=i,l.xor4096=s,l.tychei=o,t.exports=l})),M=x((()=>{})),O=x((()=>{})),P=x((()=>{})),L=x((()=>{})),z=x((()=>{})),B=x((()=>{})),W=x(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||d,function(t){function r(){return $.buffer!=M&&X($.buffer),U}function a(){return $.buffer!=M&&X($.buffer),V}function i(){return $.buffer!=M&&X($.buffer),G}function s(){return $.buffer!=M&&X($.buffer),H}var o,l,u,d="undefined"!=typeof(t=t||{})?t:{};d.ready=new Promise((function(e,t){o=e,l=t})),"undefined"!=typeof process&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c,p,h,f=Object.assign({},d),m=[],g=(e,t)=>{throw t},y="object"==typeof window,b="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=d.ENVIRONMENT_IS_PTHREAD||!1,w="";function k(e){return d.locateFile?d.locateFile(e,w):w+e}if(v){var S=O(),I=P();let e;w=b?I.dirname(w)+"/":"//",c=(e,t)=>(e=ue(e)?new URL(e):I.normalize(e),S.readFileSync(e,t?void 0:"utf8")),h=e=>{var t=c(e,!0);return t.buffer||(t=new Uint8Array(t)),t},p=(e,t,n)=>{e=ue(e)?new URL(e):I.normalize(e),S.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),m=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof pe))throw e})),process.on("unhandledRejection",(function(e){throw e})),g=(e,t)=>{if(te())throw process.exitCode=e,t;(function(e){e instanceof pe||C("exiting due to exception: "+e)})(t),process.exit(e)},d.inspect=function(){return"[Emscripten Module object]"};try{e=L()}catch(et){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),et}n.g.Worker=e.Worker}else(y||b)&&(b?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),"undefined"!=typeof e&&e&&(w=e),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},b&&(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),p=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}),e=>document.title=e);v&&"undefined"==typeof performance&&(n.g.performance=z().performance);var N=console.log.bind(console),T=console.warn.bind(console);v&&(N=e=>S.writeSync(1,e+"\n"),T=e=>S.writeSync(2,e+"\n"));var _=d.print||N,C=d.printErr||T;Object.assign(d,f),f=null,d.arguments&&(m=d.arguments),d.thisProgram&&d.thisProgram,d.quit&&(g=d.quit);var E;Atomics.load,Atomics.store,Atomics.compareExchange;d.wasmBinary&&(E=d.wasmBinary);var A=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&se("no native wasm support detected");var $,R,F,D=!1;var M,W,U,V,G,H,j="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function q(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&j)return j.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var i="";t<a;){var s=e[t++];if(128&s){var o=63&e[t++];if(192!=(224&s)){var l=63&e[t++];if((s=224==(240&s)?(15&s)<<12|o<<6|l:(7&s)<<18|o<<12|l<<6|63&e[t++])<65536)i+=String.fromCharCode(s);else{var u=s-65536;i+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else i+=String.fromCharCode((31&s)<<6|o)}else i+=String.fromCharCode(s)}return i}function K(e,t){return(e>>>=0)?q(r(),e,t):""}function X(e){M=e,d.HEAP8=W=new Int8Array(e),d.HEAP16=new Int16Array(e),d.HEAP32=V=new Int32Array(e),d.HEAPU8=U=new Uint8Array(e),d.HEAPU16=new Uint16Array(e),d.HEAPU32=G=new Uint32Array(e),d.HEAPF32=new Float32Array(e),d.HEAPF64=H=new Float64Array(e)}x&&(M=d.buffer);var Y=d.INITIAL_MEMORY||16777216;if(x)$=d.wasmMemory,M=d.buffer;else if(d.wasmMemory)$=d.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:Y/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw C("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&C("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");$&&(M=$.buffer),Y=M.byteLength,X(M);var Q,J=[],Z=[],ee=[];function te(){return A}function ne(){!x&&be(Z)}var re=0,ae=null,ie=null;function se(e){d.onAbort&&d.onAbort(e),C(e="Aborted("+e+")"),D=!0,F=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}var oe;function le(e){return e.startsWith("data:application/octet-stream;base64,")}function ue(e){return e.startsWith("file://")}function de(e){try{if(e==oe&&E)return new Uint8Array(E);if(h)return h(e);throw"both async and sync fetching of the wasm failed"}catch(et){se(et)}}le(oe="tfjs-backend-wasm-threaded-simd.wasm")||(oe=k(oe));var ce={};function pe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function he(e){var t=ye.pthreads[e];(function(e,t){e||se(t)})(t),ye.returnWorkerToPool(t)}function fe(e){var t=ye.getNewWorker();if(!t)return 6;ye.runningWorkers.push(t),ye.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{v&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function me(e){if(x)return Te(1,1,e);F=e,te()||(ye.terminateAllThreads(),d.onExit&&d.onExit(e),D=!0),g(e,new pe(e))}var ge=function(e,t){if(F=e,!t&&x)throw ve(e),"unwind";me(e)};var ye={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?ye.initWorker():ye.initMainThread()},initMainThread:function(){for(var e=8;e--;)ye.allocateUnusedWorker()},initWorker:function(){A=!1},setExitStatus:function(e){F=e},terminateAllThreads:function(){for(var e of Object.values(ye.pthreads))ye.returnWorkerToPool(e);for(var e of ye.unusedWorkers)e.terminate();ye.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete ye.pthreads[t],ye.unusedWorkers.push(e),ye.runningWorkers.splice(ye.runningWorkers.indexOf(e),1),e.pthread_ptr=0,v&&e.unref(),je(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){ye.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread_ptr&&(ye.currentProxiedOperationCallerThread=t.pthread_ptr),r.targetThread&&r.targetThread!=Ue()){var i=ye.pthreads[r.targetThread];return i?i.postMessage(r,r.transferList):C('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(ye.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===a?Ie(r.queue):"spawnThread"===a?fe(r):"cleanupThread"===a?he(r.thread):"killThread"===a?function(e){var t=ye.pthreads[e];delete ye.pthreads[e],t.terminate(),je(e),ye.runningWorkers.splice(ye.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===a?function(e){ye.pthreads[e].postMessage({cmd:"cancel"})}(r.thread):"loaded"===a?(t.loaded=!0,v&&t.unref(),n&&n(t),t.runPthread&&t.runPthread()):"print"===a?_("Thread "+r.threadId+": "+r.text):"printErr"===a?C("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"callHandler"===a?d[r.handler](...r.args):a&&C("worker sent an unknown command "+a),ye.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{throw C("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){})));var r=[];for(var a of["onExit","onAbort","print","printErr"])d.hasOwnProperty(a)&&r.push(a);t.postMessage({cmd:"load",handlers:r,urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:$,wasmModule:R})},allocateUnusedWorker:function(){var e,t=k("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),ye.unusedWorkers.push(e)},getNewWorker:function(){return 0==ye.unusedWorkers.length&&(ye.allocateUnusedWorker(),ye.loadWasmModuleToWorker(ye.unusedWorkers[0])),ye.unusedWorkers.pop()}};function be(e){for(;e.length>0;)e.shift()(d)}function ve(e){if(x)return Te(2,0,e);try{ge(e)}catch(et){!function(e){if(e instanceof pe||"unwind"==e)return F;g(1,e)}(et)}}d.PThread=ye,d.establishStackSpace=function(){var e=Ue(),t=a()[e+52>>>2],n=a()[e+56>>>2];Ke(t,t-n),Ye(t)};var xe=[];function we(e,t,n,r){return x?Te(3,1,e,t,n,r):ke(e,t,n,r)}function ke(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return C("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(x&&0===a.length)return we(e,t,n,r);var i={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return x?(i.cmd="spawnThread",postMessage(i,a),0):fe(i)}d.invokeEntryPoint=function(e,t){var n=function(e){var t=xe[e];return t||(e>=xe.length&&(xe.length=e+1),xe[e]=t=Q.get(e)),t}(e)(t);te()?ye.setExitStatus(n):qe(n)};var Se;function Ie(e){Atomics.store(a(),e>>2,1),Ue()&&He(e),Atomics.compareExchange(a(),e>>2,1,0)}function Ne(e){Ne.shown||(Ne.shown={}),Ne.shown[e]||(Ne.shown[e]=1,v&&(e="warning: "+e),C(e))}function Te(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=Xe(),n=e();return Ye(t),n}((()=>{for(var a=n,i=Qe(8*a),o=i>>3,l=0;l<n;l++){var u=r[2+l];s()[o+l>>>0]=u}return Ge(e,a,i,t)}))}d.executeNotifiedProxyingQueue=Ie,Se=v?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var _e=[];function Ce(e){try{return $.grow(e-M.byteLength+65535>>>16),X($.buffer),1}catch(et){}}function Ee(e){return x?Te(4,1,e):52}function Ae(e,t,n,r,a){return x?Te(5,1,e,t,n,r,a):70}var $e=[null,[],[]];function Re(e,t){var n=$e[e];0===t||10===t?((1===e?_:C)(q(n,0)),n.length=0):n.push(t)}function Fe(e,t,n,a){if(x)return Te(6,1,e,t,n,a);for(var s=0,o=0;o<n;o++){var l=i()[t>>>2],u=i()[t+4>>>2];t+=8;for(var d=0;d<u;d++)Re(e,r()[l+d>>>0]);s+=u}return i()[a>>>2]=s,0}function De(e){return d["_"+e]}function Me(e,t){($.buffer!=M&&X($.buffer),W).set(e,t>>>0)}function Oe(e,t,n,a,i){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,i=n+r-1,s=0;s<e.length;++s){var o=e.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++s)),o<=127){if(n>=i)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=i)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=i)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=i)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,r(),t,n)})(e,t=Qe(n),n)}return t},array:e=>{var t=Qe(e.length);return Me(e,t),t}};var o=De(e),l=[],u=0;if(a)for(var d=0;d<a.length;d++){var c=s[n[d]];c?(0===u&&(u=Xe()),l[d]=c(a[d])):l[d]=a[d]}var p,h=o.apply(null,l);return p=h,0!==u&&Ye(u),h=function(e){return"string"===t?K(e):"boolean"===t?!!e:e}(p),h}ye.init();var Pe,Le,ze,Be=[null,me,ve,we,Ee,Ae,Fe],We={__emscripten_init_main_thread_js:function(e){Ve(e,!b,1,!y),ye.threadInitTLS()},__emscripten_thread_cleanup:function(e){x?postMessage({cmd:"cleanupThread",thread:e}):he(e)},__pthread_create_js:ke,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return true},_emscripten_notify_task_queue:function(e,t,n,r){if(e==t)setTimeout((()=>Ie(r)));else if(x)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=ye.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){se("")},emscripten_check_blocking_allowed:function(){v||b||Ne("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:Se,emscripten_memcpy_big:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_num_logical_cores:function(){return v?B().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){_e.length=t;for(var r=n>>3,a=0;a<t;a++)_e[a]=s()[r+a>>>0];return(e<0?ce[-e-1]:Be[e]).apply(null,_e)},emscripten_resize_heap:function(e){var t=r().length;if((e>>>=0)<=t)return!1;var n,a,i=4294901760;if(e>i)return!1;for(var s=1;s<=4;s*=2){var o=t*(1+.2/s);if(o=Math.min(o,e+100663296),Ce(Math.min(i,(n=Math.max(e,o))+((a=65536)-n%a)%a)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:ge,fd_close:Ee,fd_seek:Ae,fd_write:Fe,memory:$||d.wasmMemory},Ue=(function(){var e={env:We,wasi_snapshot_preview1:We};function t(e,t){var n=e.exports;if(d.asm=n,function(e){ye.tlsInitFunctions.push(e)}(d.asm._emscripten_tls_init),Q=d.asm.__indirect_function_table,function(e){Z.unshift(e)}(d.asm.__wasm_call_ctors),R=t,!x){var r=ye.unusedWorkers.length;ye.unusedWorkers.forEach((function(e){ye.loadWasmModuleToWorker(e,(function(){--r||function(){if(re--,d.monitorRunDependencies&&d.monitorRunDependencies(re),0==re&&(null!==ae&&(clearInterval(ae),ae=null),ie)){var e=ie;ie=null,e()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!E&&(y||b)){if("function"==typeof fetch&&!ue(oe))return fetch(oe,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+oe+"'";return e.arrayBuffer()})).catch((function(){return de(oe)}));if(p)return new Promise((function(e,t){p(oe,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return de(oe)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){C("failed to asynchronously prepare wasm: "+e),se(e)}))}if(x||(re++,d.monitorRunDependencies&&d.monitorRunDependencies(re)),d.instantiateWasm)try{return d.instantiateWasm(e,t)}catch(a){C("Module.instantiateWasm callback failed with error: "+a),l(a)}(E||"function"!=typeof WebAssembly.instantiateStreaming||le(oe)||ue(oe)||v||"function"!=typeof fetch?r(n):fetch(oe,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return C("wasm streaming compile failed: "+e),C("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(l)}(),d.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},d._init=function(){return(d._init=d.asm.init).apply(null,arguments)},d._init_with_threads_count=function(){return(d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},d._get_threads_count=function(){return(d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},d._register_tensor=function(){return(d._register_tensor=d.asm.register_tensor).apply(null,arguments)},d._dispose_data=function(){return(d._dispose_data=d.asm.dispose_data).apply(null,arguments)},d._dispose=function(){return(d._dispose=d.asm.dispose).apply(null,arguments)},d._Abs=function(){return(d._Abs=d.asm.Abs).apply(null,arguments)},d._Acos=function(){return(d._Acos=d.asm.Acos).apply(null,arguments)},d._Acosh=function(){return(d._Acosh=d.asm.Acosh).apply(null,arguments)},d._Add=function(){return(d._Add=d.asm.Add).apply(null,arguments)},d._AddN=function(){return(d._AddN=d.asm.AddN).apply(null,arguments)},d._All=function(){return(d._All=d.asm.All).apply(null,arguments)},d._Any=function(){return(d._Any=d.asm.Any).apply(null,arguments)},d._ArgMax=function(){return(d._ArgMax=d.asm.ArgMax).apply(null,arguments)},d._ArgMin=function(){return(d._ArgMin=d.asm.ArgMin).apply(null,arguments)},d._Asin=function(){return(d._Asin=d.asm.Asin).apply(null,arguments)},d._Asinh=function(){return(d._Asinh=d.asm.Asinh).apply(null,arguments)},d._Atan=function(){return(d._Atan=d.asm.Atan).apply(null,arguments)},d._Atan2=function(){return(d._Atan2=d.asm.Atan2).apply(null,arguments)},d._Atanh=function(){return(d._Atanh=d.asm.Atanh).apply(null,arguments)},d._AvgPool=function(){return(d._AvgPool=d.asm.AvgPool).apply(null,arguments)},d._AvgPool3D=function(){return(d._AvgPool3D=d.asm.AvgPool3D).apply(null,arguments)},d._AvgPool3DGrad=function(){return(d._AvgPool3DGrad=d.asm.AvgPool3DGrad).apply(null,arguments)},d._AvgPoolGrad=function(){return(d._AvgPoolGrad=d.asm.AvgPoolGrad).apply(null,arguments)},d._BatchMatMul=function(){return(d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},d._Bincount=function(){return(d._Bincount=d.asm.Bincount).apply(null,arguments)},d._BitwiseAnd=function(){return(d._BitwiseAnd=d.asm.BitwiseAnd).apply(null,arguments)},d._Ceil=function(){return(d._Ceil=d.asm.Ceil).apply(null,arguments)},d._ClipByValue=function(){return(d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},d._Conv2D=function(){return(d._Conv2D=d.asm.Conv2D).apply(null,arguments)},d._Conv2DBackpropInput=function(){return(d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},d._Conv3D=function(){return(d._Conv3D=d.asm.Conv3D).apply(null,arguments)},d._Conv3DBackpropFilterV2=function(){return(d._Conv3DBackpropFilterV2=d.asm.Conv3DBackpropFilterV2).apply(null,arguments)},d._Conv3DBackpropInputV2=function(){return(d._Conv3DBackpropInputV2=d.asm.Conv3DBackpropInputV2).apply(null,arguments)},d._Cos=function(){return(d._Cos=d.asm.Cos).apply(null,arguments)},d._Cosh=function(){return(d._Cosh=d.asm.Cosh).apply(null,arguments)},d._CropAndResize=function(){return(d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},d._Cumprod=function(){return(d._Cumprod=d.asm.Cumprod).apply(null,arguments)},d._Cumsum=function(){return(d._Cumsum=d.asm.Cumsum).apply(null,arguments)},d._DenseBincount=function(){return(d._DenseBincount=d.asm.DenseBincount).apply(null,arguments)},d._DepthToSpace=function(){return(d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},d._DepthwiseConv2dNative=function(){return(d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},d._Diag=function(){return(d._Diag=d.asm.Diag).apply(null,arguments)},d._Dilation2D=function(){return(d._Dilation2D=d.asm.Dilation2D).apply(null,arguments)},d._Dilation2DBackpropFilter=function(){return(d._Dilation2DBackpropFilter=d.asm.Dilation2DBackpropFilter).apply(null,arguments)},d._Dilation2DBackpropInput=function(){return(d._Dilation2DBackpropInput=d.asm.Dilation2DBackpropInput).apply(null,arguments)},d._Elu=function(){return(d._Elu=d.asm.Elu).apply(null,arguments)},d._EluGrad=function(){return(d._EluGrad=d.asm.EluGrad).apply(null,arguments)},d._Equal=function(){return(d._Equal=d.asm.Equal).apply(null,arguments)},d._Erf=function(){return(d._Erf=d.asm.Erf).apply(null,arguments)},d._Exp=function(){return(d._Exp=d.asm.Exp).apply(null,arguments)},d._Expm1=function(){return(d._Expm1=d.asm.Expm1).apply(null,arguments)},d._FlipLeftRight=function(){return(d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},d._Floor=function(){return(d._Floor=d.asm.Floor).apply(null,arguments)},d._FloorDiv=function(){return(d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},d._FusedBatchNorm=function(){return(d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},d._FusedConv2D=function(){return(d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},d._FusedDepthwiseConv2D=function(){return(d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},d._Gather=function(){return(d._Gather=d.asm.Gather).apply(null,arguments)},d._GatherNd=function(){return(d._GatherNd=d.asm.GatherNd).apply(null,arguments)},d._Greater=function(){return(d._Greater=d.asm.Greater).apply(null,arguments)},d._GreaterEqual=function(){return(d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},d._IsFinite=function(){return(d._IsFinite=d.asm.IsFinite).apply(null,arguments)},d._IsInf=function(){return(d._IsInf=d.asm.IsInf).apply(null,arguments)},d._IsNan=function(){return(d._IsNan=d.asm.IsNan).apply(null,arguments)},d._LRN=function(){return(d._LRN=d.asm.LRN).apply(null,arguments)},d._LRNGrad=function(){return(d._LRNGrad=d.asm.LRNGrad).apply(null,arguments)},d._LeakyRelu=function(){return(d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},d._Less=function(){return(d._Less=d.asm.Less).apply(null,arguments)},d._LessEqual=function(){return(d._LessEqual=d.asm.LessEqual).apply(null,arguments)},d._LinSpace=function(){return(d._LinSpace=d.asm.LinSpace).apply(null,arguments)},d._Log=function(){return(d._Log=d.asm.Log).apply(null,arguments)},d._Log1p=function(){return(d._Log1p=d.asm.Log1p).apply(null,arguments)},d._LogicalAnd=function(){return(d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},d._LogicalNot=function(){return(d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},d._LogicalOr=function(){return(d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},d._LogicalXor=function(){return(d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},d._Max=function(){return(d._Max=d.asm.Max).apply(null,arguments)},d._MaxPool=function(){return(d._MaxPool=d.asm.MaxPool).apply(null,arguments)},d._MaxPool3D=function(){return(d._MaxPool3D=d.asm.MaxPool3D).apply(null,arguments)},d._MaxPool3DGrad=function(){return(d._MaxPool3DGrad=d.asm.MaxPool3DGrad).apply(null,arguments)},d._MaxPoolGrad=function(){return(d._MaxPoolGrad=d.asm.MaxPoolGrad).apply(null,arguments)},d._MaxPoolWithArgmax=function(){return(d._MaxPoolWithArgmax=d.asm.MaxPoolWithArgmax).apply(null,arguments)},d._Maximum=function(){return(d._Maximum=d.asm.Maximum).apply(null,arguments)},d._Mean=function(){return(d._Mean=d.asm.Mean).apply(null,arguments)},d._Min=function(){return(d._Min=d.asm.Min).apply(null,arguments)},d._Minimum=function(){return(d._Minimum=d.asm.Minimum).apply(null,arguments)},d._MirrorPad=function(){return(d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},d._Mod=function(){return(d._Mod=d.asm.Mod).apply(null,arguments)},d._Multinomial=function(){return(d._Multinomial=d.asm.Multinomial).apply(null,arguments)},d._Multiply=function(){return(d._Multiply=d.asm.Multiply).apply(null,arguments)},d._Neg=function(){return(d._Neg=d.asm.Neg).apply(null,arguments)},d._NonMaxSuppressionV3=function(){return(d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},d._NonMaxSuppressionV4=function(){return(d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},d._NonMaxSuppressionV5=function(){return(d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},d._NotEqual=function(){return(d._NotEqual=d.asm.NotEqual).apply(null,arguments)},d._OneHot=function(){return(d._OneHot=d.asm.OneHot).apply(null,arguments)},d._PadV2=function(){return(d._PadV2=d.asm.PadV2).apply(null,arguments)},d._Pow=function(){return(d._Pow=d.asm.Pow).apply(null,arguments)},d._Prelu=function(){return(d._Prelu=d.asm.Prelu).apply(null,arguments)},d._Prod=function(){return(d._Prod=d.asm.Prod).apply(null,arguments)},d._RealDiv=function(){return(d._RealDiv=d.asm.RealDiv).apply(null,arguments)},d._Reciprocal=function(){return(d._Reciprocal=d.asm.Reciprocal).apply(null,arguments)},d._Relu=function(){return(d._Relu=d.asm.Relu).apply(null,arguments)},d._Relu6=function(){return(d._Relu6=d.asm.Relu6).apply(null,arguments)},d._ResizeBilinear=function(){return(d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},d._ResizeBilinearGrad=function(){return(d._ResizeBilinearGrad=d.asm.ResizeBilinearGrad).apply(null,arguments)},d._ResizeNearestNeighbor=function(){return(d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},d._ResizeNearestNeighborGrad=function(){return(d._ResizeNearestNeighborGrad=d.asm.ResizeNearestNeighborGrad).apply(null,arguments)},d._Reverse=function(){return(d._Reverse=d.asm.Reverse).apply(null,arguments)},d._RotateWithOffset=function(){return(d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},d._Round=function(){return(d._Round=d.asm.Round).apply(null,arguments)},d._Rsqrt=function(){return(d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},d._ScatterNd=function(){return(d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},d._SearchSorted=function(){return(d._SearchSorted=d.asm.SearchSorted).apply(null,arguments)},d._SelectV2=function(){return(d._SelectV2=d.asm.SelectV2).apply(null,arguments)},d._Selu=function(){return(d._Selu=d.asm.Selu).apply(null,arguments)},d._Sigmoid=function(){return(d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},d._Sign=function(){return(d._Sign=d.asm.Sign).apply(null,arguments)},d._Sin=function(){return(d._Sin=d.asm.Sin).apply(null,arguments)},d._Sinh=function(){return(d._Sinh=d.asm.Sinh).apply(null,arguments)},d._Softmax=function(){return(d._Softmax=d.asm.Softmax).apply(null,arguments)},d._Softplus=function(){return(d._Softplus=d.asm.Softplus).apply(null,arguments)},d._SparseFillEmptyRows=function(){return(d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},d._SparseReshape=function(){return(d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},d._SparseSegmentReduction=function(){return(d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},d._SparseToDense=function(){return(d._SparseToDense=d.asm.SparseToDense).apply(null,arguments)},d._Sqrt=function(){return(d._Sqrt=d.asm.Sqrt).apply(null,arguments)},d._Square=function(){return(d._Square=d.asm.Square).apply(null,arguments)},d._SquaredDifference=function(){return(d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},d._Step=function(){return(d._Step=d.asm.Step).apply(null,arguments)},d._StridedSlice=function(){return(d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},d._Sub=function(){return(d._Sub=d.asm.Sub).apply(null,arguments)},d._Sum=function(){return(d._Sum=d.asm.Sum).apply(null,arguments)},d._Tan=function(){return(d._Tan=d.asm.Tan).apply(null,arguments)},d._Tanh=function(){return(d._Tanh=d.asm.Tanh).apply(null,arguments)},d._TensorScatterUpdate=function(){return(d._TensorScatterUpdate=d.asm.TensorScatterUpdate).apply(null,arguments)},d._Tile=function(){return(d._Tile=d.asm.Tile).apply(null,arguments)},d._TopK=function(){return(d._TopK=d.asm.TopK).apply(null,arguments)},d._Transform=function(){return(d._Transform=d.asm.Transform).apply(null,arguments)},d._Transpose=function(){return(d._Transpose=d.asm.Transpose).apply(null,arguments)},d.__FusedMatMul=function(){return(d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},d._malloc=function(){return(d._malloc=d.asm.malloc).apply(null,arguments)},d._free=function(){return(d._free=d.asm.free).apply(null,arguments)},d.__emscripten_tls_init=function(){return(d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)},d._pthread_self=function(){return(Ue=d._pthread_self=d.asm.pthread_self).apply(null,arguments)}),Ve=(d.___errno_location=function(){return(d.___errno_location=d.asm.__errno_location).apply(null,arguments)},d.__emscripten_thread_init=function(){return(Ve=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)}),Ge=(d.__emscripten_thread_crashed=function(){return(d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},d._emscripten_main_thread_process_queued_calls=function(){return(d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},d._emscripten_main_browser_thread_id=function(){return(d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},d._emscripten_run_in_main_runtime_thread_js=function(){return(Ge=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),He=(d._emscripten_dispatch_to_thread_=function(){return(d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},d.__emscripten_proxy_execute_task_queue=function(){return(He=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),je=d.__emscripten_thread_free_data=function(){return(je=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},qe=d.__emscripten_thread_exit=function(){return(qe=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},Ke=d._emscripten_stack_set_limits=function(){return(Ke=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},Xe=d.stackSave=function(){return(Xe=d.stackSave=d.asm.stackSave).apply(null,arguments)},Ye=d.stackRestore=function(){return(Ye=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},Qe=d.stackAlloc=function(){return(Qe=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)};d.dynCall_iijjiiii=function(){return(d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},d.dynCall_jiji=function(){return(d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)};function Je(e){if(e=e||m,!(re>0)){if(x)return o(d),ne(),void startWorker(d);(function(){if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)e=d.preRun.shift(),J.unshift(e);var e;be(J)})(),re>0||(d.setStatus?(d.setStatus("Running..."),setTimeout((function(){setTimeout((function(){d.setStatus("")}),1),t()}),1)):t())}function t(){Pe||(Pe=!0,d.calledRun=!0,!D&&(ne(),o(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),function(){if(!x){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;)e=d.postRun.shift(),ee.unshift(e);be(ee)}var e}()))}}if(d.keepRuntimeAlive=te,d.wasmMemory=$,d.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?De(e):function(){return Oe(e,t,n,arguments)}},d.ExitStatus=pe,d.PThread=ye,ie=function e(){Pe||Je(),Pe||(ie=e)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();if(Je(),u&&(Le={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!u.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!u.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)ze=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");ze=t}if(Le){var Ze=ze._dispose;ze._dispose=function(){Ze(),Le.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Le.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=r)})),U=x(((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'})),V=x(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||d,function(t){var n,r,a,i="undefined"!=typeof(t=t||{})?t:{};i.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(a={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var s,o,l,u=Object.assign({},i),d=[],c="object"==typeof window,p="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,f="";if(h){var m=O(),g=P();f=p?g.dirname(f)+"/":"//",s=(e,t)=>(e=V(e)?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=s(e,!0);return t.buffer||(t=new Uint8Array(t)),t},o=(e,t,n)=>{e=V(e)?new URL(e):g.normalize(e),m.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),d=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof H))throw e})),process.on("unhandledRejection",(function(e){throw e})),i.inspect=function(){return"[Emscripten Module object]"}}else(c||p)&&(p?f=self.location.href:"undefined"!=typeof document&&document.currentScript&&(f=document.currentScript.src),e&&(f=e),f=0!==f.indexOf("blob:")?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},p&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)},e=>document.title=e);var y=i.print||console.log.bind(console),b=i.printErr||console.warn.bind(console);Object.assign(i,u),u=null,i.arguments&&(d=i.arguments),i.thisProgram&&i.thisProgram,i.quit&&i.quit;var v;i.wasmBinary&&(v=i.wasmBinary);var x=i.noExitRuntime||!0;"object"!=typeof WebAssembly&&z("no native wasm support detected");var w,k=!1;var S,I,N,T,_="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&_)return _.decode(e.subarray(t,a));for(var i="";t<a;){var s=e[t++];if(128&s){var o=63&e[t++];if(192!=(224&s)){var l=63&e[t++];if((s=224==(240&s)?(15&s)<<12|o<<6|l:(7&s)<<18|o<<12|l<<6|63&e[t++])<65536)i+=String.fromCharCode(s);else{var u=s-65536;i+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else i+=String.fromCharCode((31&s)<<6|o)}else i+=String.fromCharCode(s)}return i}function E(e,t){return(e>>>=0)?C(N,e,t):""}function A(e){S=e,i.HEAP8=I=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAP32=new Int32Array(e),i.HEAPU8=N=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAPU32=T=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=new Float64Array(e)}i.INITIAL_MEMORY;var $=[],R=[],F=[];var D=0,M=null,L=null;function z(e){i.onAbort&&i.onAbort(e),b(e="Aborted("+e+")"),k=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}var B,W;function U(e){return e.startsWith("data:application/octet-stream;base64,")}function V(e){return e.startsWith("file://")}function G(e){try{if(e==B&&v)return new Uint8Array(v);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(t){z(t)}}function H(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function j(e){for(;e.length>0;)e.shift()(i)}function q(e){try{return w.grow(e-S.byteLength+65535>>>16),A(w.buffer),1}catch(t){}}U(B="tfjs-backend-wasm.wasm")||(W=B,B=i.locateFile?i.locateFile(W,f):f+W);var K=[null,[],[]];function X(e,t){var n=K[e];0===t||10===t?((1===e?y:b)(C(n,0)),n.length=0):n.push(t)}function Y(e){return i["_"+e]}function Q(e,t,n,r,a){var i={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,i=n+r-1,s=0;s<e.length;++s){var o=e.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++s)),o<=127){if(n>=i)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=i)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=i)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=i)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,N,t,n)})(e,t=ae(n),n)}return t},array:e=>{var t=ae(e.length);return function(e,t){I.set(e,t>>>0)}(e,t),t}};var s=Y(e),o=[],l=0;if(r)for(var u=0;u<r.length;u++){var d=i[n[u]];d?(0===l&&(l=ne()),o[u]=d(r[u])):o[u]=r[u]}var c,p=s.apply(null,o);return c=p,0!==l&&re(l),p=function(e){return"string"===t?E(e):"boolean"===t?!!e:e}(c),p}var J,Z,ee,te={abort:function(){z("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){N.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n,r=N.length,a=4294901760;if((e>>>=0)>a)return!1;for(var i=1;i<=4;i*=2){var s=r*(1+.2/i);if(s=Math.min(s,e+100663296),q(Math.min(a,(t=Math.max(e,s))+((n=65536)-t%n)%n)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,r,a){return 70},fd_write:function(e,t,n,r){for(var a=0,i=0;i<n;i++){var s=T[t>>>2],o=T[t+4>>>2];t+=8;for(var l=0;l<o;l++)X(e,N[s+l>>>0]);a+=o}return T[r>>>2]=a,0}},ne=(function(){var e={env:te,wasi_snapshot_preview1:te};function t(e,t){var n=e.exports;i.asm=n,A((w=i.asm.memory).buffer),i.asm.__indirect_function_table,function(e){R.unshift(e)}(i.asm.__wasm_call_ctors),function(){if(D--,i.monitorRunDependencies&&i.monitorRunDependencies(D),0==D&&(null!==M&&(clearInterval(M),M=null),L)){var e=L;L=null,e()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!v&&(c||p)){if("function"==typeof fetch&&!V(B))return fetch(B,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+B+"'";return e.arrayBuffer()})).catch((function(){return G(B)}));if(o)return new Promise((function(e,t){o(B,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return G(B)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){b("failed to asynchronously prepare wasm: "+e),z(e)}))}if(D++,i.monitorRunDependencies&&i.monitorRunDependencies(D),i.instantiateWasm)try{return i.instantiateWasm(e,t)}catch(s){b("Module.instantiateWasm callback failed with error: "+s),r(s)}(v||"function"!=typeof WebAssembly.instantiateStreaming||U(B)||V(B)||h||"function"!=typeof fetch?a(n):fetch(B,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return b("wasm streaming compile failed: "+e),b("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(r)}(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.__wasm_call_ctors).apply(null,arguments)},i._init=function(){return(i._init=i.asm.init).apply(null,arguments)},i._init_with_threads_count=function(){return(i._init_with_threads_count=i.asm.init_with_threads_count).apply(null,arguments)},i._get_threads_count=function(){return(i._get_threads_count=i.asm.get_threads_count).apply(null,arguments)},i._register_tensor=function(){return(i._register_tensor=i.asm.register_tensor).apply(null,arguments)},i._dispose_data=function(){return(i._dispose_data=i.asm.dispose_data).apply(null,arguments)},i._dispose=function(){return(i._dispose=i.asm.dispose).apply(null,arguments)},i._Abs=function(){return(i._Abs=i.asm.Abs).apply(null,arguments)},i._Acos=function(){return(i._Acos=i.asm.Acos).apply(null,arguments)},i._Acosh=function(){return(i._Acosh=i.asm.Acosh).apply(null,arguments)},i._Add=function(){return(i._Add=i.asm.Add).apply(null,arguments)},i._AddN=function(){return(i._AddN=i.asm.AddN).apply(null,arguments)},i._All=function(){return(i._All=i.asm.All).apply(null,arguments)},i._Any=function(){return(i._Any=i.asm.Any).apply(null,arguments)},i._ArgMax=function(){return(i._ArgMax=i.asm.ArgMax).apply(null,arguments)},i._ArgMin=function(){return(i._ArgMin=i.asm.ArgMin).apply(null,arguments)},i._Asin=function(){return(i._Asin=i.asm.Asin).apply(null,arguments)},i._Asinh=function(){return(i._Asinh=i.asm.Asinh).apply(null,arguments)},i._Atan=function(){return(i._Atan=i.asm.Atan).apply(null,arguments)},i._Atan2=function(){return(i._Atan2=i.asm.Atan2).apply(null,arguments)},i._Atanh=function(){return(i._Atanh=i.asm.Atanh).apply(null,arguments)},i._AvgPool=function(){return(i._AvgPool=i.asm.AvgPool).apply(null,arguments)},i._AvgPool3D=function(){return(i._AvgPool3D=i.asm.AvgPool3D).apply(null,arguments)},i._AvgPool3DGrad=function(){return(i._AvgPool3DGrad=i.asm.AvgPool3DGrad).apply(null,arguments)},i._AvgPoolGrad=function(){return(i._AvgPoolGrad=i.asm.AvgPoolGrad).apply(null,arguments)},i._BatchMatMul=function(){return(i._BatchMatMul=i.asm.BatchMatMul).apply(null,arguments)},i._Bincount=function(){return(i._Bincount=i.asm.Bincount).apply(null,arguments)},i._BitwiseAnd=function(){return(i._BitwiseAnd=i.asm.BitwiseAnd).apply(null,arguments)},i._Ceil=function(){return(i._Ceil=i.asm.Ceil).apply(null,arguments)},i._ClipByValue=function(){return(i._ClipByValue=i.asm.ClipByValue).apply(null,arguments)},i._Conv2D=function(){return(i._Conv2D=i.asm.Conv2D).apply(null,arguments)},i._Conv2DBackpropInput=function(){return(i._Conv2DBackpropInput=i.asm.Conv2DBackpropInput).apply(null,arguments)},i._Conv3D=function(){return(i._Conv3D=i.asm.Conv3D).apply(null,arguments)},i._Conv3DBackpropFilterV2=function(){return(i._Conv3DBackpropFilterV2=i.asm.Conv3DBackpropFilterV2).apply(null,arguments)},i._Conv3DBackpropInputV2=function(){return(i._Conv3DBackpropInputV2=i.asm.Conv3DBackpropInputV2).apply(null,arguments)},i._Cos=function(){return(i._Cos=i.asm.Cos).apply(null,arguments)},i._Cosh=function(){return(i._Cosh=i.asm.Cosh).apply(null,arguments)},i._CropAndResize=function(){return(i._CropAndResize=i.asm.CropAndResize).apply(null,arguments)},i._Cumprod=function(){return(i._Cumprod=i.asm.Cumprod).apply(null,arguments)},i._Cumsum=function(){return(i._Cumsum=i.asm.Cumsum).apply(null,arguments)},i._DenseBincount=function(){return(i._DenseBincount=i.asm.DenseBincount).apply(null,arguments)},i._DepthToSpace=function(){return(i._DepthToSpace=i.asm.DepthToSpace).apply(null,arguments)},i._DepthwiseConv2dNative=function(){return(i._DepthwiseConv2dNative=i.asm.DepthwiseConv2dNative).apply(null,arguments)},i._Diag=function(){return(i._Diag=i.asm.Diag).apply(null,arguments)},i._Dilation2D=function(){return(i._Dilation2D=i.asm.Dilation2D).apply(null,arguments)},i._Dilation2DBackpropFilter=function(){return(i._Dilation2DBackpropFilter=i.asm.Dilation2DBackpropFilter).apply(null,arguments)},i._Dilation2DBackpropInput=function(){return(i._Dilation2DBackpropInput=i.asm.Dilation2DBackpropInput).apply(null,arguments)},i._Elu=function(){return(i._Elu=i.asm.Elu).apply(null,arguments)},i._EluGrad=function(){return(i._EluGrad=i.asm.EluGrad).apply(null,arguments)},i._Equal=function(){return(i._Equal=i.asm.Equal).apply(null,arguments)},i._Erf=function(){return(i._Erf=i.asm.Erf).apply(null,arguments)},i._Exp=function(){return(i._Exp=i.asm.Exp).apply(null,arguments)},i._Expm1=function(){return(i._Expm1=i.asm.Expm1).apply(null,arguments)},i._FlipLeftRight=function(){return(i._FlipLeftRight=i.asm.FlipLeftRight).apply(null,arguments)},i._Floor=function(){return(i._Floor=i.asm.Floor).apply(null,arguments)},i._FloorDiv=function(){return(i._FloorDiv=i.asm.FloorDiv).apply(null,arguments)},i._FusedBatchNorm=function(){return(i._FusedBatchNorm=i.asm.FusedBatchNorm).apply(null,arguments)},i._FusedConv2D=function(){return(i._FusedConv2D=i.asm.FusedConv2D).apply(null,arguments)},i._FusedDepthwiseConv2D=function(){return(i._FusedDepthwiseConv2D=i.asm.FusedDepthwiseConv2D).apply(null,arguments)},i._Gather=function(){return(i._Gather=i.asm.Gather).apply(null,arguments)},i._GatherNd=function(){return(i._GatherNd=i.asm.GatherNd).apply(null,arguments)},i._Greater=function(){return(i._Greater=i.asm.Greater).apply(null,arguments)},i._GreaterEqual=function(){return(i._GreaterEqual=i.asm.GreaterEqual).apply(null,arguments)},i._IsFinite=function(){return(i._IsFinite=i.asm.IsFinite).apply(null,arguments)},i._IsInf=function(){return(i._IsInf=i.asm.IsInf).apply(null,arguments)},i._IsNan=function(){return(i._IsNan=i.asm.IsNan).apply(null,arguments)},i._LRN=function(){return(i._LRN=i.asm.LRN).apply(null,arguments)},i._LRNGrad=function(){return(i._LRNGrad=i.asm.LRNGrad).apply(null,arguments)},i._LeakyRelu=function(){return(i._LeakyRelu=i.asm.LeakyRelu).apply(null,arguments)},i._Less=function(){return(i._Less=i.asm.Less).apply(null,arguments)},i._LessEqual=function(){return(i._LessEqual=i.asm.LessEqual).apply(null,arguments)},i._LinSpace=function(){return(i._LinSpace=i.asm.LinSpace).apply(null,arguments)},i._Log=function(){return(i._Log=i.asm.Log).apply(null,arguments)},i._Log1p=function(){return(i._Log1p=i.asm.Log1p).apply(null,arguments)},i._LogicalAnd=function(){return(i._LogicalAnd=i.asm.LogicalAnd).apply(null,arguments)},i._LogicalNot=function(){return(i._LogicalNot=i.asm.LogicalNot).apply(null,arguments)},i._LogicalOr=function(){return(i._LogicalOr=i.asm.LogicalOr).apply(null,arguments)},i._LogicalXor=function(){return(i._LogicalXor=i.asm.LogicalXor).apply(null,arguments)},i._Max=function(){return(i._Max=i.asm.Max).apply(null,arguments)},i._MaxPool=function(){return(i._MaxPool=i.asm.MaxPool).apply(null,arguments)},i._MaxPool3D=function(){return(i._MaxPool3D=i.asm.MaxPool3D).apply(null,arguments)},i._MaxPool3DGrad=function(){return(i._MaxPool3DGrad=i.asm.MaxPool3DGrad).apply(null,arguments)},i._MaxPoolGrad=function(){return(i._MaxPoolGrad=i.asm.MaxPoolGrad).apply(null,arguments)},i._MaxPoolWithArgmax=function(){return(i._MaxPoolWithArgmax=i.asm.MaxPoolWithArgmax).apply(null,arguments)},i._Maximum=function(){return(i._Maximum=i.asm.Maximum).apply(null,arguments)},i._Mean=function(){return(i._Mean=i.asm.Mean).apply(null,arguments)},i._Min=function(){return(i._Min=i.asm.Min).apply(null,arguments)},i._Minimum=function(){return(i._Minimum=i.asm.Minimum).apply(null,arguments)},i._MirrorPad=function(){return(i._MirrorPad=i.asm.MirrorPad).apply(null,arguments)},i._Mod=function(){return(i._Mod=i.asm.Mod).apply(null,arguments)},i._Multinomial=function(){return(i._Multinomial=i.asm.Multinomial).apply(null,arguments)},i._Multiply=function(){return(i._Multiply=i.asm.Multiply).apply(null,arguments)},i._Neg=function(){return(i._Neg=i.asm.Neg).apply(null,arguments)},i._NonMaxSuppressionV3=function(){return(i._NonMaxSuppressionV3=i.asm.NonMaxSuppressionV3).apply(null,arguments)},i._NonMaxSuppressionV4=function(){return(i._NonMaxSuppressionV4=i.asm.NonMaxSuppressionV4).apply(null,arguments)},i._NonMaxSuppressionV5=function(){return(i._NonMaxSuppressionV5=i.asm.NonMaxSuppressionV5).apply(null,arguments)},i._NotEqual=function(){return(i._NotEqual=i.asm.NotEqual).apply(null,arguments)},i._OneHot=function(){return(i._OneHot=i.asm.OneHot).apply(null,arguments)},i._PadV2=function(){return(i._PadV2=i.asm.PadV2).apply(null,arguments)},i._Pow=function(){return(i._Pow=i.asm.Pow).apply(null,arguments)},i._Prelu=function(){return(i._Prelu=i.asm.Prelu).apply(null,arguments)},i._Prod=function(){return(i._Prod=i.asm.Prod).apply(null,arguments)},i._RealDiv=function(){return(i._RealDiv=i.asm.RealDiv).apply(null,arguments)},i._Reciprocal=function(){return(i._Reciprocal=i.asm.Reciprocal).apply(null,arguments)},i._Relu=function(){return(i._Relu=i.asm.Relu).apply(null,arguments)},i._Relu6=function(){return(i._Relu6=i.asm.Relu6).apply(null,arguments)},i._ResizeBilinear=function(){return(i._ResizeBilinear=i.asm.ResizeBilinear).apply(null,arguments)},i._ResizeBilinearGrad=function(){return(i._ResizeBilinearGrad=i.asm.ResizeBilinearGrad).apply(null,arguments)},i._ResizeNearestNeighbor=function(){return(i._ResizeNearestNeighbor=i.asm.ResizeNearestNeighbor).apply(null,arguments)},i._ResizeNearestNeighborGrad=function(){return(i._ResizeNearestNeighborGrad=i.asm.ResizeNearestNeighborGrad).apply(null,arguments)},i._Reverse=function(){return(i._Reverse=i.asm.Reverse).apply(null,arguments)},i._RotateWithOffset=function(){return(i._RotateWithOffset=i.asm.RotateWithOffset).apply(null,arguments)},i._Round=function(){return(i._Round=i.asm.Round).apply(null,arguments)},i._Rsqrt=function(){return(i._Rsqrt=i.asm.Rsqrt).apply(null,arguments)},i._ScatterNd=function(){return(i._ScatterNd=i.asm.ScatterNd).apply(null,arguments)},i._SearchSorted=function(){return(i._SearchSorted=i.asm.SearchSorted).apply(null,arguments)},i._SelectV2=function(){return(i._SelectV2=i.asm.SelectV2).apply(null,arguments)},i._Selu=function(){return(i._Selu=i.asm.Selu).apply(null,arguments)},i._Sigmoid=function(){return(i._Sigmoid=i.asm.Sigmoid).apply(null,arguments)},i._Sign=function(){return(i._Sign=i.asm.Sign).apply(null,arguments)},i._Sin=function(){return(i._Sin=i.asm.Sin).apply(null,arguments)},i._Sinh=function(){return(i._Sinh=i.asm.Sinh).apply(null,arguments)},i._Softmax=function(){return(i._Softmax=i.asm.Softmax).apply(null,arguments)},i._Softplus=function(){return(i._Softplus=i.asm.Softplus).apply(null,arguments)},i._SparseFillEmptyRows=function(){return(i._SparseFillEmptyRows=i.asm.SparseFillEmptyRows).apply(null,arguments)},i._SparseReshape=function(){return(i._SparseReshape=i.asm.SparseReshape).apply(null,arguments)},i._SparseSegmentReduction=function(){return(i._SparseSegmentReduction=i.asm.SparseSegmentReduction).apply(null,arguments)},i._SparseToDense=function(){return(i._SparseToDense=i.asm.SparseToDense).apply(null,arguments)},i._Sqrt=function(){return(i._Sqrt=i.asm.Sqrt).apply(null,arguments)},i._Square=function(){return(i._Square=i.asm.Square).apply(null,arguments)},i._SquaredDifference=function(){return(i._SquaredDifference=i.asm.SquaredDifference).apply(null,arguments)},i._Step=function(){return(i._Step=i.asm.Step).apply(null,arguments)},i._StridedSlice=function(){return(i._StridedSlice=i.asm.StridedSlice).apply(null,arguments)},i._Sub=function(){return(i._Sub=i.asm.Sub).apply(null,arguments)},i._Sum=function(){return(i._Sum=i.asm.Sum).apply(null,arguments)},i._Tan=function(){return(i._Tan=i.asm.Tan).apply(null,arguments)},i._Tanh=function(){return(i._Tanh=i.asm.Tanh).apply(null,arguments)},i._TensorScatterUpdate=function(){return(i._TensorScatterUpdate=i.asm.TensorScatterUpdate).apply(null,arguments)},i._Tile=function(){return(i._Tile=i.asm.Tile).apply(null,arguments)},i._TopK=function(){return(i._TopK=i.asm.TopK).apply(null,arguments)},i._Transform=function(){return(i._Transform=i.asm.Transform).apply(null,arguments)},i._Transpose=function(){return(i._Transpose=i.asm.Transpose).apply(null,arguments)},i.__FusedMatMul=function(){return(i.__FusedMatMul=i.asm._FusedMatMul).apply(null,arguments)},i._malloc=function(){return(i._malloc=i.asm.malloc).apply(null,arguments)},i._free=function(){return(i._free=i.asm.free).apply(null,arguments)},i.___errno_location=function(){return(i.___errno_location=i.asm.__errno_location).apply(null,arguments)},i.stackSave=function(){return(ne=i.stackSave=i.asm.stackSave).apply(null,arguments)}),re=i.stackRestore=function(){return(re=i.stackRestore=i.asm.stackRestore).apply(null,arguments)},ae=i.stackAlloc=function(){return(ae=i.stackAlloc=i.asm.stackAlloc).apply(null,arguments)};i.dynCall_iijjiiii=function(){return(i.dynCall_iijjiiii=i.asm.dynCall_iijjiiii).apply(null,arguments)},i.dynCall_jiji=function(){return(i.dynCall_jiji=i.asm.dynCall_jiji).apply(null,arguments)};function ie(e){function t(){J||(J=!0,i.calledRun=!0,!k&&(j(R),n(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),function(){if(i.postRun)for("function"==typeof i.postRun&&(i.postRun=[i.postRun]);i.postRun.length;)e=i.postRun.shift(),F.unshift(e);var e;j(F)}()))}e=e||d,D>0||(function(){if(i.preRun)for("function"==typeof i.preRun&&(i.preRun=[i.preRun]);i.preRun.length;)e=i.preRun.shift(),$.unshift(e);var e;j($)}(),D>0)||(i.setStatus?(i.setStatus("Running..."),setTimeout((function(){setTimeout((function(){i.setStatus("")}),1),t()}),1)):t())}if(i.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Y(e):function(){return Q(e,t,n,arguments)}},L=function e(){J||ie(),J||(L=e)},i.preInit)for("function"==typeof i.preInit&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();if(ie(),a&&(Z={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!a.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!a.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof t)ee=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");ee=WasmBackendModuleThreadedSimd}if(Z){var se=ee._dispose;ee._dispose=function(){se(),Z.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Z.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModule=r)})),G=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},H=class{refCount(e){return j("refCount")}incRef(e){return j("incRef")}timerAvailable(){return!0}time(e){return j("time")}read(e){return j("read")}readSync(e){return j("readSync")}readToGPU(e,t){return j("readToGPU")}numDataIds(){return j("numDataIds")}disposeData(e,t){return j("disposeData")}write(e,t,n){return j("write")}move(e,t,n,r,a){return j("move")}createTensorFromGPUData(e,t,n){return j("createTensorFromGPUData")}memory(){return j("memory")}floatPrecision(){return j("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return j("dispose")}};function j(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function q(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Q(e,t,n)}function K(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Q(e,n,r),Q(t,n,r)}function X(e,t,n){return Math.max(e,Math.min(t,n))}function Y(e){return e%2===0?e:e+1}function Q(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function J(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Z(e,t){let n=Math.random();return t*n+(1-n)*e}function ee(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function te(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function ne(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";te(oe(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function re(e){te(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function ae(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function ie(e){return 0===e.length}function se(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function oe(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function le(e){return e%1===0}function ue(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function de(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function ce(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return q(t),t}function pe(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function he(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,i)=>{let s=0,o=()=>{if(e())return void a();s++;let l=t(s);null!=n&&s>=n?i():null!=r?r(o,l):setTimeout(o,l)};o()}))}function fe(e,t){let n=1,r=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(-1===e[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function me(e,t){let n=t.length;return te((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),te(e.every((e=>le(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function ge(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||a?null:me(t,e).sort(),s=0;for(let o=0;o<e.length;++o){if(null!=i){if(i[s]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==i[s]||i[s]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),i[s]<=o&&s++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function ye(e,t){return be(e,t)}function be(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function ve(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function xe(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function we(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function ke(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Se(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Ie(e){return"string"==typeof e||e instanceof String}function Ne(e){return"boolean"==typeof e}function Te(e){return"number"==typeof e}function _e(e){return Array.isArray(e)?_e(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Te(e)?"float32":Ie(e)?"string":Ne(e)?"bool":"float32"}function Ce(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Ee(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Ae(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function $e(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=new Array;if(1===t.length){let i=t[0]*(r?2:1);for(let t=0;t<i;t++)a[t]=n[e+t]}else{let i=t[0],s=t.slice(1),o=s.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<i;t++)a[t]=$e(e+t*o,s,n,r)}return a}function Re(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return $e(0,e,t,n)}function Fe(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function De(e,t){let n=Me(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Me(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Oe(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Re(e,new Float32Array(n));if("int32"===t)return Re(e,new Int32Array(n));if("bool"===t)return Re(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Pe(e){e.forEach((t=>{te(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Le(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function ze(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function Be(e){return e&&e.then&&"function"==typeof e.then}var We="tfjsflags",Ue=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ve,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Ge().getBool("IS_TEST")||Ge().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];Ge().getBool("IS_TEST")||Ge().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Be(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);We in e&&e[We].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}};function Ve(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function Ge(){return je}var He,je=null;function qe(){if(null==He){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}He=e}return He}function Ke(e,t){let n=function(){let e=qe();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Xe="Abs",Ye="Acos",Qe="Acosh",Je="Add",Ze="AddN",et="All",tt="Any",nt="ArgMax",rt="ArgMin",at="Asin",it="Asinh",st="Atan",ot="Atanh",lt="Atan2",ut="AvgPool",dt="AvgPoolGrad",ct="AvgPool3D",pt="AvgPool3DGrad",ht="BatchMatMul",ft="BatchToSpaceND",mt="Bincount",gt="BitwiseAnd",yt="BroadcastTo",bt="BroadcastArgs",vt="Cast",xt="Ceil",wt="ClipByValue",kt="Complex",St="ComplexAbs",It="Concat",Nt="Conv2D",Tt="Conv2DBackpropFilter",_t="Conv2DBackpropInput",Ct="Conv3D",Et="Conv3DBackpropFilterV2",At="Conv3DBackpropInputV2",$t="Cos",Rt="Cosh",Ft="Cumprod",Dt="Cumsum",Mt="CropAndResize",Ot="DenseBincount",Pt="DepthToSpace",Lt="DepthwiseConv2dNative",zt="DepthwiseConv2dNativeBackpropFilter",Bt="DepthwiseConv2dNativeBackpropInput",Wt="Diag",Ut="Dilation2D",Vt="Dilation2DBackpropInput",Gt="Dilation2DBackpropFilter",Ht="Draw",jt="RealDiv",qt="Einsum",Kt="Elu",Xt="EluGrad",Yt="Erf",Qt="Equal",Jt="Exp",Zt="ExpandDims",en="Expm1",tn="FFT",nn="Fill",rn="FlipLeftRight",an="Floor",sn="FloorDiv",on="FusedBatchNorm",ln="GatherV2",un="GatherNd",dn="Greater",cn="GreaterEqual",pn="Identity",hn="IFFT",fn="Imag",mn="IsFinite",gn="IsInf",yn="IsNan",bn="LeakyRelu",vn="Less",xn="LessEqual",wn="LinSpace",kn="Log",Sn="Log1p",In="LogicalAnd",Nn="LogicalNot",Tn="LogicalOr",_n="LogicalXor",Cn="LogSoftmax",En="LowerBound",An="LRN",$n="LRNGrad",Rn="MatrixBandPart",Fn="Max",Dn="Maximum",Mn="MaxPool",On="MaxPoolGrad",Pn="MaxPool3D",Ln="MaxPool3DGrad",zn="MaxPoolWithArgmax",Bn="Mean",Wn="Min",Un="Minimum",Vn="MirrorPad",Gn="Mod",Hn="Multinomial",jn="Multiply",qn="Neg",Kn="NotEqual",Xn="NonMaxSuppressionV3",Yn="NonMaxSuppressionV4",Qn="NonMaxSuppressionV5",Jn="OnesLike",Zn="OneHot",er="Pack",tr="PadV2",nr="Pool",rr="Pow",ar="Prelu",ir="Prod",sr="RaggedGather",or="RaggedRange",lr="RaggedTensorToTensor",ur="Range",dr="Real",cr="Reciprocal",pr="Relu",hr="Reshape",fr="ResizeNearestNeighbor",mr="ResizeNearestNeighborGrad",gr="ResizeBilinear",yr="ResizeBilinearGrad",br="Relu6",vr="Reverse",xr="Round",wr="Rsqrt",kr="ScatterNd",Sr="TensorScatterUpdate",Ir="SearchSorted",Nr="Select",Tr="Selu",_r="Slice",Cr="Sin",Er="Sinh",Ar="Sign",$r="Sigmoid",Rr="Softplus",Fr="Sqrt",Dr="Sum",Mr="SpaceToBatchND",Or="SplitV",Pr="Softmax",Lr="SparseFillEmptyRows",zr="SparseReshape",Br="SparseSegmentMean",Wr="SparseSegmentSum",Ur="SparseToDense",Vr="SquaredDifference",Gr="Square",Hr="StaticRegexReplace",jr="StridedSlice",qr="StringNGrams",Kr="StringSplit",Xr="StringToHashBucketFast",Yr="Sub",Qr="Tan",Jr="Tanh",Zr="Tile",ea="TopK",ta="Transform",na="Transpose",ra="Unique",aa="Unpack",ia="UnsortedSegmentSum",sa="UpperBound",oa="ZerosLike",la="Step",ua="FromPixels",da="RotateWithOffset",ca="_FusedMatMul",pa="FusedConv2D",ha="FusedDepthwiseConv2D";function fa(){Ge().getBool("IS_TEST")||Ge().getBool("PROD")||console.warn(...arguments)}function ma(){Ge().getBool("IS_TEST")||Ge().getBool("PROD")||console.log(...arguments)}var ga=Ke("kernelRegistry",(()=>new Map)),ya=Ke("gradRegistry",(()=>new Map));function ba(e,t){let n=Ta(e,t);return ga.get(n)}function va(e){return ya.get(e)}function xa(e){let t=ga.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[i,s]=a,[o]=i.split("_");o===e&&n.push(s)}return n}function wa(e){let{kernelName:t,backendName:n}=e,r=Ta(t,n);ga.has(r)&&fa(`The kernel '${t}' for backend '${n}' is already registered`),ga.set(r,e)}function ka(e){let{kernelName:t}=e;ya.has(t)&&Ge().getBool("DEBUG")&&fa(`Overriding the gradient for '${t}'`),ya.set(t,e)}function Sa(e,t){let n=Ta(e,t);if(!ga.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);ga.delete(n)}function Ia(e){if(!ya.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ya.delete(e)}function Na(e,t){xa(e).forEach((e=>{wa(Object.assign({},e,{backendName:t}))}))}function Ta(e,t){return`${t}_${e}`}var _a={};function Ca(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}w(_a,{arraysEqual:()=>oe,arraysEqualWithNull:()=>se,assert:()=>te,assertNonNegativeIntegerDimensions:()=>Pe,assertNonNull:()=>re,assertShapesMatch:()=>ne,bytesFromStringArray:()=>Se,bytesPerElement:()=>ke,checkConversionForErrors:()=>ve,clamp:()=>X,computeStrides:()=>Ae,convertBackendValuesAndArrayBuffer:()=>Fe,createScalarValue:()=>Va,createShuffledIndices:()=>ce,decodeString:()=>Ka,distSquared:()=>ee,encodeString:()=>qa,fetch:()=>ja,fingerPrint64:()=>Ua,flatten:()=>Ya,getArrayFromDType:()=>be,getTypedArrayFromDType:()=>ye,hasEncodingLoss:()=>we,hexToLong:()=>$a,indexToLoc:()=>ze,inferDtype:()=>_e,inferFromImplicitShape:()=>fe,isBoolean:()=>Ne,isFunction:()=>Ce,isInt:()=>le,isNumber:()=>Te,isPromise:()=>Be,isScalarShape:()=>ie,isString:()=>Ie,isTypedArray:()=>Xa,isValidDtype:()=>xe,locToIndex:()=>Le,makeOnesTypedArray:()=>De,makeZerosNestedTypedArray:()=>Oe,makeZerosTypedArray:()=>Me,nearestDivisor:()=>Ee,nearestLargerEven:()=>Y,now:()=>Ha,parseAxisParam:()=>me,randUniform:()=>Z,repeatedTry:()=>he,rightPad:()=>pe,shuffle:()=>q,shuffleCombo:()=>K,sizeFromShape:()=>ae,sizeToSquarishShape:()=>de,squeezeShape:()=>ge,sum:()=>J,swap:()=>Q,tanh:()=>ue,toNestedArray:()=>Re,toTypedArray:()=>Ga});var Ea=k(S()),Aa=Ea.default||Ea;function $a(e){return Aa.fromString(e,!0,16)}var Ra=$a("c3a5c85c97cb3127"),Fa=$a("b492b66fbe98f273"),Da=$a("9ae16a3b2f90404f");function Ma(e){return e.xor(e.shru(47))}function Oa(e,t,n){let r=e.slice(t,t+n);return Aa.fromBytes(Array.from(r),!0,!0)}function Pa(e,t){return Oa(e,t,8)}function La(e,t){return Oa(e,t,4)}function za(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Ba(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:$a("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Wa(e,t,n,r){return function(e,t,n,r,a,i){a=a.add(e),i=za(i.add(a).add(r),21);let s=a;return a=(a=a.add(t)).add(n),i=i.add(za(a,44)),[a.add(r),i.add(s)]}(Pa(e,t),Pa(e,t+8),Pa(e,t+16),Pa(e,t+24),n,r)}function Ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=Aa.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){let n=Da.add(2*t),r=Pa(e,0).add(Da),a=Pa(e,t-8);return Ba(za(a,37).mul(n).add(r),za(r,25).add(a).mul(n),n)}if(t>=4){let n=Da.add(2*t);return Ba(La(e,0).shl(3).add(t),La(e,t-4),n)}if(t>0){let n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return Ma(Da.mul(n).xor(Ra.mul(r))).mul(Da)}return Da}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=Da.add(2*t),r=Pa(e,0).mul(Fa),a=Pa(e,8),i=Pa(e,t-8).mul(n),s=Pa(e,t-16).mul(Da);return Ba(za(r.add(a),43).add(za(i,30)).add(s),r.add(za(a.add(Da),18)).add(i),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=Da.add(2*t),r=Pa(e,0).mul(Da),a=Pa(e,8),i=Pa(e,t-8).mul(n),s=Pa(e,t-16).mul(Da),o=za(r.add(a),43).add(za(i,30)).add(s),l=Ba(o,r.add(za(a.add(Da),18)).add(i),n),u=Pa(e,16).mul(n),d=Pa(e,24),c=o.add(Pa(e,t-32)).mul(n),p=l.add(Pa(e,t-24)).mul(n);return Ba(za(u.add(d),43).add(za(c,30)).add(p),u.add(za(d.add(r),18)).add(c),n)}(e,t);let r=n,a=n.mul(Fa).add(113),i=Ma(a.mul(Da).add(113)).mul(Da),s=[Aa.UZERO,Aa.UZERO],o=[Aa.UZERO,Aa.UZERO];r=r.mul(Da).add(Pa(e,0));let l=0,u=64*(t-1>>6),d=u+(t-1&63)-63;do{r=za(r.add(a).add(s[0]).add(Pa(e,l+8)),37).mul(Fa),a=za(a.add(s[1]).add(Pa(e,l+48)),42).mul(Fa),r=r.xor(o[1]),a=a.add(s[0]).add(Pa(e,l+40)),i=za(i.add(o[0]),33).mul(Fa),s=Wa(e,l,s[1].mul(Fa),r.add(o[0])),o=Wa(e,l+32,i.add(o[1]),a.add(Pa(e,l+16))),[i,r]=[r,i],l+=64}while(l!==u);let c=Fa.add(i.and(255).shl(1));return l=d,o[0]=o[0].add(t-1&63),s[0]=s[0].add(o[0]),o[0]=o[0].add(s[0]),r=za(r.add(a).add(s[0]).add(Pa(e,l+8)),37).mul(c),a=za(a.add(s[1]).add(Pa(e,l+48)),42).mul(c),r=r.xor(o[1].mul(9)),a=a.add(s[0].mul(9).add(Pa(e,l+40))),i=za(i.add(o[0]),33).mul(c),s=Wa(e,l,s[1].mul(c),r.add(o[0])),o=Wa(e,l+32,i.add(o[1]),a.add(Pa(e,l+16))),[i,r]=[r,i],Ba(Ba(s[0],o[0],c).add(Ma(a).mul(Ra)).add(i),Ba(s[1],o[1],c).add(r),c)}function Va(e,t){return"string"===t?qa(e):Ga([e],t)}function Ga(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ya(e)),Ge().getBool("DEBUG")&&ve(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Ha(){return Ge().platform.now()}function ja(e,t){return Ge().platform.fetch(e,t)}function qa(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Ge().platform.encode(e,t)}function Ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Ge().platform.decode(e,t)}function Xa(e){return null!=Ge().platform.isTypedArray?Ge().platform.isTypedArray(e):Ca(e)}function Ya(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||Be(e)||null==e||Xa(e)&&n)t.push(e);else if(Array.isArray(e)||Xa(e))for(let r=0;r<e.length;++r)Ya(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)Ya(e[a],t,n)}return t}var Qa=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Za)}profileKernel(e,t,n){let r,a,i=()=>{r=n()},s=Ha();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:Ha()-s})}if(Ge().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let t=r[o];t.data().then((n=>{Ja(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:i}=e;n.forEach((e=>{Promise.all([e.data(),r,i]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function Ja(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var Za=class{logKernelProfile(e,t,n,r,a,i){let s="number"==typeof r?pe(`${r}ms`,9):r.error,o=pe(e,25),l=t.rank,u=t.size,d=pe(t.shape.toString(),14),c="";for(let p in a){let e=a[p];if(null!=e){let n=e.shape||t.shape,r=n.length;c+=`${p}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${s}\t%c${l}D ${d}\t%c${u}\t%c${c}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function ei(e,t,n,r){let a=Ae(t),i=function(e,t,n,r){let a=ae(t),i=r[r.length-1],s=new Array(i).fill(0),o=t.length,l="complex64"===n?ai(e):e;if(o>1)for(let u=0;u<a/i;u++){let e=u*i;for(let t=0;t<i;t++)s[t]=Math.max(s[t],ti(l[e+t],0,n).length)}return s}(e,t,n,a),s=t.length,o=ri(e,t,n,a,i),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${s}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function ti(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Ie(e)?`'${e}'`:"bool"===n?ni(e):parseFloat(e.toFixed(7)).toString(),pe(r,t)}function ni(e){return 0===e?"false":"true"}function ri(e,t,n,r,a){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],s="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[ti(ai(e)[0],0,n)]}return"bool"===n?[ni(e[0])]:[e[0].toString()]}if(1===l){if(o>20){let t=3*s,r=Array.from(e.slice(0,t)),i=Array.from(e.slice((o-3)*s,o*s));return"complex64"===n&&(r=ai(r),i=ai(i)),["["+r.map(((e,t)=>ti(e,a[t],n))).join(", ")+", ..., "+i.map(((e,t)=>ti(e,a[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?ai(e):Array.from(e)).map(((e,t)=>ti(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),d=r.slice(1),c=r[0]*s,p=[];if(o>20){for(let t=0;t<3;t++){let r=t*c,i=r+c;p.push(...ri(e.slice(r,i),u,n,d,a,!1))}p.push("...");for(let t=o-3;t<o;t++){let r=t*c,i=r+c;p.push(...ri(e.slice(r,i),u,n,d,a,t===o-1))}}else for(let m=0;m<o;m++){let t=m*c,r=t+c;p.push(...ri(e.slice(t,r),u,n,d,a,m===o-1))}let h=2===l?",":"";p[0]="["+(o>0?p[0]+h:"");for(let m=1;m<p.length-1;m++)p[m]=" "+p[m]+h;let f=",\n";for(let m=2;m<l;m++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(i?"":f),p}function ai(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var ii=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ae(e),null!=n){let e=n.length;te(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||be(t,this.size),this.strides=Ae(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),te(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));let a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(let i of t){if(i<0||i>=this.shape[r]){let e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let i=0;i<t.length-1;++i)a+=this.strides[i]*t[i];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return si().makeTensor(this.values,this.shape,this.dtype)}},si=null,oi=null;var li=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ae(e),this.strides=Ae(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return oi.buffer(this.shape,this.dtype,e)}bufferSync(){return oi.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Re(this.shape,e,"complex64"===this.dtype)}arraySync(){return Re(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=si().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map((e=>Ka(e)))}catch(NZ){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),si().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=si().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Ka(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await si().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),si().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return oi.print(this,e)}clone(){return this.throwIfDisposed(),oi.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return ei(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),oi.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),si().makeVariable(this,e,t,n)}};function ui(){return Ke("Tensor",(()=>li))}Object.defineProperty(li,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),ui();var di=class extends li{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!oe(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);si().disposeTensor(this),this.dataId=e.dataId,si().incRef(this,null)}dispose(){si().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(di,Symbol.hasInstance,{value:e=>e instanceof li&&null!=e.assign&&e.assign instanceof Function});var ci,pi,hi,fi,mi,gi,yi={};w(yi,{assertTypesMatch:()=>Ii,getTensorsInContainer:()=>Ti,isTensorInList:()=>Ni,makeTypesMatch:()=>Si}),(pi=ci||(ci={})).R0="R0",pi.R1="R1",pi.R2="R2",pi.R3="R3",pi.R4="R4",pi.R5="R5",pi.R6="R6",function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(hi||(hi={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(fi||(fi={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(mi||(mi={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(gi||(gi={}));var bi={float32:mi,int32:hi,bool:fi,complex64:gi};function vi(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return bi[e][t]}function xi(e){return vi(e,"int32")}function wi(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function ki(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Si(e,t){if(e.dtype===t.dtype)return[e,t];let n=vi(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ii(e,t){te(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function Ni(e,t){return t.some((t=>t.id===e.id))}function Ti(e){let t=[];return _i(e,t,new Set),t}function _i(e,t,n){if(null==e)return;if(e instanceof li)return void t.push(e);if(!function(e){return Array.isArray(e)||"object"==typeof e}(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),_i(e,t,n))}}function Ci(e){return null!=e.kernelName}var Ei=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Ai=class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ei}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(fa(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Qa(this.backendInstance),!0}setupRegisteredKernels(){xa(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){xa(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof H||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,fa(`Initialization of backend ${e} failed`),fa(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return fa(`Initialization of backend ${e} failed`),fa(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),i=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(TJ){throw t(),TJ}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){let t=Ri.runKernel(pn,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{let t={x:e},n={dtype:"float32"};return Ri.runKernel(vt,t,n)}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==ba(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=r-t-a-i;if(s>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${s} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),i=this.state.numBytes,s=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=Ci(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ci(e)){let{kernelName:t,inputs:i,attrs:s}=e;null==this.backendName&&this.backend;let l=ba(t,this.backendName);te(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:i,attrs:s,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,i,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,i=e=>{a&&(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,i)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:d,attrs:c}=e,p=Ci(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,d,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,d,t,p,r,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map((e=>null!=d[e]?d[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=va(e);if(null!=r){let e,a=r.inputsToSave||[],i=r.outputsToSave||[];r.saveAllInputs?(te(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let s=n.filter(((e,t)=>i[t]));return e.concat(s)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&Ie(e[0])&&(a=e.map((e=>qa(e))));let i=r.write(a,t,n),s=new li(t,n,i,this.nextTensorId());if(this.trackTensor(s,r),"string"===n){let e=this.state.tensorInfo.get(i),t=Se(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return s}makeTensorFromDataId(e,t,n,r){let a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,i=new li(r,a,n,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new di(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ke(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof di||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*ke(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,i){let s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=va(e);null!=o&&(r=o.gradFunc),null!=r&&(s.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=Me(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,i))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Ti(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(te(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));te(a instanceof li,(()=>"The result y returned by f() must be a tensor."));let i=function(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],i=n.inputs;for(let e in i){let s=i[e],o=!1;for(let e=0;e<t.length;e++)if(r[s.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}let i={};i[n.id]=!0;let s={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(i[t.outputs[e].id]){for(let e in n)i[n[e].id]=!0,s[t.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&s[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===i.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?function(e){let t=De(ae(e),"float32");return Ri.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){let i=t[a],s=[];if(i.outputs.forEach((t=>{let n=e[t.id];null!=n?s.push(n):s.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);let o=i.gradient(s);for(let t in i.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let s=i.inputs[t];if(!oe(a.shape,s.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${s.shape}'`);if(null==e[s.id])e[s.id]=a;else{let t=e[s.id];e[s.id]=r(t,a),t.dispose()}}}}(e,i,(e=>this.tidy(e)),Fi);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return te(Ce(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];te(r.every((e=>e instanceof li)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let i,s={};r.forEach(((e,t)=>{s[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(i=e(...r,n),te(i.value instanceof li,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),te(Ce(i.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),i.value),backwardsFunc:(e,t)=>{let n=i.gradFunc(e,t),a=Array.isArray(n)?n:[n];te(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),te(a.every((e=>e instanceof li)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let s={};return a.forEach(((e,t)=>{s[t]=()=>e})),s},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=Ha(),n=await this.backend.time(e);return n.wallMs=Ha()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ei;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function $i(){let e=qe();if(null==e._tfengine){let t=new Ue(e);e._tfengine=new Ai(t)}return function(e){je=e}(e._tfengine.ENV),function(e){si=e}((()=>e._tfengine)),e._tfengine}Ai.nextTensorId=0,Ai.nextVariableId=0;var Ri=$i();function Fi(e,t){let n={a:e,b:t};return Ri.runKernel(Je,n)}var Di,Mi={};function Oi(e){Di=e}function Pi(e){if(void 0!==Di)return Di;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Li(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}w(Mi,{isBrowser:()=>Li,isMobile:()=>Pi,mockIsMobile:()=>Oi});var zi=Ge();function Bi(e,t){let n=e;if(Xa(e))return"string"===t?[]:[e.length];if(wi(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(ki(e))return[e.buffer.size/(null==t?4:ke(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Xa(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Ge().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Wi(e,r,[]),r}function Wi(e,t,n){if(n=n||[],!Array.isArray(e)&&!Xa(e))return void te(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));te(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),te(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)Wi(e[a],r,n.concat(a))}function Ui(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Vi(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof ui())return Ui(r,e.dtype,t,n),e;let a=_e(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Ui(r,a,t,n),null==e||!Xa(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let i=Bi(e,a);!Xa(e)&&!Array.isArray(e)&&(e=[e]);let s="string"!==a?Ga(e,a):Ya(e,[],!0);return Ri.makeTensor(s,i,a)}function Gi(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>Vi(e,`${t}[${a}]`,n,r)))}zi.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),zi.registerFlag("IS_BROWSER",(()=>Li())),zi.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),zi.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),zi.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),zi.registerFlag("PROD",(()=>!1)),zi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>zi.getBool("DEBUG"))),zi.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),zi.registerFlag("IS_TEST",(()=>!1)),zi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>zi.getBool("DEBUG"))),zi.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),zi.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),zi.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var Hi="__op";function ji(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Hi;let a=function(){Ri.startScope(n);try{let e=r(...arguments);return Be(e)&&console.error("Cannot return a Promise inside of tidy."),Ri.endScope(e),e}catch(e){throw Ri.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var qi=ji({complex_:function(e,t){let n=Vi(e,"real","complex"),r=Vi(t,"imag","complex");ne(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return Ri.runKernel(kt,a)}});function Ki(e,t,n,r){if(null==r)r=_e(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ki(e)||wi(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Ri.backend.createTensorFromGPUData(e,t||n,r)}if(!Xa(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Pe(t);let e=ae(t),r=ae(n);te(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==ae(t.slice(a));te(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!Xa(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?Ga(e,r):Ya(e,[],!0),Ri.makeTensor(e,t,r)}function Xi(e,t,n){return Ki(e,t,Bi(e,n),n)}var Yi={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Qi=class e{static join(t){return new e(t).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map((e=>Xa(e)?e.buffer:e))).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),a=new Uint8Array(r),i=0;for(let s=n;s<this.shards.length;s++){let n=this.shards[s],r=e+i-n.start,o=i,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),i+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,i=t(e[a]);if(0===i)return a;i<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function Ji(){Ge().set("PROD",!0)}function Zi(){Ge().set("DEBUG",!0)}function es(){Ge().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ts(e){Ge().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function ns(){Ri.disposeVariables()}function rs(){return Ri}function as(){return Ri.memory()}function is(e){return Ri.profile(e)}function ss(e,t){return Ri.tidy(e,t)}function os(e){Ti(e).forEach((e=>e.dispose()))}function ls(e){return Ri.keep(e)}function us(e){return Ri.time(e)}function ds(e){return Ri.setBackend(e)}function cs(){return Ri.ready()}function ps(){return Ri.backendName}function hs(e){Ri.removeBackend(e)}function fs(e){return Ri.findBackend(e)}function ms(e){return Ri.findBackendFactory(e)}function gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Ri.registerBackend(e,t,n)}function ys(){return Ri.backend}function bs(e,t){Ge().setPlatform(e,t)}!function(e){0}(ts);async function vs(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<a.length;++i){let s=a[i],o=Array.isArray(e)?e[i].tensor:e[s];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${s}': ${o.dtype}`);let l={name:s,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n),a=0;for(let i=0;i<t.length;i++){let e=t[i],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=4,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:Ts(await Promise.all(r)),specs:n}}function xs(e,t){let n=new Qi(e),r={},a=0;for(let i of t){let e=ws(i,((e,t)=>n.slice(a+e,a+t)));r[i.name]=Ss(i,n.slice(a,a+e)),a+=e}return r}function ws(e,t){let n,r=ae(e.shape);if("quantization"in e){let t=e.quantization;n=Yi[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=4+new Uint32Array(t(e,e+4))[0];return e}n=Yi[e.dtype]}return r*n}async function ks(e,t){let n,r=ae(e.shape);if("quantization"in e){let t=e.quantization;n=Yi[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=4+new Uint32Array(await t(e,e+4))[0];return e}n=Yi[e.dtype]}return r*n}function Ss(e,t){let n,r=e.name,a=e.dtype,i=e.shape,s=ae(i),o=0;if("quantization"in e){let i=e.quantization;if("uint8"===i.dtype||"uint16"===i.dtype){if(!("min"in i)||!("scale"in i))throw new Error(`Weight ${e.name} with quantization ${i.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==i.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${i.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${e.name} is quantized with ${i.dtype} which only supports weights of type float32 not ${a}.`)}let l=Yi[i.dtype],u="uint8"===i.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===i.dtype||"uint16"===i.dtype){n=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=t*i.scale+i.min}}else{if("float16"!==i.dtype)throw new Error(`Unsupported quantization type ${i.dtype} for weight type float32.`);n=function(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let a=new ArrayBuffer(4*r.length),i=new Uint32Array(a);for(let s=0;s<r.length;s++){let a=r[s],o=e[n[a>>10]+(1023&a)]+t[a>>10];i[s]=o}return new Float32Array(a)}}()(u)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${r}': ${a}`);if("uint8"!==i.dtype&&"uint16"!==i.dtype)throw new Error(`Unsupported quantization type ${i.dtype} for weight type int32.`);n=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=Math.round(t*i.scale+i.min)}}o+=s*l}else if("string"===a){let r=ae(e.shape);n=[];for(let e=0;e<r;e++){let e=new Uint32Array(t.slice(o,o+4))[0];o+=4;let r=new Uint8Array(t.slice(o,o+e));n.push(r),o+=e}}else{let e=Yi[a];if("float32"===a)n=new Float32Array(t);else if("int32"===a)n=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){n=new Float32Array(t);let e=new Float32Array(n.length/2),r=new Float32Array(n.length/2);for(let t=0;t<e.length;t++)e[t]=n[2*t],r[t]=n[2*t+1];let a=Xi(e,i,"float32"),s=Xi(r,i,"float32"),o=qi(a,s);return a.dispose(),s.dispose(),o}throw new Error(`Unsupported dtype in weight '${r}': ${a}`)}n=new Uint8Array(t)}o+=s*e}return Xi(n,i,a)}async function Is(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:a}=await e.read();if(t&&null==a){let e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}let i=new Uint8Array(r.length+a.byteLength);i.set(r,0),i.set(new Uint8Array(a),r.length),r=i}return r.buffer}async function Ns(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let i of t){let e=await ks(i,(async(e,t)=>(a=await Is(r,a,t),a.slice(e,t))));a=await Is(r,a,e);let t=a.slice(0,e);a=a.slice(e);let s=Ss(i,t);if(n[i.name]=s,"webgpu"===ps()){let e=ys();"uploadToGPU"in e&&ae(s.shape)>=Ge().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(s.dataId)}}return n}function Ts(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var _s="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Cs(e){return _s?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Es(e){return Qi.join(e)}function As(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function $s(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function Rs(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function Fs(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),Rs(e,n,r)}function Ds(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Cs(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Cs(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Qi(e.weightData).byteLength}}function Ms(e){let t=[];for(let n of e)t.push(...n.weights);return t}var Os=class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerSaveRouter(t){e.getInstance().saveRouters.push(t)}static registerLoadRouter(t){e.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return e.getHandlers(t,"save")}static getLoadHandlers(t,n){return e.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return("load"===n?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach((e=>{let n=e(t,r);null!==n&&a.push(n)})),a}},Ps=e=>Os.registerSaveRouter(e),Ls=e=>Os.registerLoadRouter(e),zs=e=>Os.getSaveHandlers(e),Bs=(e,t)=>Os.getLoadHandlers(e,t),Ws="tensorflowjs",Us="models_store",Vs="model_info_store";function Gs(){if(!Ge().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Hs(e){let t=e.result;t.createObjectStore(Us,{keyPath:"modelPath"}),t.createObjectStore(Vs,{keyPath:"modelPath"})}var js=class{constructor(e){if(this.indexedDB=Gs(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(Ws,1);r.onupgradeneeded=()=>Hs(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(Us,"readonly"),r=t.objectStore(Us).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=Qi.join(t.weightData);let r,s,o=Ds(t),l=a.transaction(Vs,"readwrite"),u=l.objectStore(Vs);try{r=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(i){return n(i)}r.onsuccess=()=>{s=a.transaction(Us,"readwrite");let r,i=s.objectStore(Us);try{r=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(d){return n(d)}r.onsuccess=()=>e({modelArtifactsInfo:o}),r.onerror=e=>{u=l.objectStore(Vs);let t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),l.oncomplete=()=>{null==s?a.close():s.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};js.URL_SCHEME="indexeddb://";var qs=e=>Ge().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(js.URL_SCHEME)?function(e){return new js(e)}(e.slice(js.URL_SCHEME.length)):null;Os.registerSaveRouter(qs),Os.registerLoadRouter(qs);var Ks="/",Xs="tensorflowjs_models",Ys="info",Qs="model_topology",Js="weight_specs",Zs="weight_data",eo="model_metadata";function to(e){return{info:[Xs,e,Ys].join(Ks),topology:[Xs,e,Qs].join(Ks),weightSpecs:[Xs,e,Js].join(Ks),weightData:[Xs,e,Zs].join(Ks),modelMetadata:[Xs,e,eo].join(Ks)}}function no(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function ro(e){let t=e.split(Ks);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ks)}var ao=class{constructor(e){if(!Ge().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=to(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=Ds(e),i=Qi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(_s)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(i));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw no(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(_s){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(i),t}};ao.URL_SCHEME="localstorage://";var io=e=>Ge().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ao.URL_SCHEME)?function(e){return new ao(e)}(e.slice(ao.URL_SCHEME.length)):null;Os.registerSaveRouter(io),Os.registerLoadRouter(io);var so="://",oo=class e{constructor(){this.managers={}}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerManager(t,n){te(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(so)&&(t=t.slice(0,t.indexOf(so))),te(t.length>0,(()=>"scheme must not be an empty string."));let r=e.getInstance();te(null==r.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),r.managers[t]=n}static getManager(t){let n=e.getInstance().managers[t];if(null==n)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(e.getInstance().managers)}};function lo(e){if(-1===e.indexOf(so))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${oo.getSchemes().join(",")}`);return{scheme:e.split(so)[0],path:e.split(so)[1]}}async function uo(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];te(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=Os.getLoadHandlers(e);te(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),te(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],i=Os.getSaveHandlers(t);te(i.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),te(i.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let s=i[0],o=lo(e).scheme,l=lo(e).path,u=o===lo(e).scheme,d=await a.load();n&&u&&await oo.getManager(o).removeModel(l);let c=await s.save(d);return n&&!u&&await oo.getManager(o).removeModel(l),c.modelArtifactsInfo}async function co(){let e=oo.getSchemes(),t={};for(let n of e){let e=await oo.getManager(n).listModels();for(let r in e){t[n+so+r]=e[r]}}return t}async function po(e){let t=lo(e);return oo.getManager(t.scheme).removeModel(t.path)}async function ho(e,t){return uo(e,t,!1)}async function fo(e,t){return uo(e,t,!0)}if(Ge().get("IS_BROWSER")){Ge().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&Ge().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return Ca(e)}});try{oo.registerManager(ao.URL_SCHEME,new class{constructor(){te(Ge().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),te("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=Xs+Ks,n=Ks+Ys;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[ro(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){let t=to(e=function(e){return e.startsWith(ao.URL_SCHEME)?e.slice(ao.URL_SCHEME.length):e}(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return no(t),n}})}catch(pi){}try{oo.registerManager(js.URL_SCHEME,new class{constructor(){this.indexedDB=Gs()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(Ws,1);n.onupgradeneeded=()=>Hs(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(Vs,"readonly"),i=a.objectStore(Vs).getAll();i.onsuccess=()=>{let t={};for(let e of i.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},i.onerror=e=>(r.close(),t(i.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=function(e){return e.startsWith(js.URL_SCHEME)?e.slice(js.URL_SCHEME.length):e}(e),new Promise(((t,n)=>{let r=this.indexedDB.open(Ws,1);r.onupgradeneeded=()=>Hs(r),r.onsuccess=()=>{let a,i=r.result,s=i.transaction(Vs,"readwrite"),o=s.objectStore(Vs),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return i.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),s=()=>{a=i.transaction(Us,"readwrite");let r=a.objectStore(Us).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=s,r.onerror=e=>(s(),i.close(),n(l.error))}},l.onerror=e=>(i.close(),n(l.error)),s.oncomplete=()=>{null==a?i.close():a.oncomplete=()=>i.close()}},r.onerror=e=>n(r.error)}))}})}catch(pi){}}var mo,go=()=>I();function yo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",Pe(e),new ii(e,t,n)}Ge().get("IS_NODE")&&!Ge().get("IS_BROWSER")&&Ge().setPlatform("node",new class{constructor(){this.util=N(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Ge().global.fetch?Ge().global.fetch(e,t):(null==mo&&(mo=go()),mo(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var bo=ji({cast_:function(e,t){let n=Vi(e,"x","cast");if(!xe(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return Ri.runKernel(vt,r,a)}});var vo=ji({clone_:function(e){let t={x:Vi(e,"x","clone","string_or_numeric")};return Ri.runKernel(pn,t)}});function xo(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}$i(),function(e){oi=e}({buffer:yo,cast:bo,clone:vo,print:xo});var wo=ji({add_:function(e,t){let n=Vi(e,"a","add"),r=Vi(t,"b","add");[n,r]=Si(n,r);let a={a:n,b:r};return Ri.runKernel(Je,a)}});var ko=ji({floorDiv_:function(e,t){let n=Vi(e,"a","floorDiv"),r=Vi(t,"b","floorDiv");[n,r]=Si(n,r);let a={a:n,b:r};return Ri.runKernel(sn,a)}});var So=ji({div_:function(e,t){let n=Vi(e,"a","div"),r=Vi(t,"b","div");if([n,r]=Si(n,r),"int32"===n.dtype&&"int32"===r.dtype)return ko(n,r);let a={a:n,b:r};return Ri.runKernel(jt,a,{})}});var Io=ji({mul_:function(e,t){let n=Vi(e,"a","mul"),r=Vi(t,"b","mul");[n,r]=Si(n,r);let a={a:n,b:r};return Ri.runKernel(jn,a)}});var No=ji({abs_:function(e){let t=Vi(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return Ri.runKernel(St,e)}{let e={x:t};return Ri.runKernel(Xe,e)}}});var To=ji({acos_:function(e){let t={x:Vi(e,"x","acos")};return Ri.runKernel(Ye,t)}});var _o=ji({acosh_:function(e){let t={x:Vi(e,"x","acosh")};return Ri.runKernel(Qe,t)}});var Co=ji({addN_:function(e){te(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),te(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>Vi(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!oe(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return Ri.runKernel(Ze,r)}});var Eo=ji({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:Vi(e,"x","all","bool")},a={axis:t,keepDims:n};return Ri.runKernel(et,r,a)}});var Ao=ji({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:Vi(e,"x","any","bool")},a={axis:t,keepDims:n};return Ri.runKernel(tt,r,a)}});var $o=ji({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:Vi(e,"x","argMax")},r={axis:t};return Ri.runKernel(nt,n,r)}});var Ro=ji({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:Vi(e,"x","argMin")},r={axis:t};return Ri.runKernel(rt,n,r)}});var Fo=ji({asin_:function(e){let t={x:Vi(e,"x","asin")};return Ri.runKernel(at,t)}});var Do=ji({asinh_:function(e){let t={x:Vi(e,"x","asinh")};return Ri.runKernel(it,t)}});var Mo=ji({atan_:function(e){let t={x:Vi(e,"x","atan")};return Ri.runKernel(st,t)}});var Oo=ji({atan2_:function(e,t){let n=Vi(e,"a","atan2"),r=Vi(t,"b","atan2");[n,r]=Si(n,r);let a={a:n,b:r};return Ri.runKernel(lt,a)}});var Po=ji({atanh_:function(e){let t={x:Vi(e,"x","atanh")};return Ri.runKernel(ot,t)}});function Lo(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",i=arguments.length>5?arguments[5]:void 0;return Wo(e,[...t,e[3]],n,i,r,null,null,Qo(a))}function zo(e,t,n,r,a,i){let s,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",[l,u]=Go(t);if("channelsLast"===o)s=[l,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);s=[l,u,e[1],e[1]]}return Wo(e,s,n,r,a,i,!1,o)}function Bo(e,t,n,r,a,i){let s,o,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC",[u,d,c]=Ho(t);if("NDHWC"===l)o="channelsLast",s=[u,d,c,e[4],e[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);o="channelsFirst",s=[u,d,c,e[1],e[1]]}return Uo(e,s,n,r,a,!1,o,i)}function Wo(e,t,n,r,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,d,c]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,d,c]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,c,u,d]=e}let p,[h,f,,m]=t,[g,y]=Go(n),[b,v]=Go(r),x=jo(h,b),w=jo(f,v),{padInfo:k,outHeight:S,outWidth:I}=function(e,t,n,r,a,i,s,o,l){let u,d,c;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=function(e,t,n,r,a){null==r&&(r=Vo(e,t,n));let i=e[0],s=e[1],o=qo((i-t+2*r)/n+1,a),l=qo((s-t+2*r)/n+1,a);return[o,l]}([t,n],i,r,e,o);d=a[0],c=a[1]}else if("same"===e){d=Math.ceil(t/r),c=Math.ceil(n/a);let e=Math.max(0,(d-1)*r+i-t),o=Math.max(0,(c-1)*a+s-n),l=Math.floor(e/2),p=e-l,h=Math.floor(o/2);u={top:l,bottom:p,left:h,right:o-h,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-i+1)/r),c=Math.ceil((n-s+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let p="channelsLast"===l?e[1][0]:e[2][0],h="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:p,bottom:h,left:f,right:m,type:0===p&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},d=qo((t-i+p+h)/r+1,o),c=qo((n-s+f+m)/a+1,o)}}return{padInfo:u,outHeight:d,outWidth:c}}(a,u,d,g,y,x,w,i,o),N=s?m*c:m;return"channelsFirst"===o?p=[l,N,S,I]:"channelsLast"===o&&(p=[l,S,I,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:d,inChannels:c,outHeight:S,outWidth:I,outChannels:N,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:h,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:v,inShape:e,outShape:p,filterShape:t}}function Uo(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,d,c,p]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[l,u,d,c,p]=e;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[l,p,u,d,c]=e}let h,[f,m,g,,y]=t,[b,v,x]=Ho(n),[w,k,S]=Ho(r),I=jo(f,w),N=jo(m,k),T=jo(g,S),{padInfo:_,outDepth:C,outHeight:E,outWidth:A}=function(e,t,n,r,a,i,s,o,l,u,d){let c,p,h,f;if("valid"===e&&(e=0),"number"==typeof e){c={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function(e,t,n,r,a,i){null==a&&(a=Vo(e,t[0],r[0]));let s=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(s[o]=qo((e[o]-t[o]+2*a)/r[o]+1,i));return s}([t,n,r,1],[o,l,u],1,[a,i,s],e,d);p=m[0],h=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{p=Math.ceil(t/a),h=Math.ceil(n/i),f=Math.ceil(r/s);let e=(p-1)*a+o-t,d=(h-1)*i+l-n,m=(f-1)*s+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(d/2),v=d-b,x=Math.floor(m/2);c={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:c,outDepth:p,outHeight:h,outWidth:f}}(a,u,d,c,b,v,x,I,N,T,o),$=i?y*p:y;return"channelsFirst"===s?h=[l,$,C,E,A]:"channelsLast"===s&&(h=[l,C,E,A,$]),{batchSize:l,dataFormat:s,inDepth:u,inHeight:d,inWidth:c,inChannels:p,outDepth:C,outHeight:E,outWidth:A,outChannels:$,padInfo:_,strideDepth:b,strideHeight:v,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationDepth:w,dilationHeight:k,dilationWidth:S,inShape:e,outShape:h,filterShape:t}}function Vo(e,t,n){let r=jo(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function Go(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Ho(e){return"number"==typeof e?[e,e,e]:e}function jo(e,t){return t<=1?e:e+(e-1)*(t-1)}function qo(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ko(e){let[t,n,r]=Go(e);return 1===t&&1===n&&1===r}function Xo(e,t){return Ko(e)||Ko(t)}function Yo(e){return Go(e).every((e=>e>0))}function Qo(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Jo(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)te(le(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{te(le(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}var Zo=ji({reshape_:function(e,t){let n={x:Vi(e,"x","reshape","string_or_numeric")},r={shape:t};return Ri.runKernel(hr,n,r)}});var el=ji({avgPool_:function(e,t,n,r,a){let i=Vi(e,"x","avgPool","float32");te(Xo(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let s=i,o=!1;3===i.rank&&(o=!0,s=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2]])),te(4===s.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${s.rank}.`)),Jo("avgPool",r,a);let l={x:s},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=Ri.runKernel(ut,l,u);return d=bo(d,i.dtype),o?Zo(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var tl=ji({avgPool3d_:function(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",s=Vi(e,"x","avgPool3d","float32"),o=s,l=!1;4===s.rank&&(l=!0,o=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),te(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),te("NDHWC"===i,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),te("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Jo("avgPool3d",r,a);let u={x:o},d={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:i},c=Ri.runKernel(ct,u,d);return c=bo(c,o.dtype),l?Zo(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}});var nl=ji({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;te(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=Gi(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return vo(n[0]);let r=n,a={axis:t};return Ri.runKernel(It,r,a)}});var rl=ji({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Vi(e,"a","matMul"),i=Vi(t,"b","matMul");[a,i]=Si(a,i);let s={a:a,b:i},o={transposeA:n,transposeB:r};return Ri.runKernel(ht,s,o)}});var al=ji({sigmoid_:function(e){let t={x:Vi(e,"x","sigmoid","float32")};return Ri.runKernel($r,t)}});var il=ji({slice_:function(e,t,n){let r=Vi(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},i={begin:t,size:n};return Ri.runKernel(_r,a,i)}});var sl=ji({tanh_:function(e){let t={x:Vi(e,"x","tanh","float32")};return Ri.runKernel(Jr,t)}});var ol=ji({basicLSTMCell_:function(e,t,n,r,a,i){let s=Vi(e,"forgetBias","basicLSTMCell"),o=Vi(t,"lstmKernel","basicLSTMCell"),l=Vi(n,"lstmBias","basicLSTMCell"),u=Vi(r,"data","basicLSTMCell"),d=Vi(a,"c","basicLSTMCell"),c=Vi(i,"h","basicLSTMCell"),p=nl([u,c],1),h=rl(p,o),f=wo(h,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=il(f,[0,0],y),v=il(f,[0,g],y),x=il(f,[0,2*g],y),w=il(f,[0,3*g],y),k=wo(Io(al(b),sl(v)),Io(d,al(wo(s,x))));return[k,Io(sl(k),al(w))]}});var ll=ji({batchToSpaceND_:function(e,t,n){let r=Vi(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));te(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),te(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),te(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let i={x:r},s={blockShape:t,crops:n};return Ri.runKernel(ft,i,s)}});function ul(e){let t;return t=0===e.rank||1===e.rank?Zo(e,[1,1,1,e.size]):2===e.rank?Zo(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Zo(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var dl=ji({batchNorm_:function(e,t,n,r,a,i){null==i&&(i=.001);let s,o,l=Vi(e,"x","batchNorm"),u=Vi(t,"mean","batchNorm"),d=Vi(n,"variance","batchNorm");null!=a&&(s=Vi(a,"scale","batchNorm")),null!=r&&(o=Vi(r,"offset","batchNorm")),te(u.rank===d.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),te(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),te(null==s||u.rank===s.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let c={x:ul(l),scale:s,offset:o,mean:u,variance:d},p={varianceEpsilon:i},h=Ri.runKernel(on,c,p);return Zo(h,l.shape)}});var cl=ji({batchNorm2d_:function(e,t,n,r,a,i){let s,o,l=Vi(e,"x","batchNorm"),u=Vi(t,"mean","batchNorm"),d=Vi(n,"variance","batchNorm");return null!=a&&(s=Vi(a,"scale","batchNorm")),null!=r&&(o=Vi(r,"offset","batchNorm")),te(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),te(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),te(2===d.rank||1===d.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${d.rank}.`)),null!=s&&te(2===s.rank||1===s.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${s.rank}.`)),null!=o&&te(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),dl(l,u,d,o,s,i)}});var pl=ji({batchNorm3d_:function(e,t,n,r,a,i){let s,o,l=Vi(e,"x","batchNorm"),u=Vi(t,"mean","batchNorm"),d=Vi(n,"variance","batchNorm");return null!=a&&(s=Vi(a,"scale","batchNorm")),null!=r&&(o=Vi(r,"offset","batchNorm")),te(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),te(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),te(3===d.rank||1===d.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${d.rank}.`)),null!=s&&te(3===s.rank||1===s.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${s.rank}.`)),null!=o&&te(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),dl(l,u,d,o,s,i)}});var hl=ji({batchNorm4d_:function(e,t,n,r,a,i){let s,o,l=Vi(e,"x","batchNorm"),u=Vi(t,"mean","batchNorm"),d=Vi(n,"variance","batchNorm");return null!=a&&(s=Vi(a,"scale","batchNorm")),null!=r&&(o=Vi(r,"offset","batchNorm")),te(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),te(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),te(4===d.rank||1===d.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${d.rank}.`)),null!=s&&te(4===s.rank||1===s.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${s.rank}.`)),null!=o&&te(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),dl(l,u,d,o,s,i)}});var fl=ji({bincount_:function(e,t,n){let r=Vi(e,"x","bincount"),a=Vi(t,"weights","bincount");te("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),te(n>=0,(()=>`size must be non-negative, but got ${n}.`)),te(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let i={x:r,weights:a},s={size:n};return Ri.runKernel(mt,i,s)}});var ml=ji({bitwiseAnd_:function(e,t){let n=Vi(e,"x","bitwiseAnd"),r=Vi(t,"y","bitwiseAnd");if(!oe(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return Ri.runKernel(gt,a)}});var gl=ji({broadcastArgs_:function(e,t){let n=Vi(e,"s0","broadcastArgs","int32"),r=Vi(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return Ri.runKernel(bt,a)}});var yl=ji({broadcastTo_:function(e,t){let n=Vi(e,"broadcastTo","x"),r=n.shape;if(Pe(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Zo(n,e)}let a=n.shape,i=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])i[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===i.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return vo(n);let s={x:n},o={reps:i};return Ri.runKernel(Zr,s,o)}});var bl=ji({ceil_:function(e){let t={x:Vi(e,"x","ceil","float32")};return Ri.runKernel(xt,t)}});function vl(e,t,n){Pe(e);let r={shape:e,value:t,dtype:n=n||_e(t)};return Ri.runKernel(nn,{},r)}var xl=ji({clipByValue_:function(e,t,n){let r=Vi(e,"x","clipByValue");if(te(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return vl(r.shape,t,r.dtype);let a={x:r},i={clipValueMin:t,clipValueMax:n};return Ri.runKernel(wt,a,i)}});var wl=ji({concat1d_:function(e){return nl(e,0)}});var kl=ji({concat2d_:function(e,t){return nl(e,t)}});var Sl=ji({concat3d_:function(e,t){return nl(e,t)}});var Il=ji({concat4d_:function(e,t){return nl(e,t)}});var Nl=ji({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,o=Vi(e,"x","conv2d","float32"),l=Vi(t,"filter","conv2d","float32"),u=o,d=!1;3===o.rank&&(d=!0,u=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),te(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),te(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Jo("conv2d",r,s);let c="NHWC"===a?u.shape[3]:u.shape[1];te(c===l.shape[2],(()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${l.shape[2]}.`)),te(Xo(n,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),te(Yo(i),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),te(Yo(n),(()=>"Error in conv2D: Strides should be larger than 0."));let p={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:s},f=Ri.runKernel(Nt,p,h);return d?Zo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Tl=ji({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,s=arguments.length>6?arguments[6]:void 0,o=Vi(e,"x","conv1d"),l=Vi(t,"filter","conv1d"),u=o,d=!1;2===o.rank&&(d=!0,u=Zo(o,[1,o.shape[0],o.shape[1]])),te(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),te(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Jo("conv1d",r,s),te(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),te(Xo(n,i),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`)),te(Yo(i),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),te(Yo(n),(()=>"Error in conv1D: Stride should be larger than 0.")),te("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let c=Zo(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=Zo(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=Nl(p,c,[1,n],r,"NHWC",[1,i],s);return Zo(h,d?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}});var _l=ji({conv2DBackpropInput_:function(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0;te(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),te(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),te(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),te(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let d="NHWC"===i?o[3]:o[1],c="NHWC"===i?l.shape[3]:l.shape[1];te(d===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[2]}.`)),te(c===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[3]}.`)),Jo("conv2dDerInput",a,s);let p={dy:l,filter:n},h={strides:r,pad:a,dataFormat:i,dimRoundingMode:s,inputShape:o},f=Ri.runKernel(_t,p,h);return u?Zo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Cl=ji({conv2dTranspose_:function(e,t,n,r,a,i){let s=Vi(e,"x","conv2dTranspose"),o=Vi(t,"filter","conv2dTranspose");return _l(n,s,o,r,a,"NHWC",i)}});var El=ji({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1],s=Vi(e,"x","conv3d"),o=Vi(t,"filter","conv3d"),l=s,u=!1;4===s.rank&&(u=!0,l=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),te(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),te(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),te(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),te(Xo(n,i),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),te("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),te(Yo(i),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),te(Yo(n),(()=>"Error in conv3D: Strides should be larger than 0."));let d={x:l,filter:o},c={strides:n,pad:r,dataFormat:a,dilations:i},p=Ri.runKernel(Ct,d,c);return u?Zo(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});var Al=ji({conv3DBackpropInput_:function(e,t,n,r,a){te(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let i=e,s=t,o=!1;4===t.rank&&(o=!0,s=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);let l=i[4],u=s.shape[4];te(5===i.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`)),te(5===s.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`)),te(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),te(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),te(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let d={dy:s,filter:n},c={pad:a,strides:r,inputShape:i},p=Ri.runKernel(At,d,c);return o?Zo(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});var $l=ji({conv3dTranspose_:function(e,t,n,r,a){let i=Vi(e,"x","conv3dTranspose"),s=Vi(t,"filter","conv3dTranspose");return Al(n,i,s,r,a)}});var Rl=ji({cos_:function(e){let t={x:Vi(e,"x","cos","float32")};return Ri.runKernel($t,t)}});var Fl=ji({cosh_:function(e){let t={x:Vi(e,"x","cosh","float32")};return Ri.runKernel(Rt,t)}});var Dl=ji({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:Vi(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:r};return Ri.runKernel(Ft,a,i)}});var Ml=ji({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:Vi(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:r};return Ri.runKernel(Dt,a,i)}});var Ol=ji({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Vi(e,"x","denseBincount"),i=Vi(t,"weights","denseBincount");te("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),te(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),te(n>=0,(()=>`size must be non-negative, but got ${n}.`)),te(i.size===a.size||0===i.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${i.shape}.`));let s={x:a,weights:i},o={size:n,binaryOutput:r};return Ri.runKernel(Ot,s,o)}});var Pl=ji({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC",r=Vi(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],i="NHWC"===n?r.shape[2]:r.shape[3],s="NHWC"===n?r.shape[3]:r.shape[1];te(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),te(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),te(i*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),te(s%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${s} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return Ri.runKernel(Pt,o,l)}});var Ll=ji({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,o=Vi(e,"x","depthwiseConv2d","float32"),l=Vi(t,"filter","depthwiseConv2d","float32"),u=o,d=!1;3===o.rank&&(d=!0,u=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),te(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),te(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));let c="NHWC"===a?u.shape[3]:u.shape[1];te(c===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Jo("depthwiseConv2d",r,s);let p={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:s},f=Ri.runKernel(Lt,p,h);return d?Zo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var zl=ji({diag_:function(e){let t={x:Vi(e,"x","diag")};return Ri.runKernel(Wt,t)}});var Bl=ji({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=Vi(e,"x","dilation2d"),o=Vi(t,"filter","dilation2d");te(3===s.rank||4===s.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${s.rank}.`)),te(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),te("NHWC"===i,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`));let l=s,u=!1;3===s.rank&&(l=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2]]),u=!0),te(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));let d={x:l,filter:o},c={strides:n,pad:r,dilations:a},p=Ri.runKernel(Ut,d,c);return u?Zo(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Wl={};function Ul(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let i=n-1-a,s=e[i]||1;(t[t.length-1-a]||1)>1&&1===s&&r.unshift(i)}return r}function Vl(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],i=t.length-r-1,s=t[i];(null==a||1===a&&s>1)&&n.unshift(i)}return n}function Gl(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let i=e[e.length-a-1];null==i&&(i=1);let s=t[t.length-a-1];if(null==s&&(s=1),1===i)r[n-a-1]=s;else if(1===s)r[n-a-1]=i;else{if(i!==s){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=i}}return r}w(Wl,{assertAndGetBroadcastShape:()=>Gl,getBroadcastDims:()=>Ul,getReductionAxes:()=>Vl});var Hl=ji({equal_:function(e,t){let n=Vi(e,"a","equal","string_or_numeric"),r=Vi(t,"b","equal","string_or_numeric");[n,r]=Si(n,r),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(Qt,a)}});var jl=ji({where_:function(e,t,n){let r=Vi(t,"a","where"),a=Vi(n,"b","where"),i=Vi(e,"condition","where","bool"),s=Gl(Gl(i.shape,r.shape),a.shape),o={condition:yl(i,s),t:yl(r,s),e:yl(a,s)};return Ri.runKernel(Nr,o)}});var ql=ji({zerosLike_:function(e){let t={x:Vi(e,"x","zerosLike")};return Ri.runKernel(oa,t)}});var Kl=ji({divNoNan_:function(e,t){let n=Vi(e,"a","div"),r=Vi(t,"b","div");[n,r]=Si(n,r);let a=So(n,r),i=ql(a),s=Hl(r,i);return jl(s,i,a)}});var Xl=ji({dot_:function(e,t){let n=Vi(e,"t1","dot"),r=Vi(t,"t2","dot");te((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],i=1===r.rank?r.size:r.shape[0];if(te(a===i,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${i}.`)),1===n.rank&&1===r.rank){let e=Zo(n,[1,-1]),t=Zo(r,[-1,1]),a=rl(e,t);return Zo(a,[])}if(1===n.rank&&2===r.rank){let e=Zo(n,[1,-1]),t=Zo(r,[r.shape[0],r.shape[1]]),a=rl(e,t);return Zo(a,[a.size])}if(2===n.rank&&1===r.rank){let e=Zo(r,[-1,1]),t=rl(n,e);return Zo(t,[t.size])}{let e=Zo(r,[r.shape[0],r.shape[1]]);return rl(n,e)}}});var Yl=ji({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];let a=n.map(((e,t)=>Vi(e,`tensors${t}`,"einsum"))),i={equation:e};return Ri.runKernel(qt,a,i)}});var Ql=ji({elu_:function(e){let t={x:Vi(e,"x","elu","float32")};return Ri.runKernel(Kt,t)}});var Jl=ji({ensureShape_:function(e,t){let n=Vi(e,"x","ensureShape","string_or_numeric");if(!se(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});var Zl=ji({erf_:function(e){let t=Vi(e,"x","erf");te("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=bo(t,"float32"));let n={x:t};return Ri.runKernel(Yt,n)}});function eu(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function tu(e,t,n){let r=e.length+t.length,a=[],i=0,s=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[i++]):a.push(t[s++]);return a}function nu(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function ru(e,t){return tu(e,t.map((e=>1)),t)}function au(e,t,n){te(eu(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function iu(e,t){if(eu(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function su(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function ou(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var lu=ji({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:Vi(e,"x","max")},a={reductionIndices:t,keepDims:n};return Ri.runKernel(Fn,r,a)}});var uu=ji({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:Vi(e,"x","min")},a={axis:t,keepDims:n};return Ri.runKernel(Wn,r,a)}});var du=ji({pow_:function(e,t){let n=Vi(e,"base","pow"),r=Vi(t,"exp","pow");[n,r]=Si(n,r);let a={a:n,b:r};return Ri.runKernel(rr,a)}});function cu(e,t){if((Xa(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Xa(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ki(e,[],[],t)}var pu=ji({sqrt_:function(e){let t={x:Vi(e,"x","sqrt","float32")};return Ri.runKernel(Fr,t)}});var hu=ji({square_:function(e){let t=Vi(e,"x","square");return Ri.runKernel("Square",{x:t},{})}});var fu=ji({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Vi(e,"x","sum");"bool"===r.dtype&&(r=bo(r,"int32"));let a={x:r},i={axis:t,keepDims:n};return Ri.runKernel(Dr,a,i)}});function mu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return No(e);if(1!==e.rank&&null===n)return mu(Zo(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return fu(No(e),n);if(t===1/0)return lu(No(e),n);if(t===-1/0)return uu(No(e),n);if("euclidean"===t||2===t)return pu(fu(du(No(e),cu(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return lu(fu(No(e),n[0]),n[1]-1);if(t===1/0)return lu(fu(No(e),n[1]),n[0]);if(t===-1/0)return uu(fu(No(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return pu(fu(hu(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var gu=ji({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=mu(e=Vi(e,"x","norm"),t,n),i=a.shape;if(r){let t=me(n,e.shape);i=ru(a.shape,t)}return Zo(a,i)}});var yu=ji({euclideanNorm_:function(e){return gu(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});var bu=ji({exp_:function(e){let t={x:Vi(e,"x","exp")};return Ri.runKernel(Jt,t)}});var vu=ji({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Vi(e,"x","expandDims","string_or_numeric");te(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return Ri.runKernel(Zt,r,a)}});var xu=ji({expm1_:function(e){let t={x:Vi(e,"x","expm1")};return Ri.runKernel(en,t)}});var wu=ji({tile_:function(e,t){let n=Vi(e,"x","tile","string_or_numeric");te(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return Ri.runKernel(Zr,r,a)}});var ku=ji({eye_:function(e,t,n){null==t&&(t=e);let r=yo([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let s=0;s<a;++s)r.set(1,s,s);let i=Zo(r.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return wu(vu(i,0),[n[0],1,1]);if(2===n.length)return wu(vu(vu(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return wu(vu(vu(vu(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var Su=ji({floor_:function(e){let t={x:Vi(e,"x","floor","float32")};return Ri.runKernel(an,t)}});var Iu=ji({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a={x:Vi(e,"x","gather"),indices:Vi(t,"indices","gather","int32")},i={axis:n,batchDims:r};return Ri.runKernel(ln,a,i)}});var Nu=ji({greater_:function(e,t){let n=Vi(e,"a","greater","string_or_numeric"),r=Vi(t,"b","greater","string_or_numeric");[n,r]=Si(n,r),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(dn,a)}});var Tu=ji({greaterEqual_:function(e,t){let n=Vi(e,"a","greaterEqual","string_or_numeric"),r=Vi(t,"b","greaterEqual","string_or_numeric");[n,r]=Si(n,r),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(cn,a)}});var _u=ji({imag_:function(e){let t={input:Vi(e,"input","imag")};return Ri.runKernel(fn,t)}});var Cu=ji({isFinite_:function(e){let t={x:Vi(e,"x","isFinite")};return Ri.runKernel(mn,t)}});var Eu=ji({isInf_:function(e){let t={x:Vi(e,"x","isInf")};return Ri.runKernel(gn,t)}});var Au=ji({isNaN_:function(e){let t={x:Vi(e,"x","isNaN")};return Ri.runKernel(yn,t)}});var $u=ji({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2,n={x:Vi(e,"x","leakyRelu")},r={alpha:t};return Ri.runKernel(bn,n,r)}});var Ru=ji({less_:function(e,t){let n=Vi(e,"a","less","string_or_numeric"),r=Vi(t,"b","less","string_or_numeric");[n,r]=Si(n,r),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(vn,a)}});var Fu=ji({lessEqual_:function(e,t){let n=Vi(e,"a","lessEqual","string_or_numeric"),r=Vi(t,"b","lessEqual","string_or_numeric");[n,r]=Si(n,r),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(xn,a)}});function Du(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return Ri.runKernel(wn,{},r)}var Mu=ji({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=Vi(e,"x","localResponseNormalization");te(4===i.rank||3===i.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`)),te(le(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let s=i,o=!1;3===i.rank&&(o=!0,s=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let l={x:s},u={depthRadius:t,bias:n,alpha:r,beta:a},d=Ri.runKernel(An,l,u);return o?Zo(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var Ou=ji({log_:function(e){let t={x:Vi(e,"x","log","float32")};return Ri.runKernel(kn,t)}});var Pu=ji({log1p_:function(e){let t={x:Vi(e,"x","log1p")};return Ri.runKernel(Sn,t)}});function Lu(e){return te(Ce(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=Vi(t,"x","tf.grad","string_or_numeric"),a=null!=n?Vi(n,"dy","tf.grad"):null;return Ri.tidy((()=>{let{value:t,grads:n}=Ri.gradients((()=>e(r)),[r],a);return null!=a&&ne(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Gu(n),n[0]}))}}function zu(e){return te(Ce(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{te(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=Gi(t,"args","tf.grads","string_or_numeric"),a=null!=n?Vi(n,"dy","tf.grads"):null;return Ri.tidy((()=>{let{value:t,grads:n}=Ri.gradients((()=>e(...r)),r,a);return null!=a&&ne(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Gu(n),n}))}}function Bu(e){return te(Ce(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{te(t instanceof li,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),te(null==n||n instanceof li,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=Ri.gradients((()=>e(t)),[t],n);return Gu(r),{grad:r[0],value:a}}}function Wu(e){return te(Ce(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{te(Array.isArray(t)&&t.every((e=>e instanceof li)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),te(null==n||n instanceof li,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=Ri.gradients((()=>e(...t)),t,n);return null!=n&&ne(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Gu(r.grads),r}}function Uu(e,t){te(Ce(e),(()=>"The f passed in variableGrads(f) must be a function")),te(null==t||Array.isArray(t)&&t.every((e=>e instanceof di)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in Ri.registeredVariables)t.push(Ri.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;te((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let{value:i,grads:s}=Ri.gradients(e,t,null,!0);te(s.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),te(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));let o={};return t.forEach(((e,t)=>{null!=s[t]&&(o[e.name]=s[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:i,grads:o}}function Vu(e){return Ri.customGrad(e)}function Gu(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var Hu=ji({neg_:function(e){let t={x:Vi(e,"x","neg")};return Ri.runKernel(qn,t)}});var ju=ji({softplus_:function(e){let t={x:Vi(e,"x","softplus")};return Ri.runKernel(Rr,t)}});var qu=ji({logSigmoid_:function(e){let t=Vi(e,"x","logSigmoid");return Vu((e=>({value:Hu(ju(Hu(e))),gradFunc:t=>Io(t,al(Hu(e)))})))(t)}});var Ku=ji({sub_:function(e,t){let n=Vi(e,"a","sub"),r=Vi(t,"b","sub");[n,r]=Si(n,r);let a={a:n,b:r};return Ri.runKernel(Yr,a)}});var Xu=ji({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=Vi(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Vu(((e,n)=>{let r=lu(e,t,!0),a=Ku(e,r),i=Ku(bo(a,"float32"),Ou(fu(bu(a),t,!0)));return n([i]),{value:i,gradFunc:(e,n)=>{let[r]=n,a=bu(r);return Ku(e,Io(fu(e,t,!0),a))}}}))(n)}});var Yu=ji({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Vi(e,"x","logSumExp"),a=me(t,r.shape),i=lu(r,a,!0),s=Ku(r,i),o=bu(s),l=fu(o,a),u=Ou(l),d=wo(Zo(i,u.shape),u);if(n){let e=ru(d.shape,a);return Zo(d,e)}return d}});var Qu=ji({logicalAnd_:function(e,t){let n=Vi(e,"a","logicalAnd","bool"),r=Vi(t,"b","logicalAnd","bool");Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(In,a)}});var Ju=ji({logicalNot_:function(e){let t={x:Vi(e,"x","logicalNot","bool")};return Ri.runKernel(Nn,t)}});var Zu=ji({logicalOr_:function(e,t){let n=Vi(e,"a","logicalOr","bool"),r=Vi(t,"b","logicalOr","bool");Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(Tn,a)}});var ed=ji({logicalXor_:function(e,t){let n=Vi(e,"a","logicalXor","bool"),r=Vi(t,"b","logicalXor","bool");return Gl(n.shape,r.shape),Qu(Zu(e,t),Ju(Qu(e,t)))}}),td=2147483648;var nd=ji({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left",r=Vi(e,"sortedSequence","searchSorted"),a=Vi(t,"values","searchSorted"),i=r.shape[r.shape.length-1],s=a.shape[a.shape.length-1],o=Zo(r,[-1,i]),l=Zo(a,[-1,s]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ae(l.shape)>=td)throw new Error(`values tensor size must less than ${td}`);if(o.shape[1]>=td)throw new Error(`trailing dim_size must less than ${td} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},d={side:n};return Ri.runKernel(Ir,u,d)}});function rd(e,t){return nd(e,t,"left")}var ad=ji({maxPool_:function(e,t,n,r,a){let i=Vi(e,"x","maxPool"),s=i,o=!1;3===i.rank&&(o=!0,s=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2]])),te(4===s.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${s.rank}.`)),te(Xo(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Jo("maxPool",r,a);let l={x:s},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=Ri.runKernel(Mn,l,u);return o?Zo(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var id=ji({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",s=Vi(e,"x","maxPool3d"),o=s,l=!1;4===s.rank&&(l=!0,o=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),te(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),te("NDHWC"===i,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),Jo("maxPool3d",r,a);let u={x:o},d={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:i},c=Ri.runKernel(Pn,u,d);return l?Zo(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}});var sd=ji({maxPoolWithArgmax_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i={x:Vi(e,"x","maxPoolWithArgmax")},s={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=Ri.runKernel(zn,i,s);return{result:o[0],indexes:o[1]}}});var od=ji({maximum_:function(e,t){let n=Vi(e,"a","maximum"),r=Vi(t,"b","maximum");[n,r]=Si(n,r),"bool"===n.dtype&&(n=bo(n,"int32"),r=bo(r,"int32")),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(Dn,a)}});var ld=ji({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:Vi(e,"x","mean")},a={axis:t,keepDims:n};return Ri.runKernel(Bn,r,a)}});function ud(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Pe(e),"complex64"===t){let t=ud(e,"float32"),n=ud(e,"float32");return qi(t,n)}let n=Me(ae(e),t);return Ri.makeTensor(n,e,t)}function dd(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Pe(e),"complex64"===t){let t=dd(e,"float32"),n=ud(e,"float32");return qi(t,n)}let n=De(ae(e),t);return Ri.makeTensor(n,e,t)}function cd(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=Vi(e,"x","meshgrid",e instanceof li?e.dtype:"float32");if(void 0===t)return[r];let a=Vi(t,"y","meshgrid",t instanceof li?t.dtype:"float32"),i=ae(r.shape),s=ae(a.shape);return"xy"===n?(r=Zo(r,[1,-1]),a=Zo(a,[-1,1]),[rl(dd([s,1],r.dtype),r),rl(a,dd([1,i],a.dtype))]):(r=Zo(r,[-1,1]),a=Zo(a,[1,-1]),[rl(r,dd([1,s],r.dtype)),rl(dd([i,1],a.dtype),a)])}var pd=ji({minimum_:function(e,t){let n=Vi(e,"a","minimum"),r=Vi(t,"b","minimum");[n,r]=Si(n,r),"bool"===n.dtype&&(n=bo(n,"int32"),r=bo(r,"int32")),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(Un,a)}});var hd=ji({mirrorPad_:function(e,t,n){te("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=Vi(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");te(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)te(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),te(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));let i={paddings:t,mode:n},s={x:r};return Ri.runKernel(Vn,s,i)}});var fd=ji({mod_:function(e,t){let n=Vi(e,"a","mod"),r=Vi(t,"b","mod");[n,r]=Si(n,r);let a={a:n,b:r};return Ri.runKernel(Gn,a)}});var md=ji({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=me(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Vi(e,"x","moments")).shape),r=ld(e,n,t),a=r.shape;t||(a=ru(r.shape,n));let i=hu(Ku(bo(e,"float32"),Zo(r,a)));return{mean:r,variance:ld(i,n,t)}}});var gd=ji({multiRNNCell_:function(e,t,n,r){let a=Vi(t,"data","multiRNNCell"),i=Gi(n,"c","multiRNNCell"),s=Gi(r,"h","multiRNNCell"),o=a,l=[];for(let c=0;c<e.length;c++){let t=e[c](o,i[c],s[c]);l.push(t[0]),l.push(t[1]),o=t[1]}let u=[],d=[];for(let c=0;c<l.length;c+=2)u.push(l[c]),d.push(l[c+1]);return[u,d]}});var yd=ji({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Vi(e,"logits","multinomial"),i=a.size,s=a.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(s>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${s}`);n=n||Math.random();let o={logits:1===s?Zo(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=Ri.runKernel(Hn,o,l);return 1===s?Zo(u,[u.size]):u}});var bd=ji({notEqual_:function(e,t){let n=Vi(e,"a","notEqual","string_or_numeric"),r=Vi(t,"b","notEqual","string_or_numeric");[n,r]=Si(n,r),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(Kn,a)}});var vd=ji({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:Vi(e,"indices","oneHot","int32")},s={dtype:a,depth:t,onValue:n,offValue:r};return Ri.runKernel(Zn,i,s)}});var xd=ji({onesLike_:function(e){let t={x:Vi(e,"x","onesLike")};return Ri.runKernel(Jn,t)}});var wd=ji({outerProduct_:function(e,t){let n=Vi(e,"v1","outerProduct"),r=Vi(t,"v2","outerProduct");te(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=Zo(n,[-1,1]),i=Zo(r,[1,-1]);return rl(a,i)}});var kd=ji({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=Vi(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},i={x:r};return Ri.runKernel(tr,i,a)}});var Sd=ji({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return te(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),kd(e,[t],n)}});var Id=ji({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return te(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),kd(e,t,n)}});var Nd=ji({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return te(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),kd(e,t,n)}});var Td=ji({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return te(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),kd(e,t,n)}});var _d=ji({spaceToBatchND_:function(e,t,n){let r=Vi(e,"x","spaceToBatchND");te(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),te(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),te(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},i={blockShape:t,paddings:n};return Ri.runKernel(Mr,a,i)}});var Cd=ji({pool_:function(e,t,n,r,a,i,s){null==a&&(a=[1,1]),null==i&&(i=1),0===r&&(r="valid");let o=Vi(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),te(Xo(i,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${a}'`));let d,c=zo(l.shape,t,i,a,r),p=[c.dilationHeight,c.dilationWidth];d="same"===r?function(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}([c.filterHeight,c.filterWidth],p):[[0,0],[0,0]];let h=1===p[0]&&1===p[1],[f,m]=function(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),i=e.concat(r,a),s=t.map(((e,t)=>(e-i[t]%e)%e)),o=a.map(((e,t)=>e+s[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,s[t]]));return[l,u]}([c.inHeight,c.inWidth],p,d),g=h?r:"valid",y=h?l:_d(l,p,f),b=("avg"===n?()=>el(y,t,i,g,s):()=>ad(y,t,i,g,s))(),v=h?b:ll(b,p,m);return u?Zo(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});var Ed=ji({prelu_:function(e,t){let n={x:Vi(e,"x","prelu"),alpha:Vi(t,"alpha","prelu")};return Ri.runKernel(ar,n)}});var Ad=ji({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Vi(e,"x","prod");"bool"===r.dtype&&(r=bo(r,"int32"));let a={x:r},i={axis:t,keepDims:n};return Ri.runKernel(ir,a,i)}});var $d=ji({raggedGather_:function(e,t,n,r){let a={paramsNestedSplits:e.map(((e,t)=>Vi(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:Vi(t,"paramsDenseValues","raggedGather"),indices:Vi(n,"indices","raggedGather","int32")},i={outputRaggedRank:r},s=Ri.runKernel(sr,a,i);return{outputNestedSplits:s.slice(0,s.length-1),outputDenseValues:s[s.length-1]}}});var Rd=ji({raggedRange_:function(e,t,n){let r=Vi(e,"starts","raggedRange"),a={starts:r,limits:Vi(t,"limits","raggedRange",r.dtype),deltas:Vi(n,"deltas","raggedRange",r.dtype)},i=Ri.runKernel(or,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}});var Fd=ji({raggedTensorToTensor_:function(e,t,n,r,a){let i=Vi(e,"shape","raggedTensorToTensor","int32"),s=Vi(t,"values","raggedTensorToTensor"),o={shape:i,values:s,defaultValue:Vi(n,"defaultValue","raggedTensorToTensor",s.dtype),rowPartitionTensors:r.map(((e,t)=>Vi(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:a};return Ri.runKernel(lr,o,l)}});var Dd=ji({rand_:function(e,t,n){Pe(e);let r=ae(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let i=0;i<r;i++)a[i]=t();return Ri.makeTensor(a,e,n)}}),Md=k(D()),Od={};w(Od,{TEST_EPSILON_FLOAT16:()=>Ld,createVideoElement:()=>Xd,encodeStrings:()=>Kd,expectArrayBuffersEqual:()=>qd,expectArraysClose:()=>zd,expectArraysEqual:()=>Vd,expectNumbersClose:()=>Gd,expectPromiseToFail:()=>Ud,expectValuesInRange:()=>jd,play:()=>Yd,testEpsilon:()=>Bd});var Pd=.001,Ld=.1;function zd(e,t,n){return null==n&&(n=Bd()),Wd(e,t,((e,t)=>Hd(e,t,n)))}function Bd(){return 32===Ri.backend.floatPrecision()?Pd:Ld}function Wd(e,t,n){let r=!0;if((Xa(e)||Xa(t))&&(r=!1),Xa(e)&&Xa(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=Bi(e),r=Bi(t);if(!oe(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=Xa(e)?e:Ya(e),i=Xa(t)?t:Ya(t);if(a.length!==i.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${i.length}.\nActual:   ${a}.\nExpected: ${i}.`);for(let s=0;s<i.length;++s){let e=a[s],t=i[s];if(!n(e,t))throw new Error(`Arrays differ: actual[${s}] = ${e}, expected[${s}] = ${t}.\nActual:   ${a}.\nExpected: ${i}.`)}"undefined"!=typeof expect&&expect().nothing()}function Ud(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function Vd(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return Ie(e)||Ie(e[0])||Ie(t)||Ie(t[0])?Wd(e,n,((e,t)=>e==t)):Wd(e,t,((e,t)=>Hd(e,t,0)))}function Gd(e,t,n){if(null==n&&(n=Bd()),!Hd(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function Hd(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function jd(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function qd(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function Kd(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?Kd(n):e[t]=qa(n)}return e}function Xd(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function Yd(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}var Qd=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let i=a||Math.random();this.random=Md.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,i;do{r=2*this.random()-1,a=2*this.random()-1,i=r*r+a*a}while(i>=1||0===i);let s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*s,t=this.mean+this.stdDev*a*s,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},Jd=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=Md.alea(a.toString()),this.randn=new Qd(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,i;for(;;){do{r=this.randn.nextValue(),i=1+this.c*r}while(i<=0);if(i*=i*i,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-i+Math.log(i)),a=this.randu(),a<t||Math.log(a)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},Zd=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Md.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};var ec=ji({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;if(Pe(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let i=new Jd(t,n,r,a),s=yo(e,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});var tc=ji({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(Pe(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let i=new Qd(t,n,r,!1,a),s=yo(e,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});var nc=ji({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return tc(e,0,1,t,n)}});var rc=ji({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;Pe(e);let i=yo(e,r),s=new Zd(t,n,null,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var ac=ji({randomUniformInt_:function(e,t,n,r){return rc(e,t,n,"int32",r)}});function ic(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return Ri.runKernel(ur,{},a)}var sc=ji({real_:function(e){let t={input:Vi(e,"input","real")};return Ri.runKernel(dr,t)}});var oc=ji({reciprocal_:function(e){let t={x:Vi(e,"x","reciprocal")};return Ri.runKernel(cr,t)}});var lc=ji({relu_:function(e){let t={x:Vi(e,"x","relu")};return Ri.runKernel(pr,t)}});var uc=ji({relu6_:function(e){let t={x:Vi(e,"x","relu6")};return Ri.runKernel(br,t)}});var dc=ji({reverse_:function(e,t){let n={x:Vi(e,"x","reverse")},r={dims:t};return Ri.runKernel(vr,n,r)}});var cc=ji({reverse1d_:function(e){let t=Vi(e,"x","reverse");return te(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),dc(t,0)}});var pc=ji({reverse2d_:function(e,t){let n=Vi(e,"x","reverse");return te(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),dc(n,t)}});var hc=ji({reverse3d_:function(e,t){let n=Vi(e,"x","reverse");return te(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),dc(n,t)}});var fc=ji({reverse4d_:function(e,t){let n=Vi(e,"x","reverse");return te(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),dc(n,t)}});var mc=ji({round_:function(e){let t={x:Vi(e,"x","round")};return Ri.runKernel(xr,t)}});var gc=ji({rsqrt_:function(e){let t={x:Vi(e,"x","rsqrt","float32")};return Ri.runKernel(wr,t)}});var yc=ji({selu_:function(e){let t={x:Vi(e,"x","selu")};return Ri.runKernel(Tr,t)}});var bc=ji({separableConv2d_:function(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC",o=Vi(e,"x","separableConv2d"),l=Vi(t,"depthwiseFilter","separableConv2d"),u=Vi(n,"pointwiseFilter","separableConv2d"),d=o,c=!1;if(3===o.rank&&(c=!0,d=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");te(4===d.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`)),te(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),te(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),te(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),te(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let p=l.shape[2],h=l.shape[3];te(u.shape[2]===p*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${u.shape[2]}.`));let f=Ll(d,l,r,a,s,i),m=Nl(f,u,1,"valid",s);return c?Zo(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var vc=async function(e,t){let n=Vi(e,"x","setdiff1d"),r=Vi(t,"y","setdiff1d");te(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),te(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),te(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),i=await r.data(),s=new Set(i),o=0;for(let d=0;d<a.length;d++)s.has(a[d])||o++;let l=new ii([o],n.dtype),u=new ii([o],"int32");for(let d=0,c=0;d<a.length;d++)s.has(a[d])||(l.values[c]=a[d],u.values[c]=d,c++);return[l.toTensor(),u.toTensor()]};var xc=ji({sign_:function(e){let t={x:Vi(e,"x","sign")};return Ri.runKernel(Ar,t)}});var wc=ji({sin_:function(e){let t={x:Vi(e,"x","sin","float32")};return Ri.runKernel(Cr,t)}});var kc=ji({sinh_:function(e){let t={x:Vi(e,"x","sinh")};return Ri.runKernel(Er,t)}});var Sc=ji({slice1d_:function(e,t,n){let r=Vi(e,"x","slice1d");return te(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),il(r,[t],[n])}});var Ic=ji({slice2d_:function(e,t,n){let r=Vi(e,"x","slice2d");return te(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),il(r,t,n)}});var Nc=ji({slice3d_:function(e,t,n){let r=Vi(e,"x","slice3d");return te(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),il(r,t,n)}});var Tc=ji({slice4d_:function(e,t,n){let r=Vi(e,"x","slice4d");return te(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),il(r,t,n)}});var _c=ji({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=Vi(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return Ri.runKernel(Pr,r,a)}});var Cc=ji({fft_:function(e){te("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Ri.runKernel(tn,t)}});var Ec=ji({ifft_:function(e){te("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Ri.runKernel(hn,t)}});var Ac=ji({irfft_:function(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=Zo(e,[r,n]);t=Ec(a)}else{let a=[r,2*(n-1)],i=Zo(sc(e),[r,n]),s=Zo(_u(e),[r,n]),o=dc(il(i,[0,1],[r,n-2]),1),l=Io(dc(il(s,[0,1],[r,n-2]),1),cu(-1)),u=nl([i,o],1),d=nl([s,l],1),c=Zo(qi(u,d),[a[0],a[1]]);t=Ec(c)}if(t=sc(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=Zo(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}});var $c=ji({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r={x:Vi(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Ri.runKernel(Or,r,a)}});var Rc=ji({rfft_:function(e,t){te("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),i=e.shape.map((e=>e));i[e.shape.length-1]=t,n=il(e,a,i),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=nl([e,ud(a)],e.shape.length-1),r=t}else n=e;let i=ql(n),s=Zo(qi(n,i),[a,r]),o=Cc(s),l=Math.floor(r/2)+1,u=sc(o),d=_u(o),c=$c(u,[l,r-l],u.shape.length-1),p=$c(d,[l,r-l],d.shape.length-1),h=n.shape.slice();return h[n.shape.length-1]=l,Zo(qi(c[0],p[0]),h)}});var Fc=ji({squaredDifference_:function(e,t){let n=Vi(e,"a","squaredDifference"),r=Vi(t,"b","squaredDifference");[n,r]=Si(n,r),Gl(n.shape,r.shape);let a={a:n,b:r};return Ri.runKernel(Vr,a,{})}});var Dc=ji({squeeze_:function(e,t){let n=Vi(e,"x","squeeze","string_or_numeric");return Zo(n,ge(n.shape,t).newShape)}});var Mc=ji({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Gi(e,"tensors","stack","string_or_numeric");te(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&te(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return Ri.runKernel(er,r,a)}});var Oc=ji({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:Vi(e,"x","step")},r={alpha:t};return Ri.runKernel(la,n,r)}});var Pc=ji({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,u={x:Vi(e,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:r,beginMask:a,endMask:i,ellipsisMask:s,newAxisMask:o,shrinkAxisMask:l};return Ri.runKernel(jr,u,d)}});var Lc=ji({tan_:function(e){let t={x:Vi(e,"x","tan","float32")};return Ri.runKernel(Qr,t)}});function zc(e,t){re(e);let n=Bi(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ki(e,null,n,t)}function Bc(e,t,n){if(re(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=Bi(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ki(e,t,r,n)}function Wc(e,t,n){if(re(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=Bi(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ki(e,t,r,n)}function Uc(e,t,n){if(re(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=Bi(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ki(e,t,r,n)}function Vc(e,t,n){if(re(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=Bi(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ki(e,t,r,n)}function Gc(e,t,n){if(re(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=Bi(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Ki(e,t=t||r,r,n)}var Hc={};function jc(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(i+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(i+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(i+" update.rank != "+(a+e.length-r));for(let s=0;s<a;++s)if(n.shape[s]!==t.shape[s])throw new Error(i+` updates.shape[${s}] (${n.shape[s]}) != indices.shape[${s}] (${t.shape[s]}).`);for(let s=0;s<n.rank-a;++s)if(n.shape[s+a]!==e[s+r])throw new Error(i+` updates.shape[${s+a}] (${n.shape[s+a]}) != shape[${s+a}] (${e[s+a]})`)}function qc(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}jc(n,t,e)}function Kc(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,i=n.length,s=1;for(let l=a;l<i;++l)s*=n[l];let o=a<1?1:a;return{sliceRank:a,numUpdates:ae(t.shape)/o,sliceSize:s,strides:[...Ae(n.slice(0,a)),1],outputSize:ae(n)}}w(Hc,{calculateShapes:()=>Kc,validateInput:()=>qc,validateUpdateShape:()=>jc});var Xc=ji({tensorScatterUpdate_:function(e,t,n){let r=Vi(e,"tensor","tensorScatterupdate"),a=Vi(t,"indices","tensorScatterupdate","int32"),i=Vi(n,"updates","tensorScatterupdate");if(qc(i,a,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);let s={tensor:r,indices:a,updates:i};return Ri.runKernel(Sr,s,{})}});var Yc=ji({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=Vi(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let i={x:r},s={k:t,sorted:n},[o,l]=Ri.runKernel(ea,i,s);return{values:o,indices:l}}});var Qc=ji({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(Pe(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let i=new Qd(t,n,r,!0,a),s=yo(e,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});var Jc=ji({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Vi(e,"x","unique","string_or_numeric");te(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[i,s]=Ri.runKernel(ra,r,a);return{values:i,indices:s}}});var Zc=ji({unsortedSegmentSum_:function(e,t,n){let r=Vi(e,"x","unsortedSegmentSum"),a=Vi(t,"segmentIds","unsortedSegmentSum","int32");te(le(n),(()=>"numSegments must be of dtype int"));let i={x:r,segmentIds:a},s={numSegments:n};return Ri.runKernel(ia,i,s)}});var ep=ji({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Vi(e,"x","unstack","string_or_numeric");te(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return Ri.runKernel(aa,r,a)}});function tp(e,t){return nd(e,t,"right")}function np(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Ri.makeVariable(e,t,n,r)}function rp(e,t){let n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);let r=yo(e,"int32"),a=yo([n.length,e.length],"int32");for(let i=0;i<n.length;i++){let t=r.indexToLoc(n[i]),s=i*e.length;a.values.set(t,s)}return a.toTensor()}var ap=async function(e){let t=Vi(e,"condition","whereAsync","bool"),n=await t.data(),r=rp(t.shape,n);return e!==t&&t.dispose(),r};var ip=async function(e,t,n){let r=Vi(e,"tensor","boolMask"),a=Vi(t,"mask","boolMask","bool"),i=null==n?0:n,s=a.rank,o=r.shape;te(s>0,(()=>"mask cannot be scalar")),ne(o.slice(i,i+s),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+s;m++)l*=o[m];let u=o.slice(0,i).concat([l],o.slice(i+s)),d=Zo(r,u),c=Zo(a,[-1]),p=await ap(c),h=Dc(p,[1]),f=Iu(d,h,i);return e!==r&&r.dispose(),t!==a&&a.dispose(),h.dispose(),d.dispose(),c.dispose(),p.dispose(),f};var sp=ji({transpose_:function(e,t,n){let r=Vi(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),te(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{te(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},i={perm:t};return"complex64"===r.dtype?ss((()=>{let e=sc(r),t=_u(r);return e=Ri.runKernel(na,{x:e},i),t=Ri.runKernel(na,{x:t},i),n&&(t=Hu(t)),qi(e,t)})):Ri.runKernel(na,a,i)}});var op=ji({movingAverage_:function(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=Vi(e,"v","movingAverage"),s=Vi(t,"x","movingAverage"),o=Vi(n,"decay","movingAverage");Ii(i,s),te(oe(i.shape,s.shape),(()=>"Shape mismatch in v and x"));let l=cu(1),u=Ku(l,o),d=Io(Ku(s,i),u);if(a){te(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=Vi(r,"step","movingAverage");d=So(d,Ku(l,du(o,e)))}return wo(i,d)}});var lp=ji({scatterND_:function(e,t,n){Pe(n);let r=Vi(e,"indices","scatterND","int32"),a=Vi(t,"updates","scatterND");qc(a,r,n);let i={indices:r,updates:a},s={shape:n};return Ri.runKernel(kr,i,s)}});var up=ji({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;Pe(n);let a=Vi(e,"sparseIndices","sparseToDense","int32"),i=Vi(t,"sparseValues","sparseToDense","string_or_numeric"),s=Vi(r,"defaultValue","sparseToDense",i.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,i=e.rank>1?e.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);let s=t.size;if(0!==t.rank&&(1!==t.rank||s!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,i,n,s);let o={sparseIndices:a,sparseValues:i,defaultValue:s},l={outputShape:n};return Ri.runKernel(Ur,o,l)}});var dp=ji({gatherND_:function(e,t){let n=Vi(t,"indices","gatherND","int32"),r={params:Vi(e,"x","gatherND","string_or_numeric"),indices:n};return Ri.runKernel(un,r)}});var cp=ji({dropout_:function(e,t,n,r){let a=Vi(e,"x","dropout");if(te("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),te(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof li?a.clone():a;let i=function(e,t){if(null==t)return e.shape.slice();if(oe(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),s=1-t,o=So(Su(wo(rc(i,0,1,"float32",r),s)),s);return Io(a,o)}});function pp(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function hp(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let i=0;i<e;++i){let s=2*Math.PI*i/(e+r-1);a[i]=t-n*Math.cos(s)}return zc(a,"float32")}var fp=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=Vi(e,"predictions","inTopK"),a=Vi(t,"targets","inTopK");te(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),te(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),ne(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let i=r.shape[r.shape.length-1];te(n>0&&n<=i,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`));let s=await r.data(),o=await a.data(),[l,u]=[s.length/i,i],d=ye("bool",l);for(let c=0;c<l;c++){let e=c*u,t=s.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),d[c]=0;for(let a=0;a<n;a++)if(r[a].index===o[c]){d[c]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),Xi(d,a.shape,"bool")},mp={};w(mp,{conv2d:()=>wp,depthwiseConv2d:()=>Ip,matMul:()=>Np});var gp=ji({conv2DBackpropFilter_:function(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Zo(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]])),te(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),te(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),te(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===i?o.shape[3]:o.shape[1],d="NHWC"===i?l.shape[3]:l.shape[1];te(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),te(d===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${n[3]}).`)),Jo("conv2dDerFilter",a,s);let c={x:o,dy:l},p={strides:r,pad:a,dataFormat:i,dimRoundingMode:s,filterShape:n};return Ri.runKernel(Tt,c,p)}});function yp(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Io(e,Oc(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function bp(e,t){let n=t,r=Vl(e.shape,t.shape);return r.length>0&&(n=fu(n,r)),Zo(n,e.shape)}function vp(e,t,n,r){if("linear"===t)return e;if("relu"===t)return lc(e);if("elu"===t)return Ql(e);if("relu6"===t)return uc(e);if("prelu"===t)return Ed(e,n);if("leakyrelu"===t)return $u(e,r);if("sigmoid"===t)return al(e);throw new Error(`Unknown fused activation ${t}.`)}var xp=(e,t)=>!(e>0)||"linear"===t;var wp=ji({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}=e;if(u=u||"linear",!1===xp(Ri.state.gradientDepth,u)){te("NHWC"===i,(()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=Nl(t,n,r,a,i,s,o);return null!=l&&(e=wo(e,l)),vp(e,u,d,c)}let p=Vi(t,"x","conv2d","float32"),h=Vi(n,"filter","conv2d","float32"),f=p,m=!1;3===p.rank&&(m=!0,f=Zo(p,[1,p.shape[0],p.shape[1],p.shape[2]])),te(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),te(4===h.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`)),Jo("fused conv2d",a,o);let g="NHWC"===i?f.shape[3]:f.shape[1];te(h.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`)),te(Xo(r,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`));let y,b,v=Wo(f.shape,h.shape,r,s,a,o);if(null!=l&&(y=Vi(l,"bias","fused conv2d"),[y]=Si(y,p),"NHWC"===i?Gl(v.outShape,y.shape):(te(y.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)),te(0===y.shape.length||y.shape[0]===v.outChannels||1===y.shape[0],(()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${v.outChannels})`)))),null!=d){let e=d.shape;if(te(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)te(1===e[0]||e[0]===v.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${v.outChannels}).`));else if(3===e.length)try{Gl(e,v.outShape)}catch(S){let t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(t)}b=Vi(d,"prelu weights","fused conv2d")}let x=(e,t)=>{te("NHWC"===i,(()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`));let[n,o,l,d]=t,c=yp(e,l,u);te(Ko(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));let p=[_l(o.shape,c,n,r,a),gp(o,c,n.shape,r,a)];if(null!=d){let e=bp(d,c);p.push(e)}return p},w={x:f,filter:h,bias:y,preluActivationWeights:b},k={strides:r,pad:a,dataFormat:i,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return null==l?Vu(((e,t,n)=>{let r=Ri.runKernel(pa,w,k);return n([t,e,r]),m&&(r=Zo(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(f,h):Vu(((e,t,n,r)=>{let a=Ri.runKernel(pa,w,k);return r([t,e,a,n]),m&&(a=Zo(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(f,h,y)}});var kp=ji({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Zo(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},d={strides:r,pad:a,dimRoundingMode:s,dilations:i,filterShape:n};return Ri.runKernel(zt,u,d)}});var Sp=ji({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},d={strides:r,pad:a,dimRoundingMode:s,dilations:i,inputShape:e},c=Ri.runKernel(Bt,u,d);return l?Zo(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var Ip=ji({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}=e;if(!1===xp(Ri.state.gradientDepth,u)){let e=Ll(t,n,r,a,i,s,o);return null!=l&&(e=wo(e,l)),vp(e,u,d,c)}let p=Vi(t,"x","depthwiseConv2d","float32"),h=Vi(n,"filter","depthwiseConv2d","float32"),f=p,m=!1;3===p.rank&&(m=!0,f=Zo(p,[1,p.shape[0],p.shape[1],p.shape[2]])),te(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),te(4===h.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`)),te(f.shape[3]===h.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`)),null==s&&(s=[1,1]),te(Xo(r,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`)),Jo("fused depthwiseConv2d",a,o);let g,y,b=Wo(f.shape,h.shape,r,s,a,o,!0);null!=l&&(g=Vi(l,"bias","fused conv2d"),[g]=Si(g,p),Gl(b.outShape,g.shape)),null!=d&&(y=Vi(d,"prelu weights","fused depthwiseConv2d"));let v=(e,t)=>{te(Ko(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));let[n,i,l,d]=t,c=yp(e,l,u),p=Sp(i.shape,c,n,r,a,s,o),h=kp(i,c,n.shape,r,a,s,o);if(null!=d){return[p,h,bp(g,c)]}return[p,h]},x={x:f,filter:h,bias:g,preluActivationWeights:y},w={strides:r,pad:a,dataFormat:i,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return null==l?Vu(((e,t,n)=>{let r=Ri.runKernel(ha,x,w);return n([t,e,r]),m&&(r=Zo(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}))(f,h):Vu(((e,t,n,r)=>{let a=Ri.runKernel(ha,x,w);return r([t,e,a,n]),m&&(a=Zo(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}))(f,h,g)}});var Np=ji({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:i,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===xp(Ri.state.gradientDepth,s)){let e=rl(t,n,r,a);return null!=i&&(e=wo(e,i)),vp(e,s,o,l)}let u=Vi(t,"a","fused matMul"),d=Vi(n,"b","fused matMul");[u,d]=Si(u,d);let c=r?u.shape[u.rank-2]:u.shape[u.rank-1],p=a?d.shape[d.rank-1]:d.shape[d.rank-2],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=a?d.shape[d.rank-2]:d.shape[d.rank-1],m=u.shape.slice(0,-2),g=d.shape.slice(0,-2),y=ae(m),b=ae(g);te(c===p,(()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${d.shape} and transposeA=${r} and transposeB=${a} must match.`));let v,x,w=Gl(u.shape.slice(0,-2),d.shape.slice(0,-2)).concat([h,f]),k=Zo(u,r?[y,c,h]:[y,h,c]),S=Zo(d,a?[b,f,p]:[b,p,f]);null!=i&&(v=Vi(i,"bias","fused matMul"),[v]=Si(v,u),Gl(w,v.shape)),null!=o&&(x=Vi(o,"prelu weights","fused matMul"));let I=(e,t)=>{let n,o,[l,u,d,c]=t,p=yp(Zo(e,d.shape),d,s);if(r||a?!r&&a?(n=rl(p,u,!1,!1),o=rl(p,l,!0,!1)):r&&!a?(n=rl(u,p,!1,!0),o=rl(l,p,!1,!1)):(n=rl(u,p,!0,!0),o=rl(p,l,!0,!0)):(n=rl(p,u,!1,!0),o=rl(l,p,!0,!1)),null!=i){return[n,o,bp(c,p)]}return[n,o]},N={a:k,b:S,bias:v,preluActivationWeights:x},T={transposeA:r,transposeB:a,activation:s,leakyreluAlpha:l};return null==i?Vu(((e,t,n)=>{let r=Ri.runKernel(ca,N,T);return n([e,t,r]),{value:Zo(r,w),gradFunc:I}}))(k,S):Vu(((e,t,n,r)=>{let a=Ri.runKernel(ca,N,T);return r([e,t,a,n]),{value:Zo(a,w),gradFunc:I}}))(k,S,v)}});var Tp=ji({hammingWindow_:function(e){return hp(e,.54,.46)}});var _p=ji({hannWindow_:function(e){return hp(e,.5,.5)}});var Cp=ji({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=0,s=[];for(;i+t<=e.size;)s.push(il(e,i,t)),i+=n;if(r)for(;i<e.size;){let r=i+t-e.size,o=nl([il(e,i,t-r),vl([r],a)]);s.push(o),i+=n}return 0===s.length?Bc([],[0,t]):Zo(nl(s),[s.length,t])}});var Ep=ji({stft_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:_p;null==r&&(r=pp(t));let i=Cp(e,t,n),s=Io(i,a(t));return Rc(s,r)}});var Ap=ji({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=Vi(e,"image","cropAndResize"),o=Vi(t,"boxes","cropAndResize","float32"),l=Vi(n,"boxInd","cropAndResize","int32"),u=o.shape[0];te(4===s.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${s.rank}.`)),te(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),te(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),te(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),te(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),te("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let d={image:s,boxes:o,boxInd:l},c={method:a,extrapolationValue:i,cropSize:r};return Ri.runKernel(Mt,d,c)}});var $p=ji({flipLeftRight_:function(e){let t=Vi(e,"image","flipLeftRight","float32");te(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return Ri.runKernel(rn,n,{})}});var Rp=ji({grayscaleToRGB_:function(e){let t=Vi(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];te(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),te(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,wu(t,a)}});var Fp=ji({rgbToGrayscale_:function(e){let t=Vi(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];te(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),te(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));let a,i=t.dtype,s=bo(t,"float32"),o=zc([.2989,.587,.114]);switch(t.rank){case 2:a=Yl("ij,j->i",s,o);break;case 3:a=Yl("ijk,k->ij",s,o);break;case 4:a=Yl("ijkl,l->ijk",s,o);break;case 5:a=Yl("ijklm,m->ijkl",s,o);break;case 6:a=Yl("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return a=vu(a,-1),bo(a,i)}});var Dp=ji({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=Vi(e,"image","rotateWithOffset","float32");te(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let i={image:a},s={radians:t,fillValue:n,center:r};return Ri.runKernel(da,i,s)}});function Mp(e,t,n,r,a,i){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==i&&(i=0);let s=e.shape[0];return n=Math.min(n,s),te(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),te(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),te(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),te(1===t.rank,(()=>"scores must be a 1D tensor")),te(t.shape[0]===s,(()=>`scores has incompatible shape with boxes. Expected ${s}, but was ${t.shape[0]}`)),te(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:i}}var Op=ji({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=Vi(e,"boxes","nonMaxSuppression","float32"),s=Vi(t,"scores","nonMaxSuppression","float32"),o=Mp(i,s,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Ri.runKernel(Xn,{boxes:i,scores:s},l)}});function Pp(e,t,n){let r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,i=0,s=!1;for(;r<a;){i=r+(a-r>>>1);let o=n(t,e[i]);o>0?r=i+1:(a=i,s=!o)}return s?r:-r-1}(e,t,n||Lp)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Lp(e,t){return e>t?1:e<t?-1:0}function zp(e,t,n,r,a){return Up(e,t,n,r,a,0)}function Bp(e,t,n,r,a,i){return Up(e,t,n,r,a,0,!1,i,!0)}function Wp(e,t,n,r,a,i){return Up(e,t,n,r,a,i,!0)}function Up(e,t,n,r,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8],u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(Hp);let d=i>0?-.5/i:0,c=[],p=[];for(;c.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:s}=t;if(n<a)break;let o=!1;for(let l=c.length-1;l>=s;--l){let n=Vp(e,i,c[l]);if(n>=r){o=!0;break}if(t.score=t.score*Gp(r,d,n),t.score<=a)break}t.suppressBeginIndex=c.length,o||(t.score===n?(c.push(i),p.push(t.score)):t.score>a&&Pp(u,t,Hp))}let h=c.length,f=n-h;o&&f>0&&(c.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));let m={selectedIndices:c};return s&&(m.selectedScores=p),l&&(m.validOutputs=h),m}function Vp(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),i=Math.min(r[0],r[2]),s=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),d=Math.min(a[1],a[3]),c=Math.max(a[0],a[2]),p=Math.max(a[1],a[3]),h=(o-i)*(l-s),f=(c-u)*(p-d);if(h<=0||f<=0)return 0;let m=Math.max(i,u),g=Math.max(s,d),y=Math.min(o,c),b=Math.min(l,p),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(h+f-v)}function Gp(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function Hp(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var jp=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=Vi(e,"boxes","nonMaxSuppressionAsync"),s=Vi(t,"scores","nonMaxSuppressionAsync"),o=Mp(i,s,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([i.data(),s.data()]),u=l[0],d=l[1],{selectedIndices:c}=zp(u,d,n,r,a);return i!==e&&i.dispose(),s!==t&&s.dispose(),zc(c,"int32")};var qp=ji({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=Vi(e,"boxes","nonMaxSuppression"),o=Vi(t,"scores","nonMaxSuppression"),l=Mp(s,o,n,r,a,i);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,i=l.softNmsSigma;let u={boxes:s,scores:o},d={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:i},c=Ri.runKernel(Qn,u,d);return{selectedIndices:c[0],selectedScores:c[1]}}});var Kp=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=Vi(e,"boxes","nonMaxSuppressionAsync"),o=Vi(t,"scores","nonMaxSuppressionAsync"),l=Mp(s,o,n,r,a,i);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,i=l.softNmsSigma;let u=await Promise.all([s.data(),o.data()]),d=u[0],c=u[1],{selectedIndices:p,selectedScores:h}=Wp(d,c,n,r,a,i);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:zc(p,"int32"),selectedScores:zc(h)}};var Xp=ji({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=Vi(e,"boxes","nonMaxSuppression"),o=Vi(t,"scores","nonMaxSuppression"),l=Mp(s,o,n,r,a,null),u={boxes:s,scores:o},d={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i},c=Ri.runKernel(Yn,u,d);return{selectedIndices:c[0],validOutputs:c[1]}}});var Yp=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=Vi(e,"boxes","nonMaxSuppressionAsync"),o=Vi(t,"scores","nonMaxSuppressionAsync"),l=Mp(s,o,n,r,a,null),u=l.maxOutputSize,d=l.iouThreshold,c=l.scoreThreshold,[p,h]=await Promise.all([s.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Bp(p,h,u,d,c,i);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:zc(f,"int32"),validOutputs:cu(m,"int32")}};var Qp=ji({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Vi(e,"images","resizeBilinear");te(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),te(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),te(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let i=a,s=!1;3===a.rank&&(s=!0,i=Zo(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:i},l={alignCorners:n,halfPixelCenters:r,size:t},u=Ri.runKernel(gr,o,l);return s?Zo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var Jp=ji({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Vi(e,"images","resizeNearestNeighbor");te(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),te(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),te("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),te(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let i=a,s=!1;3===a.rank&&(s=!0,i=Zo(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:i},l={alignCorners:n,halfPixelCenters:r,size:t},u=Ri.runKernel(fr,o,l);return s?Zo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var Zp=ji({threshold_:function(e){let t,n,r,a,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,l=Vi(e,"image","threshold"),u=l.shape[0]*l.shape[1],d=Io(zc([o]),255);if(te(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),te(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),te("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),te("otsu"===i||"binary"===i,(()=>`Method must be binary or otsu, but was ${i}`)),3===l.shape[2]){[t,n,r]=$c(l,[1,1,1],-1);let e=Io(t,.2989),i=Io(n,.587),s=Io(r,.114);a=wo(wo(e,i),s)}else a=e;if("otsu"===i){d=function(e,t){let n,r,a,i,s,o,l=zc([-1]),u=zc([0]),d=zc([0]);for(let c=0;c<e.size-1;c++){n=il(e,0,c+1),r=il(e,c+1),s=So(fu(n),t),o=So(fu(r),t);let p=fu(Io(n,ic(0,n.size)));a=So(p,fu(n));let h=vl(r.shape,n.size),f=wo(ic(0,r.size),h),m=Io(r,f);i=So(fu(m),fu(r));let g=Ku(a,i),y=Ku(a,i),b=Io(s,o);d=Io(Io(b,g),y);let v=Nu(d,u);u=jl(v,d,u),l=jl(v,zc([c]),l)}return l}(fl(bo(mc(a),"int32"),Xi([]),256),u)}let c=s?Fu(a,d):Nu(a,d);return bo(Io(c,255),"int32")}});var eh=ji({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5?arguments[5]:void 0,s=Vi(e,"image","transform","float32"),o=Vi(t,"transforms","transform","float32");te(4===s.rank,(()=>`Error in transform: image must be rank 4,but got rank ${s.rank}.`)),te(2===o.rank&&(o.shape[0]===s.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),te(null==i||2===i.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`));let l={image:s,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:i};return Ri.runKernel(ta,l,u)}});var th=ji({bandPart_:function(e,t,n){let r=Vi(e,"a","bandPart");te(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a,i,s=r.shape,[o,l]=r.shape.slice(-2);"number"==typeof t?(te(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),te(t<=o,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`)),a=Vi(t<0?o:t,"numLower","bandPart")):(te("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=jl(Ru(t,0),o,pd(t,o))),"number"==typeof n?(te(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),te(n<=l,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`)),i=Vi(n<0?l:n,"numUpper","bandPart")):(te("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),i=jl(Ru(n,0),l,pd(n,l)));let u=Zo(ic(0,o,1,"int32"),[-1,1]),d=ic(0,l,1,"int32"),c=Ku(u,d),p=Qu(Fu(c,a),Tu(c,Hu(i))),h=ud([o,l],r.dtype);return Zo(Mc(ep(Zo(r,[-1,o,l])).map((e=>jl(p,e,h)))),s)}});var nh=ji({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,te(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)te(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=$c(e,e.shape[0],0).map((e=>Dc(e,[0])));te(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(Ri.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=Io(fu(Io(n[t],e)),n[t]);e=Ku(e,r)}return So(e,gu(e,"euclidean"))})));return t?Mc(n,0):n}});function rh(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Ri.tidy((()=>{te(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=ku(n),i=vo(e),s=Bc([[1]],[1,1]),o=vo(s),l=n>=r?r:n;for(let e=0;e<l;++e){let t=i,l=o,u=a;[o,i,a]=Ri.tidy((()=>{let t=il(i,[e,e],[n-e,1]),l=gu(t),u=il(i,[e,e],[1,1]),d=jl(Nu(u,0),Bc([[-1]]),Bc([[1]])),c=Ku(u,Io(d,l)),p=So(t,c);o=1===p.shape[0]?vo(s):nl([s,il(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);let h=Hu(So(rl(d,c),l)),f=il(i,[e,0],[n-e,r]),m=Io(h,o),g=sp(o);if(0===e)i=Ku(f,rl(m,rl(g,f)));else{let t=Ku(f,rl(m,rl(g,f)));i=nl([il(i,[0,0],[e,r]),t],0)}let y=sp(m),b=il(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=Ku(b,rl(rl(b,o),y));else{let t=Ku(b,rl(rl(b,o),y));a=nl([il(a,[0,0],[n,e]),t],1)}return[o,i,a]})),os([t,l,u])}return!t&&n>r&&(a=il(a,[0,0],[n,r]),i=il(i,[0,0],[r,r])),[a,i]}))}var ah,ih=ji({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(te(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return rh(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=ep(Zo(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],i=[];return r.forEach((e=>{let[n,r]=rh(e,t);a.push(n),i.push(r)})),[Zo(Mc(a,0),e.shape),Zo(Mc(i,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ah||(ah={}));var sh=ji({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ah.SUM_BY_NONZERO_WEIGHTS,r=Vi(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=Vi(t,"weights","computeWeightedLoss"));let i=null==a?r:Io(r,a);if(n===ah.NONE)return i;if(n===ah.SUM)return fu(i);if(n===ah.MEAN){if(null==a)return ld(i);{let e=r.size/a.size,t=So(fu(i),fu(a));return e>1?So(t,cu(e)):t}}if(n===ah.SUM_BY_NONZERO_WEIGHTS){if(null==a)return So(fu(i),cu(r.size));{let e=Io(a,dd(r.shape)),t=bo(fu(bd(e,cu(0))),"float32");return So(fu(i),t)}}throw Error(`Unknown reduction: ${n}`)}});var oh=ji({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ah.SUM_BY_NONZERO_WEIGHTS,a=Vi(e,"labels","absoluteDifference"),i=Vi(t,"predictions","absoluteDifference"),s=null;null!=n&&(s=Vi(n,"weights","absoluteDifference")),ne(a.shape,i.shape,"Error in absoluteDifference: ");let o=No(Ku(a,i));return sh(o,s,r)}});var lh=ji({cosineDistance_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ah.SUM_BY_NONZERO_WEIGHTS,i=Vi(e,"labels","cosineDistance"),s=Vi(t,"predictions","cosineDistance"),o=null;null!=r&&(o=Vi(r,"weights","cosineDistance")),ne(i.shape,s.shape,"Error in cosineDistance: ");let l=cu(1),u=Ku(l,fu(Io(i,s),n,!0));return sh(u,o,a)}});var uh=ji({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ah.SUM_BY_NONZERO_WEIGHTS,a=Vi(e,"labels","hingeLoss"),i=Vi(t,"predictions","hingeLoss"),s=null;null!=n&&(s=Vi(n,"weights","hingeLoss")),ne(a.shape,i.shape,"Error in hingeLoss: ");let o=cu(1);a=Ku(Io(cu(2),a),o);let l=lc(Ku(o,Io(a,i)));return sh(l,s,r)}});var dh=ji({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ah.SUM_BY_NONZERO_WEIGHTS,i=Vi(e,"labels","huberLoss"),s=Vi(t,"predictions","huberLoss"),o=null;null!=n&&(o=Vi(n,"weights","huberLoss")),ne(i.shape,s.shape,"Error in huberLoss: ");let l=cu(r),u=No(Ku(s,i)),d=pd(u,l),c=Ku(u,d),p=wo(Io(cu(.5),hu(d)),Io(l,c));return sh(p,o,a)}});var ch=ji({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ah.SUM_BY_NONZERO_WEIGHTS,i=Vi(e,"labels","logLoss"),s=Vi(t,"predictions","logLoss"),o=null;null!=n&&(o=Vi(n,"weights","logLoss")),ne(i.shape,s.shape,"Error in logLoss: ");let l=cu(1),u=cu(r),d=Hu(Io(i,Ou(wo(s,u)))),c=Io(Ku(l,i),Ou(wo(Ku(l,s),u))),p=Ku(d,c);return sh(p,o,a)}});var ph=ji({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ah.SUM_BY_NONZERO_WEIGHTS,a=Vi(e,"labels","meanSquaredError"),i=Vi(t,"predictions","meanSquaredError"),s=null;null!=n&&(s=Vi(n,"weights","meanSquaredError")),ne(a.shape,i.shape,"Error in meanSquaredError: ");let o=Fc(a,i);return sh(o,s,r)}});var hh=ji({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ah.SUM_BY_NONZERO_WEIGHTS,i=Vi(e,"multiClassLabels","sigmoidCrossEntropy"),s=Vi(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=Vi(n,"weights","sigmoidCrossEntropy")),ne(i.shape,s.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=cu(r),t=cu(1),n=cu(.5);i=wo(Io(i,Ku(t,e)),Io(n,e))}let l=function(e,t){let n=Vi(e,"labels","sigmoidCrossEntropyWithLogits"),r=Vi(t,"logits","sigmoidCrossEntropyWithLogits");ne(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=lc(r),i=Io(r,n),s=Pu(bu(Hu(No(r))));return wo(Ku(a,i),s)}(i,s);return sh(l,o,a)}});var fh=ji({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ah.SUM_BY_NONZERO_WEIGHTS,i=Vi(e,"onehotLabels","softmaxCrossEntropy"),s=Vi(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=Vi(n,"weights","softmaxCrossEntropy")),ne(i.shape,s.shape,"Error in softmaxCrossEntropy: "),r>0){let e=cu(r),t=cu(1),n=cu(i.shape[1]);i=wo(Io(i,Ku(t,e)),So(e,n))}let l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Vu(((e,t,r)=>{let a=Yu(t,[n],!0),i=Ku(bo(t,"float32"),a);r([e,i]);let s=Hu(Io(i,e));return{value:fu(s,[n]),gradFunc:(e,t)=>{let[r,a]=t,i=ru(e.shape,[n]);return[Io(Zo(e,i),Ku(bo(r,"float32"),bu(a))),Io(Zo(e,i),Ku(bu(a),bo(r,"float32")))]}}}))(e,t)}(i,s);return sh(l,o,a)}});var mh=ji({sparseFillEmptyRows_:function(e,t,n,r){let a=Vi(e,"indices","sparseFillEmptyRows","int32"),i=Vi(t,"values","sparseFillEmptyRows"),s=Vi(n,"denseShape","sparseFillEmptyRows","int32"),o=Vi(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==s.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${s.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:i,denseShape:s,defaultValue:o},u=Ri.runKernel(Lr,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});var gh=ji({sparseReshape_:function(e,t,n){let r=Vi(e,"inputIndices","sparseReshape","int32"),a=Vi(t,"inputShape","sparseReshape","int32"),i=Vi(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);let s={inputIndices:r,inputShape:a,newShape:i},o=Ri.runKernel(zr,s);return{outputIndices:o[0],outputShape:o[1]}}});var yh=ji({sparseSegmentMean_:function(e,t,n){let r=Vi(e,"data","sparseSegmentMean"),a=Vi(t,"indices","sparseSegmentMean","int32"),i=Vi(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);let s={data:r,indices:a,segmentIds:i};return Ri.runKernel(Br,s)}});var bh=ji({sparseSegmentSum_:function(e,t,n){let r=Vi(e,"data","sparseSegmentSum"),a=Vi(t,"indices","sparseSegmentSum","int32"),i=Vi(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);let s={data:r,indices:a,segmentIds:i};return Ri.runKernel(Wr,s)}});var vh=ji({stringNGrams_:function(e,t,n,r,a,i,s,o){let l=Vi(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=Vi(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let d={separator:n,nGramWidths:r,leftPad:a,rightPad:i,padWidth:s,preserveShortSequences:o},c={data:l,dataSplits:u},p=Ri.runKernel(qr,c,d);return{nGrams:p[0],nGramsSplits:p[1]}}});var xh=ji({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=Vi(e,"input","stringSplit","string"),a=Vi(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let i={skipEmpty:n},s={input:r,delimiter:a},o=Ri.runKernel(Kr,s,i);return{indices:o[0],values:o[1],shape:o[2]}}});var wh=ji({stringToHashBucketFast_:function(e,t){let n=Vi(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return Ri.runKernel(Xr,a,r)}});var kh=ji({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=Vi(e,"input","staticRegexReplace","string"),i={pattern:t,rewrite:n,replaceGlobal:r};return Ri.runKernel(Hr,{x:a},i)}}),Sh={fft:Cc,ifft:Ec,rfft:Rc,irfft:Ac},Ih={hammingWindow:Tp,hannWindow:_p,frame:Cp,stft:Ep},Nh={flipLeftRight:$p,grayscaleToRGB:Rp,resizeNearestNeighbor:Jp,resizeBilinear:Qp,rgbToGrayscale:Fp,rotateWithOffset:Dp,cropAndResize:Ap,nonMaxSuppression:Op,nonMaxSuppressionAsync:jp,nonMaxSuppressionWithScore:qp,nonMaxSuppressionWithScoreAsync:Kp,nonMaxSuppressionPadded:Xp,nonMaxSuppressionPaddedAsync:Yp,threshold:Zp,transform:eh},Th={bandPart:th,gramSchmidt:nh,qr:ih},_h={absoluteDifference:oh,computeWeightedLoss:sh,cosineDistance:lh,hingeLoss:uh,huberLoss:dh,logLoss:ch,meanSquaredError:ph,sigmoidCrossEntropy:hh,softmaxCrossEntropy:fh},Ch={sparseFillEmptyRows:mh,sparseReshape:gh,sparseSegmentMean:yh,sparseSegmentSum:bh},Eh={stringNGrams:vh,stringSplit:xh,stringToHashBucketFast:wh,staticRegexReplace:kh},Ah={};w(Ah,{Serializable:()=>Fh,SerializationMap:()=>Dh,getRegisteredName:()=>Oh,registerClass:()=>Mh});var $h=new Map,Rh=new Map,Fh=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Dh=class e{constructor(){this.classNameMap={}}static getMap(){return null==e.instance&&(e.instance=new e),e.instance}static register(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Mh(e,t,n){te(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),te("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),te(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"==typeof t&&(t="Custom"),"undefined"==typeof n&&(n=e.className);let r=t+">"+n;return Dh.register(e),$h.set(r,e),Rh.set(e,r),e}function Oh(e){return Rh.has(e)?Rh.get(e):e.className}var Ph=class extends Fh{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0,{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return os(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Uu(e,t)}dispose(){null!=this.iterations_&&os(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:cu(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Ph,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var Lh=class extends Ph{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Ri.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Ri.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ss((()=>ql(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ss((()=>ql(r).variable(a)))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ss((()=>{let e=wo(Io(s,this.rho),Io(hu(i),1-this.rho)),t=Io(So(pu(wo(o,this.epsilon)),pu(wo(s,this.epsilon))),i),n=wo(Io(o,this.rho),Io(hu(t),1-this.rho));s.assign(e),o.assign(n);let a=wo(Io(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(os(this.accumulatedGrads.map((e=>e.variable))),os(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},zh=class extends Ph{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Ri.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ss((()=>vl(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let i=this.accumulatedGrads[n].variable;ss((()=>{let e=wo(i,hu(a));i.assign(e);let t=wo(Io(So(a,pu(wo(e,Ri.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&os(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},Bh=class extends Ph{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ss((()=>{this.accBeta1=cu(t).variable(),this.accBeta2=cu(n).variable()})),null==r&&(this.epsilon=Ri.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);ss((()=>{let n=Ku(1,this.accBeta1),r=Ku(1,this.accBeta2);t.forEach(((t,a)=>{let i=Ri.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:ss((()=>ql(i).variable(s)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:ss((()=>ql(i).variable(s)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,d=wo(Io(l,this.beta1),Io(o,1-this.beta1)),c=wo(Io(u,this.beta2),Io(hu(o),1-this.beta2)),p=So(d,n),h=So(c,r);l.assign(d),u.assign(c);let f=wo(Io(So(p,wo(pu(h),this.epsilon)),-this.learningRate),i);i.assign(f)})),this.accBeta1.assign(Io(this.accBeta1,this.beta1)),this.accBeta2.assign(Io(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&os(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&os(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),ss((()=>{this.accBeta1.assign(du(this.beta1,this.iterations_+1)),this.accBeta2.assign(du(this.beta2,this.iterations_+1))}));let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Wh=class extends Ph{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ss((()=>{this.iteration=cu(0).variable(),this.accBeta1=cu(t).variable()})),null==r&&(this.epsilon=Ri.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);ss((()=>{let n=Ku(1,this.accBeta1),r=So(-this.learningRate,wo(Io(this.iteration,this.decay),1));t.forEach(((t,a)=>{let i=Ri.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:ql(i).variable(s)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:ql(i).variable(s)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,d=wo(Io(l,this.beta1),Io(o,1-this.beta1)),c=Io(u,this.beta2),p=No(o),h=od(c,p);l.assign(d),u.assign(h);let f=wo(Io(So(r,n),So(d,wo(h,this.epsilon))),i);i.assign(f)})),this.iteration.assign(wo(this.iteration,1)),this.accBeta1.assign(Io(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&os(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&os(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Uh=class extends Ph{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=Ri.registeredVariables[t];ss((()=>{let e=wo(Io(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ls(cu(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},Vh=class extends Uh{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=cu(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Ri.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ss((()=>ql(r).variable(!1)))});let a=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[t];null!=i&&ss((()=>{let e,t=wo(Io(this.m,a),i);e=this.useNesterov?wo(Io(this.c,wo(i,Io(t,this.m))),r):wo(Io(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&os(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},Gh=class extends Ph{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Ri.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Ri.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ss((()=>ql(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ss((()=>ql(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ss((()=>ql(r).variable(a)))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let s=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ss((()=>{let e=wo(Io(s,this.decay),Io(hu(i),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=wo(Io(t,this.decay),Io(i,1-this.decay)),l=So(Io(i,this.learningRate),pu(Ku(e,wo(hu(a),this.epsilon)))),u=wo(Io(o,this.momentum),l);s.assign(e),t.assign(a),o.assign(u);let d=Ku(r,u);r.assign(d)}else{let e=wo(Io(s,this.decay),Io(hu(i),1-this.decay)),t=wo(Io(o,this.momentum),So(Io(i,this.learningRate),pu(wo(e,this.epsilon))));s.assign(e),o.assign(t);let n=Ku(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&os(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&os(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&os(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Hh=[Lh,zh,Bh,Wh,Vh,Gh,Uh];var jh={};w(jh,{CompositeArrayBuffer:()=>Qi,browserFiles:()=>Yh,browserHTTPRequest:()=>sf,concatenateArrayBuffers:()=>Es,copyModel:()=>ho,decodeWeights:()=>xs,decodeWeightsStream:()=>Ns,encodeWeights:()=>vs,fromMemory:()=>df,fromMemorySync:()=>cf,getLoadHandlers:()=>Bs,getModelArtifactsForJSON:()=>Fs,getModelArtifactsForJSONSync:()=>Rs,getModelArtifactsInfoForJSON:()=>Ds,getSaveHandlers:()=>zs,getWeightSpecs:()=>Ms,http:()=>af,isHTTPScheme:()=>nf,listModels:()=>co,loadWeights:()=>Zh,moveModel:()=>fo,registerLoadRouter:()=>Ls,registerSaveRouter:()=>Ps,removeModel:()=>po,weightsLoaderFactory:()=>ef,withSaveHandler:()=>pf,withSaveHandlerSync:()=>hf});function qh(e){return new Promise((e=>setTimeout(e))).then(e)}var Kh=class e{constructor(t){if(!Ge().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(null==t||0===t.length)&&(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=Qi.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=$s(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await qh((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await qh((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Ds(e)}}}};Kh.URL_SCHEME="downloads://";var Xh=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let i=Fs(r,(e=>this.loadWeights(e)));e(i)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let i of e)t.push(...i.weights),n.push(...i.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>As(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=As(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};function Yh(e){return new Xh(e)}function Qh(e,t,n,r){var a;te(null!=(a=e)&&Array.isArray(a)&&a.length>0,(()=>"promises must be a none empty array")),function(e,t){te(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),te(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),te(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let i=0;return Promise.all(e.map((a=>(a.then((a=>{let s=n+ ++i/e.length*(r-n);return t(s),a})),a))))}async function Jh(e,t){null==t&&(t={});let n=null==t.fetchFunc?Ge().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await Qh(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await Qh(a,t.onProgress,.5,1)}async function Zh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return ef((e=>Jh(e,{requestInit:r})))(e,t,n)}function ef(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0,a=t.map((()=>!1)),i={},s=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=Yi[l]*ae(e.shape),d=()=>{a[t]=!0,null==i[t]&&(i[t]=[]),i[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(d(),s[n]=!0)})):d(),o.push(e.name),n+=u}))})),!s.every((e=>e))){let e=r.filter(((e,t)=>!s[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let d=await e(u),c={},p=0;return l.forEach((e=>{let n=t[e].paths.length,r=new Qi(d.slice(p,p+n));i[e].forEach((e=>{let t=xs(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let n in t)c[n]=t[n]})),p+=n})),c}}Os.registerSaveRouter((e=>Ge().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Kh.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Kh(e)}(e.slice(Kh.URL_SCHEME.length)):null));var tf=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(te("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Ge().platform.fetch,te(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&te(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=$s(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=Qi.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Ds(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(TJ){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return Fs(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Ms(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;let r,a=null==t.fetchFunc?Ge().platform.fetch:t.fetchFunc,i=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var s;i<e.length;){r||(r=(await a(e[i],t.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await r.read();if(!o)return void n.enqueue(l);i++,r=void 0,null===(s=t.onProgress)||void 0===s||s.call(t,i/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,i=[],s=[];for(let o of e)for(let e of o.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):i.push(a+e+r);return this.weightUrlConverter&&i.push(...await Promise.all(s)),i}async loadWeights(e){let t=await this.getWeightUrls(e);return[Ms(e),await Jh(t,this.loadOptions)]}};function nf(e){return null!=e.match(tf.URL_SCHEME_REGEX)}tf.URL_SCHEME_REGEX=/^https?:\/\//;var rf=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>nf(e))):nf(e),n)return af(e,t)}return null};function af(e,t){return new tf(e,t)}function sf(e,t){return af(e,t)}Os.registerSaveRouter(rf),Os.registerLoadRouter(rf);var of=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},lf=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},uf=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function df(e,t,n,r){return new uf(cf(...arguments))}function cf(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new of(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new of({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new of({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function pf(e){return new lf(e)}function hf(e){return new lf(e)}var ff={};w(ff,{confusionMatrix:()=>mf});var mf=ji({confusionMatrix_:function(e,t,n){let r=Vi(e,"labels","confusionMatrix"),a=Vi(t,"predictions","confusionMatrix");te(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),te(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),te(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),te(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),te(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let i=vd(bo(r,"int32"),n),s=vd(bo(a,"int32"),n),o=sp(i),l=rl(o,s);return bo(l,"int32")}}),gf={};w(gf,{draw:()=>If,fromPixels:()=>Nf,fromPixelsAsync:()=>wf,toPixels:()=>Sf});var yf,bf=!1;function vf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,i=!1,s=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)i=!0;else if(null!=e.getContext)s=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=ba(ua,Ri.backendName)){let n={pixels:e},r={numChannels:t};return Ri.runKernel(ua,n,r)}let l,u,[d,c]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(s)l=e.getContext("2d").getImageData(0,0,d,c).data;else if(r||n)l=e.data;else if(i||a||o){if(null==yf)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");yf=new OffscreenCanvas(1,1).getContext("2d")}else yf=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});yf.canvas.width=d,yf.canvas.height=c,yf.drawImage(e,0,0,d,c),l=yf.getImageData(0,0,d,c).data}if(4===t)u=new Int32Array(l);else{let e=d*c;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return Wc(u,[c,d,t],"int32")}function xf(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function wf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(Ge().getBool("WRAP_TO_IMAGEBITMAP")&&xf(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(TJ){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return vf(n,t)}function kf(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function Sf(e,t){let n=Vi(e,"img","toPixels");if(!(e instanceof li)){let e=n;n=bo(e,"int32"),e.dispose()}kf(n);let[r,a]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2],s=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<i;r++){let t=s[u*i+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===i?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){bf||null!=ba(Ht,Ri.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),bf=!0),t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function If(e,t,n){let r=Vi(e,"img","draw");if(!(e instanceof li)){let e=r;r=bo(e,"int32"),e.dispose()}kf(r),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);let a={image:r},i={canvas:t,options:n};Ri.runKernel(Ht,a,i)}var Nf=ji({fromPixels_:vf}),Tf={};function _f(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===ae(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,i=a[a.length-1],s=1;for(let c=0;c<a.length-1;++c)s*=a[c];let o=e.shape,l=a.slice();l.pop();let u=1;for(let c=i;c<n;++c)u*=o[c],l.push(o[c]);let d=[...Ae(e.shape).map((e=>e/u)),1].slice(0,i);return[l,s,u,d]}w(Tf,{prepareAndValidate:()=>_f});var Cf={};w(Cf,{assertParamsValid:()=>$f,computeFlatOffset:()=>Gf,computeOutShape:()=>Ff,getNormalizedAxes:()=>Pf,isSliceContinous:()=>Vf,maskToAxes:()=>Rf,parseSliceParams:()=>Hf,sliceInfo:()=>jf,startForAxis:()=>Wf,startIndicesWithElidedDims:()=>Lf,stopForAxis:()=>Uf,stopIndicesWithElidedDims:()=>zf,stridesForAxis:()=>Bf,stridesWithElidedDims:()=>Df});var Ef=-2,Af=-1;function $f(e,t,n){let r=e.shape.length;te(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),te(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)te(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function Rf(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Ff(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function Df(e,t,n,r){let a=[...e];for(let i=a.length;i<r.length;i++)a.push(1);for(let i=0;i<n;i++)0===i?a[t]=1:(a.splice(t,0,1),a.pop());return a}function Mf(e,t,n){return n<=e?n:n-(t-1)}function Of(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Pf(e,t,n,r,a,i,s,o,l){let u=e.length,d=new Array(u),c=new Array(u),p=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;d=Lf(s,l,u,r,e),c=zf(o,l,u,a,e),p=Df(i,l,u,e)}else for(let h=0;h<u;h++)d[h]=Wf(s,r,i,e,h,l),c[h]=Uf(o,a,i,e,h,l),p[h]=Bf(i,h,l);return{begin:d,end:c,strides:p}}function Lf(e,t,n,r,a){let i=[...a],s=Of(n,t);for(let o=0;o<i.length;o++)if(s.indexOf(o)>-1)i[o]=0;else{let a=Mf(t,n,o),s=r[a];e&1<<a&&(s=0),i[o]=s}return i}function zf(e,t,n,r,a){let i=[...a],s=Of(n,t);for(let o=0;o<i.length;o++)if(s.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{let a=Mf(t,n,o),s=r[a];e&1<<a&&(s=Number.MAX_SAFE_INTEGER),i[o]=s}for(let o=0;o<i.length;o++){let e=a[o];i[o]<0&&(i[o]+=e),i[o]=X(0,i[o],a[o])}return i}function Bf(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Wf(e,t,n,r,a,i){let s=t[a],o=n[a]||1;(e&1<<a||i&1<<a||null==s)&&(s=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return s<0&&(s+=l),s=X(0,s,l-1),s}function Uf(e,t,n,r,a,i){let s=t[a],o=n[a]||1;(e&1<<a||i&1<<a||null==s)&&(s=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return s<0&&(s+=l),s=o>0?X(0,s,l):X(-1,s,l-1),s}function Vf(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function Gf(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Hf(e,t,n){let r,a,i=e.shape.length;return r="number"==typeof t?[t,...new Array(i-1).fill(0)]:t.length<i?t.concat(new Array(i-t.length).fill(0)):t.slice(),r.forEach((e=>{te(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(i).fill(-1):"number"==typeof n?[n,...new Array(i-1).fill(-1)]:n.length<i?n.concat(new Array(i-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(te(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function jf(e,t,n,r,a,i,s,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=s&&s&s-1)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1,c={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:i,ellipsisMask:s,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<c.dims;b++)d&&1<<b&o&&c.numAddAxisAfterEllipsis++,1<<b&s&&(d=!0);d||(c.ellipsisMask|=1<<c.dims,c.dims++);let p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Ef),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Af),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(c,p);let h=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(0===p.strides[b])throw Error(`strides[${b}] must be non-zero`);let t=!!(p.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}let r=[p.beginMask&1<<b,p.endMask&1<<b],a=[p.strides[b]>0?0:-1,p.strides[b]>0?n:n-1];if(t&&p.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===p.strides[b];let i=!!(p.beginMask&1<<b&&p.endMask&1<<b);if(p.beginValid&&p.endValid){if(t){let e=p.begin[b]<0?n+p.begin[b]:p.begin[b];if(p.begin[b]=e,p.end[b]=p.begin[b]+1,e<0||e>=n)throw Error(`slice index ${p.begin[b]} of dimension ${b} out of bounds.`)}else p.begin[b]=qf(p.begin[b],0,p.strides[b],n,r,a),p.end[b]=qf(p.end[b],1,p.strides[b],n,r,a);let e=1===p.strides[b]&&0===p.begin[b]&&p.end[b]===n;h=h&&e,f=f&&(0===b&&1===p.strides[b]||e)}else h=h&&1===p.strides[b]&&i,f=f&&(0===b&&1===p.strides[b]||i);let s,o=!1;if(p.beginValid&&p.endValid?(s=p.end[b]-p.begin[b],o=!0):t?(s=1,o=!0):i&&n>=0&&(s=p.strides[b]<0?-n:n,o=!0),o){let e;e=0===s||s<0!=p.strides[b]<0?0:Math.trunc(s/p.strides[b])+(s%p.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<p.finalShapeGatherIndices.length;++b){let e=p.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===Ef&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>p.finalShapeGatherIndices[t]!==Ef)),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:p.begin,end:p.end,strides:p.strides}}function qf(e,t,n,r,a,i){if(a[t])return n>0?i[t]:i[t+1&1];{let t=e<0?r+e:e;return t<i[0]?i[0]:t>i[1]?i[1]:t}}var Kf="4.21.0",Xf=class{static sgd(e){return new Uh(e)}static momentum(e,t){return new Vh(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Gh(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Bh(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Lh(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Wh(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new zh(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},Yf=Xf,Qf="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Jf(){return new Promise((e=>Qf((()=>e()))))}var Zf,em={};function tm(e,t){let n=e[0].length;e.forEach(((e,t)=>{te(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),te(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let i=0;i<n;i++)te(i===t||e[i]===r[i],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function nm(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function rm(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let i=n[a],s=r[r.length-n.length+a],o=r[s];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${i} but shape[${a+e}] = ${o}`)}else r[s]=i}return r}function am(e){let t={FIRST_DIM_SIZE:Zf.FIRST_DIM_SIZE,VALUE_ROWIDS:Zf.VALUE_ROWIDS,ROW_LENGTHS:Zf.ROW_LENGTHS,ROW_SPLITS:Zf.ROW_SPLITS,ROW_LIMITS:Zf.ROW_LIMITS,ROW_STARTS:Zf.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function im(e){return 0===e.length?0:e[0]===Zf.FIRST_DIM_SIZE?e.length-1:e.length}function sm(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}w(em,{ERF_A1:()=>bm,ERF_A2:()=>vm,ERF_A3:()=>xm,ERF_A4:()=>wm,ERF_A5:()=>km,ERF_P:()=>ym,PARALLELIZE_THRESHOLD:()=>om,RowPartitionType:()=>Zf,SELU_SCALE:()=>gm,SELU_SCALEALPHA:()=>mm,applyActivation:()=>vp,assertAndGetBroadcastShape:()=>Gl,assertAxesAreInnerMostDims:()=>au,assertParamsConsistent:()=>tm,assignToTypedArray:()=>Cm,axesAreInnerMostDims:()=>eu,calculateShapes:()=>Kc,checkEinsumDimSizes:()=>Pm,checkPadOnDimRoundingMode:()=>Jo,combineLocations:()=>tu,combineRaggedTensorToTensorShapes:()=>rm,complexWithEvenIndex:()=>Nm,complexWithOddIndex:()=>Tm,computeConv2DInfo:()=>Wo,computeConv3DInfo:()=>Uo,computeDefaultPad:()=>Vo,computeDilation2DInfo:()=>Lo,computeOptimalWindowSize:()=>lm,computeOutAndReduceShapes:()=>nu,computeOutShape:()=>nm,computePool2DInfo:()=>zo,computePool3DInfo:()=>Bo,convertConv2DDataFormat:()=>Qo,decodeEinsumEquation:()=>Mm,eitherStridesOrDilationsAreOne:()=>Xo,expandShapeToKeepDim:()=>ru,exponent:()=>Am,exponents:()=>Em,fromStringArrayToUint8:()=>ig,fromUint8ToStringArray:()=>ag,getAxesPermutation:()=>iu,getBroadcastDims:()=>Ul,getComplexWithIndex:()=>_m,getEinsumComputePath:()=>Lm,getEinsumPermutation:()=>Om,getFusedBiasGradient:()=>bp,getFusedDyActivation:()=>yp,getImageCenter:()=>um,getInnerMostAxes:()=>ou,getPermuted:()=>cm,getRaggedRank:()=>im,getReductionAxes:()=>Vl,getReshaped:()=>dm,getReshapedPermuted:()=>pm,getRowPartitionTypesHelper:()=>am,getSliceBeginCoords:()=>hm,getSliceSize:()=>fm,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Um,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Vm,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Gm,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>qm,getSparseReshapeInputOutputMismatchErrorMessage:()=>Xm,getSparseReshapeInputOutputMultipleErrorMessage:()=>Km,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Hm,getSparseReshapeNegativeOutputDimErrorMessage:()=>jm,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Zm,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Ym,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Qm,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Jm,getUndoAxesPermutation:()=>su,isIdentityPermutation:()=>zm,log:()=>ma,mergeRealAndImagArrays:()=>Sm,prepareAndValidate:()=>_f,prepareSplitSize:()=>Wm,segment_util:()=>eg,shouldFuse:()=>xp,slice_util:()=>Cf,splitRealAndImagArrays:()=>Im,stridesOrDilationsArePositive:()=>Yo,tupleValuesAreOne:()=>Ko,upcastType:()=>vi,validateDefaultValueShape:()=>sm,validateInput:()=>qc,validateUpdateShape:()=>jc,warn:()=>fa}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Zf||(Zf={}));var om=30;function lm(e){return e<=om?e:Ee(e,Math.floor(Math.sqrt(e)))}function um(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function dm(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function cm(e,t){let n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{let r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function pm(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let i=1;i<e.length;++i)i<=t.length?r?a.push(t[i-1]*e[i]):a.push(e[i]/t[i-1]):a.push(e[i]);return a}function hm(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function fm(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var mm=1.7580993408473768,gm=1.0507009873554805,ym=.3275911,bm=.254829592,vm=-.284496736,xm=1.421413741,wm=-1.453152027,km=1.061405429;function Sm(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Im(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Nm(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Tm(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function _m(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Cm(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Em(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let i=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(i),r[a]=Math.sin(i)}return{real:n,imag:r}}function Am(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var $m="->",Rm=/->/g,Fm=",",Dm="...";function Mm(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(Rm,"").length)/$m.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${$m}").`);let[r,a]=e.split($m);te(-1===r.indexOf(Dm),(()=>`The ellipsis notation ("${Dm}") is not supported yet.`));let i=r.split(Fm),s=i.length;if(t!==s)throw new Error(`Expected ${s} input tensors, received ${t}`);if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let c=0;c<a.length;++c){let e=a[c];if(!i.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let c=0;c<r.length;++c){let e=r[c];-1===o.indexOf(e)&&e!==Fm&&o.push(e)}let l=new Array(i.length);for(let c=0;c<s;++c){if(new Set(i[c].split("")).size!==i[c].length)throw new Error(`Found duplicate axes in input component ${i[c]}. Support for duplicate axes in input is not implemented yet.`);l[c]=[];for(let e=0;e<i[c].length;++e)l[c].push(o.indexOf(i[c][e]))}let u=o.length,d=[];for(let c=a.length;c<u;++c)d.push(c);return{allDims:o,summedDims:d,idDims:l}}function Om(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Pm(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:te(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Lm(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let s=0;s<a;++s)r.push([]);let i=[];for(let s=0;s<n.length;++s){let e=Bm(t,n[s]);for(let t of e)-1===i.indexOf(t)&&(r[s].push(t),i.push(t))}return{path:n,steps:r}}function zm(e){return e.every(((e,t)=>e===t))}function Bm(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function Wm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"==typeof t)te(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{te(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));let a=t.indexOf(-1);if(-1!==a){let r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}te(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Um(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Vm(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Gm(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Hm(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function jm(e,t){return`size ${e} must be non-negative, not ${t}`}function qm(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Km(e,t){return`Input to reshape is a SparseTensor with ${ae(e)}\n  dense values, but the requested shape requires a multiple of ${ae(t)}. inputShape=${e} outputShape= ${t}`}function Xm(e,t){return`Input to reshape is a tensor with ${ae(e)} dense values, but the requested shape has ${ae(t)}. inputShape=${e} outputShape=${t}`}function Ym(){return"segment ids must be >= 0"}function Qm(){return"segment ids are not increasing"}function Jm(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Zm(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var eg={};function tg(e,t){let n,r=!1;for(e<=om?(n=e,r=!0):n=Ee(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Ee(e,n+1);return n}function ng(e,t,n){let r=[],a=e.length;for(let i=0;i<a;i++)i!==t?r.push(e[i]):r.push(n);return r}function rg(e,t,n,r){let a=t.shape.length,i=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let c=0;c<r;++c)if(e.shape[c]!==t.shape[c])throw new Error(`x.shape[${c}]: ${e.shape[c]} should be equal to indices.shape[${c}]: ${t.shape[c]}.`);let s=e.shape[n],o=[],l=1,u=1,d=1;for(let c=0;c<r;++c)o.push(e.shape[c]),l*=e.shape[c];for(let c=r;c<n;c++)o.push(e.shape[c]),u*=e.shape[c];for(let c=r;c<a;c++)o.push(t.shape[c]);for(let c=n+1;c<i;c++)o.push(e.shape[c]),d*=e.shape[c];return{batchSize:l,sliceSize:d,outerSize:u,dimSize:s,outputShape:o}}function ag(e){try{return e.map((e=>Ka(e)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function ig(e){return e.map((e=>qa(e)))}w(eg,{collectGatherOpShapeInfo:()=>rg,computeOutShape:()=>ng,segOpComputeOptimalWindowSize:()=>tg});var sg={};w(sg,{nonMaxSuppressionV3Impl:()=>zp,nonMaxSuppressionV4Impl:()=>Bp,nonMaxSuppressionV5Impl:()=>Wp,whereImpl:()=>rp}),function(){for(let e of Hh)Mh(e)}();var og={kernelName:Xe,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(e,Oc(bo(n,"float32"),-1))}}},lg={kernelName:Ye,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=hu(bo(n,"float32")),r=pu(Ku(cu(1),t));return Hu(So(e,r))}}}},ug={kernelName:Qe,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=pu(Ku(hu(bo(n,"float32")),1));return So(e,t)}}}},dg={kernelName:Je,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Gl(n.shape,r.shape);return{a:()=>{let t=e,r=Vl(n.shape,a);return r.length>0&&(t=fu(t,r)),Zo(t,n.shape)},b:()=>{let t=e,n=Vl(r.shape,a);return n.length>0&&(t=fu(t,n)),Zo(t,r.shape)}}}},cg={kernelName:Ze,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},pg={kernelName:nt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ql(n)}}},hg={kernelName:rt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ql(n)}}},fg={kernelName:at,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,pu(Ku(cu(1),hu(bo(n,"float32")))))}}},mg={kernelName:it,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=pu(wo(cu(1),hu(bo(n,"float32"))));return So(e,t)}}}},gg={kernelName:lt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Gl(n.shape,r.shape);return{a:()=>{let t=wo(hu(n),hu(r)),i=Io(e,So(r,t)),s=Vl(n.shape,a);return s.length>0&&(i=fu(i,s)),Zo(i,n.shape)},b:()=>{let t=wo(hu(n),hu(r)),i=Hu(Io(e,So(n,t))),s=Vl(r.shape,a);return s.length>0&&(i=fu(i,s)),Zo(i,r.shape)}}}},yg={kernelName:st,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,wo(hu(bo(n,"float32")),1))}}},bg={kernelName:ot,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,Ku(cu(1),hu(bo(n,"float32"))))}}};var vg=ji({avgPool3dGrad_:function(e,t,n,r,a,i){let s=Vi(e,"dy","avgPool3dGrad"),o=Vi(t,"input","avgPool3dGrad"),l=s,u=o,d=!1;4===o.rank&&(d=!0,l=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),u=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),te(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),te(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Jo("avgPool3dGrad",a,i);let c={dy:l,input:u},p={filterSize:n,strides:r,pad:a,dimRoundingMode:i},h=Ri.runKernel(pt,c,p);return d?Zo(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),xg={kernelName:ct,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:i,pad:s,dimRoundingMode:o}=n;return{x:()=>vg(e,r,a,i,s,o)}}};var wg=ji({avgPoolGrad_:function(e,t,n,r,a){let i=Vi(e,"dy","avgPoolGrad"),s=Vi(t,"input","avgPoolGrad");te(s.rank===i.rank,(()=>`Rank of input (${s.rank}) does not match rank of dy (${i.rank})`));let o=s,l=i,u=!1;3===s.rank&&(u=!0,o=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2]]),l=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2]])),te(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),te(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let d={dy:l,input:o},c={filterSize:n,strides:r,pad:a},p=Ri.runKernel(dt,d,c);return u?Zo(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),kg={kernelName:ut,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:i,pad:s}=n;return{x:()=>wg(e,r,a,i,s)}}},Sg={kernelName:ht,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:i,transposeB:s}=n;return i||s?!i&&s?{a:()=>rl(e,a,!1,!1),b:()=>rl(e,r,!0,!1)}:i&&!s?{a:()=>rl(a,e,!1,!0),b:()=>rl(r,e,!1,!1)}:{a:()=>rl(a,e,!0,!0),b:()=>rl(e,r,!0,!0)}:{a:()=>rl(e,a,!1,!0),b:()=>rl(r,e,!0,!1)}}},Ig={kernelName:ft,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>_d(e,r,a)}}},Ng={kernelName:yt,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,i=r.shape,s=Array.from(i);for(let l=a.length-1;l>=0;l--)if(a[l]===i[l])s[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${i}].`);let o=[];for(let l=0;l<s.length;l++)s[l]>1&&o.push(l);return{x:()=>fu(e,o,!0)}}},Tg={kernelName:vt,gradFunc:e=>({x:()=>e.clone()})},_g={kernelName:xt,gradFunc:e=>({x:()=>ql(e)})},Cg={kernelName:wt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:i}=n;return{x:()=>jl(Qu(Tu(r,a),Fu(r,i)),e,ql(e))}}},Eg={kernelName:St,inputsToSave:["x"],gradFunc:og.gradFunc},Ag={kernelName:It,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,i=me(a,t[0].shape)[0],s=r.map((e=>e[i]));return $c(e,s,i).map((e=>()=>e))}},$g={kernelName:Nt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:i,strides:s,pad:o,dataFormat:l}=n;return te(Ko(i),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`)),{x:()=>_l(r.shape,e,a,s,o,l),filter:()=>gp(r,e,a.shape,s,o,l)}}},Rg={kernelName:_t,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:i,pad:s,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Nl(e,a,i,s,o,1,l),filter:()=>gp(e,r,a.shape,i,s,o,l)}}};var Fg=ji({conv3DBackpropFilter_:function(e,t,n,r,a){let i=e;4===e.rank&&(i=Zo(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let s=t;4===s.rank&&(s=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),te(5===i.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`)),te(5===s.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`)),te(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),te(i.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`)),te(s.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:i,dy:s},l={strides:r,pad:a,filterShape:n};return Ri.runKernel(Et,o,l)}}),Dg={kernelName:Ct,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:i}=n;te(Ko(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[s,o]=t;return{x:()=>Al(s.shape,e,o,a,i),filter:()=>Fg(s,e,o.shape,a,i)}}},Mg={kernelName:$t,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(Hu(wc(bo(n,"float32"))),e)}}},Og={kernelName:Rt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(kc(bo(n,"float32")),e)}}},Pg={kernelName:Dt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:i,reverse:s}=n;return{x:()=>{let t=iu([a],r.rank),n=Ml(e,a,i,!s);return null!=t&&(n=sp(n,t)),n}}}},Lg={kernelName:Lt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:i,dimRoundingMode:s}=n,o=null==r?[1,1]:r;te(Ko(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return te(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),te(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),te(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),te(Xo(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),Jo("depthwiseConv2d",i,s),{x:()=>Sp(l.shape,e,u,a,i,o,s),filter:()=>kp(l,e,u.shape,a,i,o,s)}}},zg={kernelName:Ut,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,i={x:r,filter:a,dy:e},s={x:r,filter:a,dy:e};return{x:()=>Ri.runKernel(Vt,i,n),filter:()=>Ri.runKernel(Gt,s,n)}}},Bg={kernelName:Kt,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>Ri.runKernel(Xt,r)}}},Wg={kernelName:Yt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Io(bu(Hu(hu(n))),2/Math.sqrt(Math.PI));return{x:()=>Io(e,r)}}},Ug={kernelName:Jt,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(e,n)}}},Vg={kernelName:Zt,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>Zo(e,n.shape)}}},Gg={kernelName:en,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(e,bu(n))}}},Hg={kernelName:an,gradFunc:e=>({x:()=>ql(e)})},jg={kernelName:sn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Gl(n.shape,r.shape);return{a:()=>{let t=So(e,bo(r,"float32")),i=Vl(n.shape,a);return i.length>0?Zo(fu(t,i),n.shape):t},b:()=>{let t=Io(e,bo(n,"float32")),i=Vl(r.shape,a);i.length>0&&(t=Zo(fu(t,i),r.shape));let s=hu(r);return Hu(So(t,bo(s,"float32")))}}}},qg={kernelName:on,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,i,s,o]=t,l=null==o?cu(1):o,u=Vl(i.shape,a.shape),d=[];if(1===i.rank){for(let e=0;e<a.shape.length-1;++e)d.push(a.shape[e]);d.push(1)}let c=Ku(a,i),p=Io(e,l),h=gc(wo(s,cu(r))),f=Io(Io(Io(h,h),h),cu(-.5));return{x:()=>1===i.rank?Zo(Io(Io(e,wu(Zo(h,[1,1,1,i.shape[0]]),d)),l),a.shape):Zo(Io(Io(e,h),l),a.shape),mean:()=>{let e=Io(Io(h,cu(-1)),p);return 1===i.rank&&(e=fu(e,u)),Zo(e,i.shape)},variance:()=>{let e=Io(Io(f,c),p);return 1===i.rank&&(e=fu(e,u)),Zo(e,i.shape)},scale:()=>{let t=Io(c,h),n=Io(e,t);return 1===i.rank&&(n=fu(n,u)),Zo(n,i.shape)},offset:()=>{let t=e;return 1===i.rank&&(t=fu(t,u)),Zo(t,i.shape)}}}},Kg={kernelName:ln,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:i,batchDims:s}=n,o=me(i,r.shape)[0],l=(e,t,n)=>()=>{let r=e.shape,a=t.size,s=r.slice(0,o),l=s.length,u=r.slice(i,r.length).slice(1),d=u.length,c=Xg(0,l),p=Xg(l+1,l+1+d),h=Yg([s,[a],u]),f=Zo(n,h),m=Zo(t,[a]),g=Yg([[l],c,p]),y=sp(f,g),b=Zc(y,m,e.shape[o]),v=su(g);return b=sp(b,v),b};if(1===s){let t=r.shape[0],n=r.split(t,0);return{x:()=>Mc(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))()))).reshape(r.shape),indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function Xg(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Yg(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Qg={kernelName:cn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>ql(n),b:()=>ql(r)}}},Jg={kernelName:pn,gradFunc:e=>({x:()=>bo(e,"float32")})},Zg={kernelName:mn,gradFunc:e=>({x:()=>ql(e)})},ey={kernelName:gn,gradFunc:e=>({x:()=>ql(e)})},ty={kernelName:yn,gradFunc:e=>({x:()=>ql(e)})},ny={kernelName:bn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,i=Nu(r,0);return{x:()=>jl(i,e,Io(e,a))}}},ry={kernelName:Sn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,wo(n,1))}}},ay={kernelName:kn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,bo(n,"float32"))}}},iy={kernelName:Cn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=bu(r);return Ku(e,Io(fu(e,a,!0),t))}}}};var sy=ji({localResponseNormalizationBackprop_:function(e,t,n){let r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Ri.runKernel($n,r,a)}}),oy={kernelName:An,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:i,bias:s,alpha:o,beta:l}=n;return{x:()=>sy(r,a,e,i,s,o,l)}}};function ly(e,t,n,r){return t.rank<n.rank&&(t=Zo(t,ru(t.shape,r))),e.rank<n.rank&&(e=Zo(e,ru(e.shape,r))),{x:()=>Io(e,bo(Hl(n,t),e.dtype))}}var uy={kernelName:Fn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,i=t[0],s=ly(e,t[1],i,me(a,i.shape));return{x:()=>s.x()}}},dy={kernelName:Dn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Io(e,bo(Tu(n,r),"float32")),b:()=>Io(e,bo(Ru(n,r),"float32"))}}};var cy=ji({maxPool3dGrad_:function(e,t,n,r,a,i,s){let o=Vi(e,"dy","maxPool3dGrad"),l=Vi(t,"input","maxPool3dGrad"),u=Vi(n,"output","maxPool3dGrad"),d=o,c=l,p=u,h=!1;4===l.rank&&(h=!0,d=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=Zo(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=Zo(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),te(5===d.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`)),te(5===c.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`)),te(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),Jo("maxPool3dGrad",i,s);let f={dy:d,input:c,output:p},m={filterSize:r,strides:a,pad:i,dimRoundingMode:s},g=Ri.runKernel(Ln,f,m);return h?Zo(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),py={kernelName:Pn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=n;return{x:()=>cy(e,r,a,i,s,o,l)}}};var hy=ji({maxPoolGrad_:function(e,t,n,r,a,i,s){let o=Vi(e,"dy","maxPoolGrad"),l=Vi(t,"input","maxPoolGrad"),u=Vi(n,"output","maxPoolGrad");te(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),te(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),te(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Jo("maxPoolGrad",i,s);let d={dy:o,input:l,output:u},c={filterSize:r,strides:a,pad:i,dimRoundingMode:s};return Ri.runKernel(On,d,c)}}),fy={kernelName:Mn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:i,strides:s,pad:o}=n;return{x:()=>hy(e,r,a,i,s,o)}}},my={kernelName:Bn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,i=me(a,r.shape),s=ae(nu(r.shape,i)[1]);return{x:()=>{let t=r.shape.slice();i.forEach((e=>{t[e]=1}));let n=Zo(e,t);return So(Io(n,dd(r.shape,"float32")),s)}}}},gy={kernelName:Wn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[i,s]=t,o=ly(e,s,i,me(a,i.shape));return{x:()=>o.x()}}},yy={kernelName:Un,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Io(e,bo(Fu(n,r),"float32")),b:()=>Io(e,bo(Nu(n,r),"float32"))}}},by={kernelName:Vn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,i=a.map((e=>e[0]));return{x:()=>il(e,i,r.shape)}}},vy={kernelName:Gn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Gl(n.shape,r.shape);return{a:()=>{let t=Vl(n.shape,a);return t.length>0?Zo(fu(e,t),n.shape):e},b:()=>{let t=Io(e,Hu(Su(So(n,r)))),i=Vl(r.shape,a);return i.length>0?Zo(fu(t,i),r.shape):t}}}},xy={kernelName:jn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Gl(n.shape,r.shape);return{a:()=>{let t=Io(e,bo(r,"float32")),i=Vl(n.shape,a);return i.length>0?Zo(fu(t,i),n.shape):t},b:()=>{let t=Io(e,bo(n,"float32")),i=Vl(r.shape,a);return i.length>0?Zo(fu(t,i),r.shape):t}}}},wy={kernelName:qn,gradFunc:e=>({x:()=>Hu(e)})},ky={kernelName:Zn,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>ud(n.shape,"float32")}}},Sy={kernelName:Jn,gradFunc:e=>({x:()=>ql(e)})},Iy={kernelName:er,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return ep(e,r).map((e=>()=>e))}},Ny={kernelName:tr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,i=a.map((e=>e[0]));return{x:()=>il(e,i,r.shape)}}},Ty={kernelName:rr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,i=n,s=r,o=Gl(i.shape,s.shape);return{a:()=>{let t=bo(s,"float32"),n=Io(e,Io(t,du(i,Ku(t,cu(1))))),r=Vl(i.shape,o);return r.length>0&&(n=fu(n,r)),Zo(n,i.shape)},b:()=>{let t=Nu(i,0),n=jl(t,Ou(i),ql(i)),r=Io(e,Io(a,n)),l=Vl(s.shape,o);return l.length>0&&(r=fu(r,l)),Zo(r,s.shape)}}}},_y={kernelName:ar,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=Nu(n,0);return{x:()=>jl(a,e,Io(e,r)),alpha:()=>{let t=jl(a,ql(e),Io(e,n)),i=Vl(r.shape,e.shape);return i.length>0&&(t=fu(t,i)),Zo(t,r.shape)}}}};function Cy(e,t,n){let r=e.shape.length,a=r-n.length,i=em.getAxesPermutation(n,r),s=e;null!=i&&(s=sp(e,i));let o=s.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){let r=e.shape.slice();r[n]=1;let a=Zo(t,r),i=Dl(e,n,!0,!1),s=Dl(e,n,!0,!0),o=Io(i,s);return Io(a,o)}(s.reshape(o),t,a);if(u=u.reshape(s.shape),null!=i){let e=em.getUndoAxesPermutation(i);u=sp(u,e)}return u}var Ey={kernelName:ir,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,i=[];return i=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>Cy(r,e,i)}}},Ay={kernelName:jt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Gl(n.shape,r.shape);return{a:()=>{let t=So(e,bo(r,"float32")),i=Vl(n.shape,a);return i.length>0?Zo(fu(t,i),n.shape):t},b:()=>{let t=Io(e,bo(n,"float32")),i=Vl(r.shape,a);i.length>0&&(t=Zo(fu(t,i),r.shape));let s=hu(r);return Hu(So(t,bo(s,"float32")))}}}},$y={kernelName:cr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,Hu(hu(n)))}}},Ry={kernelName:br,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Io(Fu(n,6),Oc(n));return{x:()=>Io(e,bo(r,"float32"))}}},Fy={kernelName:pr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(e,bo(Oc(n),"float32"))}}},Dy={kernelName:hr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,n.shape)}}},My={kernelName:gr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Ri.runKernel(yr,a,n)}}},Oy={kernelName:fr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Ri.runKernel(mr,a,n)}}},Py={kernelName:vr,gradFunc:(e,t,n)=>{let{dims:r}=n,a=me(r,e.shape);return{x:()=>dc(e,a)}}},Ly={kernelName:xr,gradFunc:e=>({x:()=>ql(e)})},zy={kernelName:wr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(So(e,Io(du(n,1.5),2)))}}},By={kernelName:Nr,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>bo(ql(n),"float32"),t:()=>Io(e,bo(n,e.dtype)),e:()=>Io(e,bo(Ju(n),e.dtype))}}},Wy={kernelName:Tr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Nu(n,cu(0)),r=cu(mm),a=cu(gm),i=Io(e,a),s=Io(Io(e,r),bu(bo(n,"float32")));return jl(t,i,s)}}}},Uy={kernelName:$r,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(e,Io(n,Ku(cu(1),n)))}}},Vy={kernelName:Ar,gradFunc:e=>({x:()=>ql(e)})},Gy={kernelName:Cr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(Rl(bo(n,"float32")),e)}}},Hy={kernelName:Er,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(Fl(bo(n,"float32")),e)}}},jy={kernelName:_r,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:i}=n,s=r.shape,[o,l]=Hf(r,a,i),u=[];for(let d=0;d<e.rank;d++)u.push([o[d],s[d]-o[d]-l[d]]);return{x:()=>kd(e,u)}}},qy={kernelName:Pr,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,i=Io(e,r);return{logits:()=>Ku(i,Io(fu(i,[a],true),r))}}},Ky={kernelName:Rr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(e,al(n))}}},Xy={kernelName:Mr,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>ll(e,r,a)}}},Yy={kernelName:Or,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>nl(e,r)}}},Qy={kernelName:Fr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,Io(pu(bo(n,"float32")),2))}}},Jy={kernelName:Gr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(e,Io(bo(n,"float32"),2))}}},Zy={kernelName:Vr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=cu(2);return{a:()=>Io(e,Io(a,Ku(n,r))),b:()=>Io(e,Io(a,Ku(r,n)))}}},eb={kernelName:la,gradFunc:e=>({x:()=>ql(e)})},tb={kernelName:Yr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Gl(n.shape,r.shape);return{a:()=>{let t=e,r=Vl(n.shape,a);return r.length>0&&(t=fu(t,r)),Zo(t,n.shape)},b:()=>{let t=e,n=Vl(r.shape,a);return n.length>0&&(t=fu(t,n)),Zo(Hu(t),r.shape)}}}},nb={kernelName:Dr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:i}=n;me(i,r.shape).forEach((e=>{a[e]=1}));let s=Zo(e,a),o=Io(s,dd(r.shape,"float32"));return{x:()=>o}}},rb={kernelName:Qr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>So(e,hu(Rl(n)))}}},ab={kernelName:Jr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Io(Ku(cu(1),hu(n)),e)}}},ib={kernelName:Zr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=ql(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=wo(t,il(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let i=0;i<a[1];++i)t=wo(t,il(e,[n*r.shape[0],i*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let i=0;i<a[1];++i)for(let s=0;s<a[2];++s)t=wo(t,il(e,[n*r.shape[0],i*r.shape[1],s*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let i=0;i<a[1];++i)for(let s=0;s<a[2];++s)for(let o=0;o<a[3];++o)t=wo(t,il(e,[n*r.shape[0],i*r.shape[1],s*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},sb={kernelName:na,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,i=su(a);return{x:()=>sp(e,i)}}},ob={kernelName:aa,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Mc(e,a)}}},lb={kernelName:ia,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function(e,t){let n=od(t,ql(t)),r=Iu(e,n),a=Tu(t,cu(0,"int32")),i=r.rank-a.rank;for(let o=0;o<i;++o)a=vu(a,o+1);a=Qu(a,dd(r.shape,"bool"));let s=ql(r);return jl(a,r,s)}(e,n)}}};var ub={kernelName:oa,gradFunc:e=>({x:()=>ql(e)})},db=[og,lg,ug,dg,cg,pg,hg,fg,mg,gg,yg,bg,xg,kg,Sg,Ig,Ng,Tg,_g,Cg,Eg,Ag,Rg,$g,Dg,Mg,Og,Pg,Lg,zg,Ay,Bg,Wg,Ug,Vg,Gg,jg,Hg,qg,Kg,Qg,Jg,Zg,ey,ty,ny,ry,ay,iy,oy,uy,uy,dy,py,fy,my,gy,yy,by,vy,xy,wy,ky,Sy,Iy,Ny,Ny,Ty,_y,Ey,$y,Ry,Fy,Dy,My,Oy,Py,Ly,zy,By,Wy,Uy,Vy,Gy,Hy,jy,qy,Ky,Xy,Xy,Yy,Yy,Qy,Zy,Jy,eb,tb,nb,rb,ab,ib,sb,ob,lb,ub];for(let n of db)ka(n);ui().prototype.abs=function(){return this.throwIfDisposed(),No(this)},ui().prototype.acos=function(){return this.throwIfDisposed(),To(this)},ui().prototype.acosh=function(){return this.throwIfDisposed(),_o(this)},ui().prototype.add=function(e){return this.throwIfDisposed(),wo(this,e)},ui().prototype.all=function(e,t){return this.throwIfDisposed(),Eo(this,e,t)},ui().prototype.any=function(e,t){return this.throwIfDisposed(),Ao(this,e,t)},ui().prototype.argMax=function(e){return this.throwIfDisposed(),$o(this,e)},ui().prototype.argMin=function(e){return this.throwIfDisposed(),Ro(this,e)},ui().prototype.asScalar=function(){return this.throwIfDisposed(),te(1===this.size,(()=>"The array must have only 1 element.")),Zo(this,[])},ui().prototype.asType=function(e){return this.throwIfDisposed(),bo(this,e)},ui().prototype.as1D=function(){return this.throwIfDisposed(),Zo(this,[this.size])},ui().prototype.as2D=function(e,t){return this.throwIfDisposed(),Zo(this,[e,t])},ui().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Zo(this,[e,t,n])},ui().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Zo(this,[e,t,n,r])},ui().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),Zo(this,[e,t,n,r,a])},ui().prototype.asin=function(){return this.throwIfDisposed(),Fo(this)},ui().prototype.asinh=function(){return this.throwIfDisposed(),Do(this)},ui().prototype.atan=function(){return this.throwIfDisposed(),Mo(this)},ui().prototype.atan2=function(e){return this.throwIfDisposed(),Oo(this,e)},ui().prototype.atanh=function(){return this.throwIfDisposed(),Po(this)},ui().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),el(this,e,t,n,r)},ui().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),ll(this,e,t)},ui().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),dl(this,e,t,n,r,a)},ui().prototype.broadcastTo=function(e){return this.throwIfDisposed(),yl(this,e)},ui().prototype.cast=function(e){return this.throwIfDisposed(),bo(this,e)},ui().prototype.ceil=function(){return this.throwIfDisposed(),bl(this)},ui().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),xl(this,e,t)},ui().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof li&&(e=[e]),nl([this,...e],t)},ui().prototype.conv1d=function(e,t,n,r,a,i){return this.throwIfDisposed(),Tl(this,e,t,n,r,a,i)},ui().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Cl(this,e,t,n,r,a)},ui().prototype.conv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),Nl(this,e,t,n,r,a,i)},ui().prototype.cos=function(){return this.throwIfDisposed(),Rl(this)},ui().prototype.cosh=function(){return this.throwIfDisposed(),Fl(this)},ui().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Dl(this,e,t,n)},ui().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Ml(this,e,t,n)},ui().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Pl(this,e,t)},ui().prototype.depthwiseConv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),Ll(this,e,t,n,r,a,i)},ui().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),Bl(this,e,t,n,r,a)},ui().prototype.divNoNan=function(e){return this.throwIfDisposed(),Kl(this,e)},ui().prototype.div=function(e){return this.throwIfDisposed(),So(this,e)},ui().prototype.dot=function(e){return this.throwIfDisposed(),Xl(this,e)},ui().prototype.elu=function(){return this.throwIfDisposed(),Ql(this)},ui().prototype.equal=function(e){return this.throwIfDisposed(),Hl(this,e)},ui().prototype.erf=function(){return this.throwIfDisposed(),Zl(this)},ui().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),yu(this,e,t)},ui().prototype.exp=function(){return this.throwIfDisposed(),bu(this)},ui().prototype.expandDims=function(e){return this.throwIfDisposed(),vu(this,e)},ui().prototype.expm1=function(){return this.throwIfDisposed(),xu(this)},ui().prototype.fft=function(){return this.throwIfDisposed(),Cc(this)},ui().prototype.flatten=function(){return this.throwIfDisposed(),Zo(this,[this.size])},ui().prototype.floor=function(){return this.throwIfDisposed(),Su(this)},ui().prototype.floorDiv=function(e){return this.throwIfDisposed(),ko(this,e)},ui().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Iu(this,e,t,n)},ui().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Tu(this,e)},ui().prototype.greater=function(e){return this.throwIfDisposed(),Nu(this,e)},ui().prototype.ifft=function(){return this.throwIfDisposed(),Ec(this)},ui().prototype.irfft=function(){return this.throwIfDisposed(),Ac(this)},ui().prototype.isFinite=function(){return this.throwIfDisposed(),Cu(this)},ui().prototype.isInf=function(){return this.throwIfDisposed(),Eu(this)},ui().prototype.isNaN=function(){return this.throwIfDisposed(),Au(this)},ui().prototype.leakyRelu=function(e){return this.throwIfDisposed(),$u(this,e)},ui().prototype.lessEqual=function(e){return this.throwIfDisposed(),Fu(this,e)},ui().prototype.less=function(e){return this.throwIfDisposed(),Ru(this,e)},ui().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Mu(this,e,t,n,r)},ui().prototype.logSigmoid=function(){return this.throwIfDisposed(),qu(this)},ui().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Xu(this,e)},ui().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Yu(this,e,t)},ui().prototype.log=function(){return this.throwIfDisposed(),Ou(this)},ui().prototype.log1p=function(){return this.throwIfDisposed(),Pu(this)},ui().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Qu(this,e)},ui().prototype.logicalNot=function(){return this.throwIfDisposed(),Ju(this)},ui().prototype.logicalOr=function(e){return this.throwIfDisposed(),Zu(this,e)},ui().prototype.logicalXor=function(e){return this.throwIfDisposed(),ed(this,e)},ui().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),rl(this,e,t,n)},ui().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),ad(this,e,t,n,r)},ui().prototype.max=function(e,t){return this.throwIfDisposed(),lu(this,e,t)},ui().prototype.maximum=function(e){return this.throwIfDisposed(),od(this,e)},ui().prototype.mean=function(e,t){return this.throwIfDisposed(),ld(this,e,t)},ui().prototype.min=function(e,t){return this.throwIfDisposed(),uu(this,e,t)},ui().prototype.minimum=function(e){return this.throwIfDisposed(),pd(this,e)},ui().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),hd(this,e,t)},ui().prototype.mod=function(e){return this.throwIfDisposed(),fd(this,e)},ui().prototype.mul=function(e){return this.throwIfDisposed(),Io(this,e)},ui().prototype.neg=function(){return this.throwIfDisposed(),Hu(this)},ui().prototype.norm=function(e,t,n){return this.throwIfDisposed(),gu(this,e,t,n)},ui().prototype.notEqual=function(e){return this.throwIfDisposed(),bd(this,e)},ui().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),vd(this,e,t,n)},ui().prototype.onesLike=function(){return this.throwIfDisposed(),xd(this)},ui().prototype.pad=function(e,t){return this.throwIfDisposed(),kd(this,e,t)},ui().prototype.pool=function(e,t,n,r,a,i){return this.throwIfDisposed(),Cd(this,e,t,n,r,a,i)},ui().prototype.pow=function(e){return this.throwIfDisposed(),du(this,e)},ui().prototype.prelu=function(e){return this.throwIfDisposed(),Ed(this,e)},ui().prototype.prod=function(e,t){return this.throwIfDisposed(),Ad(this,e,t)},ui().prototype.reciprocal=function(){return this.throwIfDisposed(),oc(this)},ui().prototype.relu=function(){return this.throwIfDisposed(),lc(this)},ui().prototype.relu6=function(){return this.throwIfDisposed(),uc(this)},ui().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Zo(this,e.shape)},ui().prototype.reshape=function(e){return this.throwIfDisposed(),Zo(this,e)},ui().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Qp(this,e,t,n)},ui().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Jp(this,e,t,n)},ui().prototype.reverse=function(e){return this.throwIfDisposed(),dc(this,e)},ui().prototype.rfft=function(){return this.throwIfDisposed(),Rc(this)},ui().prototype.round=function(){return this.throwIfDisposed(),mc(this)},ui().prototype.rsqrt=function(){return this.throwIfDisposed(),gc(this)},ui().prototype.selu=function(){return this.throwIfDisposed(),yc(this)},ui().prototype.separableConv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),bc(this,e,t,n,r,a,i)},ui().prototype.sigmoid=function(){return this.throwIfDisposed(),al(this)},ui().prototype.sign=function(){return this.throwIfDisposed(),xc(this)},ui().prototype.sin=function(){return this.throwIfDisposed(),wc(this)},ui().prototype.sinh=function(){return this.throwIfDisposed(),kc(this)},ui().prototype.slice=function(e,t){return this.throwIfDisposed(),il(this,e,t)},ui().prototype.softmax=function(e){return this.throwIfDisposed(),_c(this,e)},ui().prototype.softplus=function(){return this.throwIfDisposed(),ju(this)},ui().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),_d(this,e,t)},ui().prototype.split=function(e,t){return this.throwIfDisposed(),$c(this,e,t)},ui().prototype.sqrt=function(){return this.throwIfDisposed(),pu(this)},ui().prototype.square=function(){return this.throwIfDisposed(),hu(this)},ui().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Fc(this,e)},ui().prototype.squeeze=function(e){return this.throwIfDisposed(),Dc(this,e)},ui().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof li?[this,e]:[this,...e];return Mc(n,t)},ui().prototype.step=function(e){return this.throwIfDisposed(),Oc(this,e)},ui().prototype.stridedSlice=function(e,t,n,r,a,i,s,o){return this.throwIfDisposed(),Pc(this,e,t,n,r,a,i,s,o)},ui().prototype.sub=function(e){return this.throwIfDisposed(),Ku(this,e)},ui().prototype.sum=function(e,t){return this.throwIfDisposed(),fu(this,e,t)},ui().prototype.tan=function(){return this.throwIfDisposed(),Lc(this)},ui().prototype.tanh=function(){return this.throwIfDisposed(),sl(this)},ui().prototype.tile=function(e){return this.throwIfDisposed(),wu(this,e)},ui().prototype.toBool=function(){return this.throwIfDisposed(),bo(this,"bool")},ui().prototype.toFloat=function(){return this.throwIfDisposed(),bo(this,"float32")},ui().prototype.toInt=function(){return this.throwIfDisposed(),bo(this,"int32")},ui().prototype.topk=function(e,t){return this.throwIfDisposed(),Yc(this,e,t)},ui().prototype.transpose=function(e){return this.throwIfDisposed(),sp(this,e)},ui().prototype.unique=function(e){return this.throwIfDisposed(),Jc(this,e)},ui().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Zc(this,e,t)},ui().prototype.unstack=function(e){return this.throwIfDisposed(),ep(this,e)},ui().prototype.where=function(e,t){return this.throwIfDisposed(),jl(e,this,t)},ui().prototype.zerosLike=function(){return this.throwIfDisposed(),ql(this)};var cb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},pb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},hb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},fb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},mb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},gb=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function yb(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function bb(e,t){if(!e)throw new mb(t)}function vb(e,t){let n=0;for(let r of e)r===t&&n++;return n}function xb(e){return 1===e.length?e[0]:e}function wb(e){return Array.isArray(e)?e:[e]}function kb(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Sb(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var Ib={};function Nb(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Tb(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>Tb(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?Tb(t):e[n]=t.value)}}}function _b(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"==typeof e){let a,i=e;if(i in n)a=n[i];else if(i in Ib)a=Ib[i];else if(a=t[i],null==a)throw new hb(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let i=e;if(null==i.className||null==i.config)throw new hb(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);let s,o,l=i.className;if(l in n?[s,o]=n[l]:l in Ib?[s,o]=Ib.className:l in t&&([s,o]=t[l]),null==s)throw new hb(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let n of Object.keys(Ib))e[n]=Ib[n];for(let a of Object.keys(n))e[a]=n[a];i.config.customObjects=e;let t=Object.assign({},Ib);for(let a of Object.keys(n))Ib[a]=n[a];Tb(i.config);let r=o(s,i.config,n,a);return Ib=Object.assign({},t),r}{let e=Object.assign({},Ib);for(let r of Object.keys(n))Ib[r]=n[r];let t=new s(i.config);return Ib=Object.assign({},e),t}}}function Cb(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Eb(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function Ab(e){if(null==e)throw new hb(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function $b(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new hb(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return bb(n>=0),bb(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function Fb(e,t){Array.isArray(e)?(_a.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>Fb(e,`element ${n+1} of ${t}`)))):_a.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${Db(e)}.`))}function Db(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>Db(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function Mb(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var Ob=0;function Pb(){return Ob++}var Lb={};function zb(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in Lb||(Lb[e]=0),Lb[e]+=1,e+Lb[e].toString()}var Bb=["channelsFirst","channelsLast"],Wb=["nearest","bilinear"],Ub=["valid","same","causal"],Vb=["max","avg"],Gb=["sum","mul","concat","ave"],Hb=new Map;function jb(e){$b(Bb,"DataFormat",e)}function qb(e){$b(Ub,"PaddingMode",e)}function Kb(e){$b(Vb,"PoolMode",e)}var Xb=[];function Yb(e,t){Xb.push(e);try{let e=t();return Xb.pop(),e}catch(NZ){throw Xb.pop(),NZ}}function Qb(e){if(!tv(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Xb.length?"":Xb.join("/")+"/")+e}function Jb(e){if(!tv(e))throw new Error("Not a valid tensor name: '"+e+"'");Hb.has(e)||Hb.set(e,0);let t=Hb.get(e);if(Hb.set(e,Hb.get(e)+1),t>0){let n=`${e}_${t}`;return Hb.set(n,1),n}return e}var Zb,ev=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function tv(e){return!!e.match(ev)}function nv(e){return e===parseInt(e.toString(),10)}function rv(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function av(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function iv(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function sv(e,t){if(t<e)throw new hb(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function ov(){return null==Zb&&(Zb=ys().epsilon()),Zb}function lv(e,t){return bo(e,t)}function uv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Zo(e,n)}function dv(e,t,n){return ss((()=>{switch(e.rank){case 1:return Sc(e,t,n);case 2:return Ic(e,[t,0],[n,e.shape[1]]);case 3:return Nc(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Tc(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return il(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return il(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new hb(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function cv(e,t,n){return ss((()=>{switch(e.rank){case 1:return Sc(e,t,n);case 2:return Ic(e,[0,t],[e.shape[0],n]);case 3:return Nc(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Tc(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new hb(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function pv(e,t,n,r){return ss((()=>{switch(e.rank){case 1:return Sc(e,t,n);case 2:switch(r){case 1:return dv(e,t,n);case 2:return cv(e,t,n);default:throw new hb(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return dv(e,t,n);case 2:return Nc(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return cv(e,t,n);default:throw new hb(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return dv(e,t,n);case 2:return Tc(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Tc(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return cv(e,t,n);default:throw new hb(`The axis is not within the rank of the tensor ${r}`)}default:throw new hb(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function hv(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),nl(e,n)}function fv(e,t){switch(e.rank){case 1:return wl([e,t]);case 2:return kl([e,t],0);case 3:return Sl([e,t],0);case 4:return Il([e,t],0);default:throw new hb(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function mv(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new hb(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return wu(e,t)}function gv(e){return tc(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function yv(e,t,n,r){if(e.rank<2||t.rank<2)throw new fb(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new fb(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return mp.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?xv(e.rank,r,"channelsLast"):null,activation:n});{let a=e.shape.slice(),i=a.pop();e=Zo(e,[-1,i]);let s=t.shape.slice(),o=s.pop(),l=s.pop(),u=[...s,o],d=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Zo(sp(t,d),[l,-1]);let c=[...a,...u];return Zo(mp.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?xv(e.rank,r,"channelsLast"):null,activation:n}),c)}}function bv(e,t,n){return ss((()=>(t=Array.isArray(t)?zc(t,"int32"):bo(t,"int32"),Iu(e,t,n))))}function vv(e){return Io(e,e)}function xv(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new hb(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Zo(t,[1,r[0],1,1,1]):Zo(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Zo(t,[1,1,1,1,r[0]]):Zo(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Zo(t,[1,r[0],1,1]):Zo(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Zo(t,[1,1,1,r[0]]):Zo(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Zo(t,[1,r[0],1]):Zo(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Zo(t,[1,1,r[0]]):Zo(t,[1].concat(r))}else if(e<3)return t;throw new hb(`Unsupported input rank by biasAdd: ${t.rank}`)}function wv(e,t,n){return ss((()=>(null==n&&(n="channelsLast"),jb(n),wo(e,xv(e.rank,t,n)))))}function kv(e,t,n,r){return ss((()=>cp(e,t,n,r)))}function Sv(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}var Iv=["fanIn","fanOut","fanAvg"],Nv=["normal","uniform","truncatedNormal"];var Tv=class extends Ah.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},_v=class extends Tv{apply(e,t){return ud(e,t)}};_v.className="Zeros",Ah.registerClass(_v);var Cv=class extends Tv{apply(e,t){return dd(e,t)}};Cv.className="Ones",Ah.registerClass(Cv);var Ev=class extends Tv{constructor(e){if(super(),"object"!=typeof e)throw new hb(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new hb(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ss((()=>Io(cu(this.value),dd(e,t))))}getConfig(){return{value:this.value}}};Ev.className="Constant",Ah.registerClass(Ev);var Av=class extends Tv{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return rc(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Av.className="RandomUniform",Ah.registerClass(Av);var $v=class extends Tv{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new fb(`randomNormal does not support dType ${t}.`);return gv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};$v.className="RandomNormal",Ah.registerClass($v);var Rv=class extends Tv{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new fb(`truncatedNormal does not support dType ${t}.`);return Qc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Rv.className="TruncatedNormal",Ah.registerClass(Rv);var Fv=class extends Tv{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return ss((()=>{if(2!==e.length||e[0]!==e[1])throw new hb("Identity matrix initializer can only be used for 2D square matrices.");return Io(this.gain,ku(e[0]))}))}getConfig(){return{gain:this.gain}}};Fv.className="Identity",Ah.registerClass(Fv);var Dv=class extends Tv{constructor(e){if(super(),e.scale<0)throw new hb(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){$b(Iv,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){$b(Nv,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){let n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(jb(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){let r=rv(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){let r=rv(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{let r=rv(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1],i=this.scale;if("fanIn"===this.mode?i/=Math.max(1,r):"fanOut"===this.mode?i/=Math.max(1,a):i/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(i);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new fb(`${this.getClassName()} does not support dType ${t}.`);return Qc(e,0,n,t,this.seed)}{let n=Math.sqrt(3*i);return rc(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Dv.className="VarianceScaling",Ah.registerClass(Dv);var Mv=class extends Dv{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Dv.className}};Mv.className="GlorotUniform",Ah.registerClass(Mv);var Ov=class extends Dv{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Dv.className}};Ov.className="GlorotNormal",Ah.registerClass(Ov);var Pv=class extends Dv{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Dv.className}};Pv.className="HeNormal",Ah.registerClass(Pv);var Lv=class extends Dv{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Dv.className}};Lv.className="HeUniform",Ah.registerClass(Lv);var zv=class extends Dv{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Dv.className}};zv.className="LeCunNormal",Ah.registerClass(zv);var Bv=class extends Dv{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Dv.className}};Bv.className="LeCunUniform",Ah.registerClass(Bv);var Wv=class extends Tv{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ss((()=>{if(e.length<2)throw new fb("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);let n=_a.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let i=gv([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),s=Th.qr(i,!1),o=s[0],l=s[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=Io(o,l.sign()),n<r&&(o=o.transpose()),Io(cu(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}};Wv.className="Orthogonal",Ah.registerClass(Wv);var Uv={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Vv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _b(e,Ah.SerializationMap.getMap().classNameMap,t,"initializer")}function Gv(e){return Nb(e)}function Hv(e){if("string"==typeof e){let t=e in Uv?Uv[e]:e;if("GlorotNormal"===t)return new Ov;if("GlorotUniform"===t)return new Mv;if("HeNormal"===t)return new Pv;if("HeUniform"===t)return new Lv;if("LeCunNormal"===t)return new zv;if("LeCunUniform"===t)return new Bv;{let e={};return e.className=t,e.config={},Vv(e)}}return e instanceof Tv?e:Vv(e)}function jv(e){return Array.isArray(e)&&Array.isArray(e[0])}function qv(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Kv(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new hb(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Xv(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new hb(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Yv(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var Qv="Variable",Jv=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Qv,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Pb(),n=null==n?Qv:n,this.originalName=Qb(n),this.name=Jb(this.originalName),this.trainable_=r,this.constraint=a,this.val=np(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Zv(e){return e.map((e=>e.read()))}function ex(e){e.forEach((e=>{e[0].write(e[1])}))}var tx=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},nx=class{constructor(e,t,n,r,a,i,s){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=s,this.id=Pb(),null!=i&&(this.originalName=Qb(i),this.name=Jb(this.originalName)),this.rank=t.length}},rx=0,ax=class{constructor(e,t){this.callArgs=t,this.id=rx++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},ix=0,sx=class extends Ah.Serializable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ix++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=kb(e)+"_"+zb(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new pb(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new hb(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return xb(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return xb(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new cb(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new cb(`Layer ${this.name} is not connected, no input to return.`);return xb(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new cb(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new cb(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return xb(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=wb(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let n=wb(this.inputSpec);if(t.length!==n.length)throw new hb(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let e=t[r],a=n[r];if(null==a)continue;let i=e.rank;if(null!=a.ndim&&i!==a.ndim)throw new hb(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(null!=a.maxNDim&&i>a.maxNDim)throw new hb(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(null!=a.minNDim&&i<a.minNDim)throw new hb(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new hb(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){let t=e.shape;for(let e in a.axes){let n=Number(e),i=a.axes[e],s=n>=0?t[n]:t[t.length+n];if(null!=i&&-1===[i,null].indexOf(s))throw new hb(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){let n=a.shape[t],i=e.shape[t];if(null!=n&&null!=i&&n!==i)throw new hb(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=wb(e),r=function(e){let t=!0;for(let n of wb(e))if(!(n instanceof nx)){t=!1;break}return t}(e),a=function(e){let t=!0;for(let n of wb(e))if(n instanceof nx){t=!1;break}return t}(e);if(r===a)throw new hb("Arguments to apply() must be all SymbolicTensors or all Tensors");return Yb(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of wb(e))t.push(n.shape);this.build(xb(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);let a=wb(r),i=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),i.push(e);if(r=xb(i),null!=this.activityRegularizer)throw new fb("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=function(e){e=wb(e);let t=[];for(let n of e)t.push(n.shape);return xb(t)}(e),a=this.computeOutputShape(r),i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new nx(i,n,this,wb(e),t,this.name,r))):new nx(i,a,this,wb(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new fb("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new cb(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new cb(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new pb(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Yv(this.weights)}build(e){this.built=!0}getWeights(){return Zv(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){ss((()=>{let t=this.weights;if(t.length!==e.length)throw new hb(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=Zv(t);for(let a=0;a<r.length;++a){let i=r[a],s=t[a],o=e[a];if(!_a.arraysEqual(i.shape,o.shape))throw new hb(`Layer weight shape ${i.shape} not compatible with provided weight shape ${o.shape}`);n.push([s,o])}ex(n)}))}addWeight(e,t,n,r,a,i,s,o){if(-1!==this._addedWeightNames.indexOf(e))throw new hb(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():Hv("zeros"));let l=r.apply(t,n),u=new Jv(l,n,e,i,s);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=wb(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=wb(t),i=wb(r);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let s=0;s<a.length;s++)a[s].kerasMask=i[s]}addInboundNode(e,t,n,r,a,i){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=wb(e);t=wb(t),n=wb(n),r=wb(r),a=qv(a),i=qv(i);let l=[],u=[],d=[];for(let c of o)l.push(c.sourceLayer),u.push(c.nodeIndex),d.push(c.tensorIndex);new ax({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:d,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:i},s);for(let c=0;c<t.length;c++)t[c].sourceLayer=this,t[c].nodeIndex=this.inboundNodes.length-1,t[c].tensorIndex=c}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function ox(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=ox(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(let e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}var lx=class extends sx{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:zb("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new hb("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new hb("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new hb("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new nx(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new ax({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new hb(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function ux(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new hb("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new lx({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}lx.className="InputLayer",Ah.registerClass(lx);var dx=class e{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(let e of t)this.add(e.key,e.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new hb(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,n){if(null==e.dtype||e.dtype===n.dtype)return n;try{return bo(n,e.dtype)}catch(t){throw new hb(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof nx){if(null==this.id2Value[e.id])throw new hb(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new hb(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof nx){if(null==this.id2Value[e.id])throw new hb(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new hb(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&os(this.id2Mask)}},cx=new gb,px=new gb;function hx(e,t,n,r){let a=null!=n&&n.training,i=Array.isArray(e),s=i?e:[e],o=s.map((e=>e.name)),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let d,c=o.join(",")+"|"+t.names().sort().join(","),p=cx.get(c);if(null==p){let e=function(e,t){_a.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=mx(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let i of e){let{sorted:e,recipientMap:s}=mx(i,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in s)null==r[t]&&(r[t]=new Set),s[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:fx(r)}}(s,t);p=e.sorted,d=e.recipientCounts,cx.put(c,p),px.put(c,d)}d={},a||Object.assign(d,px.get(c));let h=new dx(t);for(let f=0;f<p.length;++f){if(null!=r){let e=as().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=p[f],i=e.sourceLayer;if(i instanceof lx)continue;let s=[],u=[],c=[],m=!1;for(let n of e.inputs){let e=h.getValue(n),r=h.getMask(n);s.push(e),u.push(r),null!=r&&(m=!0),a||(d[n.name]--,0===d[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&c.push(e))}m&&((n=n||{}).mask=u[0]);let g=wb(i.apply(s,n)),y=null;i.supportsMasking&&(y=i.computeMask(s,u));let b=gx(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){h.hasKey(v[t])||h.add(v[t],g[t],Array.isArray(y)?y[0]:y);let e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||os(c)}return h.disposeMasks(),i?l:l[0]}function fx(e){let t={};for(let n in e)t[n]=e[n].size;return t}function mx(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let i=[],s=[];for(i.push(e);i.length>0;){let e=i[i.length-1];if(n.has(e.name)){i.pop();continue}let t=s[s.length-1]===i.length-1;if(0===e.inputs.length||t)i.pop(),r.push(e),n.add(e.name),t&&s.pop();else{s.push(i.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&i.push(t)}}return{sorted:r,recipientMap:a}}function gx(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}Ge().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=cx&&cx.setMaxEntries(e),null!=px&&px.setMaxEntries(e)}));var yx={};function bx(e,t){return ss((()=>pu(fu(Io(e,e),t,!0))))}w(yx,{maxNorm:()=>Cx,minMaxNorm:()=>$x,nonNeg:()=>Ax,unitNorm:()=>Ex});var vx=class extends Ah.Serializable{getConfig(){return{}}},xx=class extends vx{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ss((()=>{let t=bx(e,this.axis),n=xl(t,0,this.maxValue);return Io(e,So(n,wo(ov(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};xx.className="MaxNorm",Ah.registerClass(xx);var wx=class extends vx{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ss((()=>So(e,wo(ov(),bx(e,this.axis)))))}getConfig(){return{axis:this.axis}}};wx.className="UnitNorm",Ah.registerClass(wx);var kx=class extends vx{apply(e){return lc(e)}};kx.className="NonNeg",Ah.registerClass(kx);var Sx=class extends vx{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ss((()=>{let t=bx(e,this.axis),n=wo(Io(this.rate,xl(t,this.minValue,this.maxValue)),Io(1-this.rate,t));return Io(e,So(n,wo(ov(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Sx.className="MinMaxNorm",Ah.registerClass(Sx);var Ix={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Nx(e){return Nb(e)}function Tx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _b(e,Ah.SerializationMap.getMap().classNameMap,t,"constraint")}function _x(e){if(null==e)return null;if("string"==typeof e){return Tx({className:e in Ix?Ix[e]:e,config:{}})}return e instanceof vx?e:Tx(e)}function Cx(e){return new xx(e)}function Ex(e){return new wx(e)}function Ax(){return new kx}function $x(e){return new Sx(e)}var Rx={};function Fx(){return new _v}function Dx(){return new Cv}function Mx(e){return new Ev(e)}function Ox(e){return new Av(e)}function Px(e){return new $v(e)}function Lx(e){return new Rv(e)}function zx(e){return new Fv(e)}function Bx(e){return new Dv(e)}function Wx(e){return new Mv(e)}function Ux(e){return new Ov(e)}function Vx(e){return new Pv(e)}function Gx(e){return new Lv(e)}function Hx(e){return new zv(e)}function jx(e){return new Bv(e)}function qx(e){return new Wv(e)}w(Rx,{constant:()=>Mx,glorotNormal:()=>Ux,glorotUniform:()=>Wx,heNormal:()=>Vx,heUniform:()=>Gx,identity:()=>zx,leCunNormal:()=>Hx,leCunUniform:()=>jx,ones:()=>Dx,orthogonal:()=>qx,randomNormal:()=>Px,randomUniform:()=>Ox,truncatedNormal:()=>Lx,varianceScaling:()=>Bx,zeros:()=>Fx});var Kx,Xx={};async function Yx(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let i=e[a];if("number"!=typeof i){let e=i;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];os(r)}}function Qx(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}w(Xx,{Layer:()=>sx,RNN:()=>cS,RNNCell:()=>pS,activation:()=>GI,add:()=>ZI,alphaDropout:()=>VN,average:()=>eN,averagePooling1d:()=>uN,averagePooling2d:()=>pN,averagePooling3d:()=>mN,avgPool1d:()=>dN,avgPool2d:()=>hN,avgPool3d:()=>gN,avgPooling1d:()=>cN,avgPooling2d:()=>fN,avgPooling3d:()=>yN,batchNormalization:()=>sN,bidirectional:()=>MN,categoryEncoding:()=>KN,centerCrop:()=>jN,concatenate:()=>tN,conv1d:()=>MI,conv2d:()=>OI,conv2dTranspose:()=>PI,conv3d:()=>LI,conv3dTranspose:()=>zI,convLstm2d:()=>$N,convLstm2dCell:()=>RN,cropping2D:()=>WI,dense:()=>HI,depthwiseConv2d:()=>VI,dot:()=>iN,dropout:()=>jI,elu:()=>EI,embedding:()=>JI,flatten:()=>KI,gaussianDropout:()=>UN,gaussianNoise:()=>WN,globalAveragePooling1d:()=>bN,globalAveragePooling2d:()=>vN,globalMaxPool1d:()=>PN,globalMaxPool2d:()=>LN,globalMaxPooling1d:()=>xN,globalMaxPooling2d:()=>wN,gru:()=>NN,gruCell:()=>TN,input:()=>dk,inputLayer:()=>CI,layerNormalization:()=>oN,leakyReLU:()=>$I,lstm:()=>_N,lstmCell:()=>CN,masking:()=>GN,maxPool1d:()=>zN,maxPool2d:()=>BN,maxPooling1d:()=>kN,maxPooling2d:()=>SN,maxPooling3d:()=>IN,maximum:()=>nN,minimum:()=>rN,multiply:()=>aN,permute:()=>QI,prelu:()=>RI,randomWidth:()=>XN,reLU:()=>AI,repeatVector:()=>XI,rescaling:()=>HN,reshape:()=>YI,resizing:()=>qN,rnn:()=>FN,separableConv2d:()=>BI,simpleRNN:()=>EN,simpleRNNCell:()=>AN,softmax:()=>FI,spatialDropout1d:()=>qI,stackedRNNCells:()=>DN,thresholdedReLU:()=>DI,timeDistributed:()=>ON,upSampling2d:()=>UI,zeroPadding2d:()=>lN}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Kx||(Kx={}));var Jx=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},Zx=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},ew=class extends Jx{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=ss((()=>wo(this.totals[r],Io(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:ss((()=>{let e=Io(So(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),ls(t[n])})))}},tw=class extends Jx{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let i=0;i<r.length;++i)if("number"!=typeof r[i]){let s=r[i];e.push(s.data()),t.push(a),n.push(i)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},nw=class extends Jx{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Jf,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");_a.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():_a.now();return function(){let i=null!=n?n():_a.now();return i-a<t||(a=i,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await Yx(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Yx(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await Yx(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Yx(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await Yx(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):_a.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Yx(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Yx(e),await this.trainEnd(e))}};function rw(e,t){return null==e&&(e={}),e instanceof Jx?[e]:Array.isArray(e)&&e[0]instanceof Jx?e:wb(e).map((e=>new nw(e,t)))}var aw=class e{constructor(){}static registerCallbackConstructor(t,n){_a.assert(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)}static checkForDuplicate(t){for(let n in e.constructors)e.constructors[+n].forEach((e=>{if(e===t)throw new hb("Duplicate callback constructor.")}))}static clear(){e.constructors={}}static createCallbacks(t){let n=[];for(let r in e.constructors){let a=+r;t>=a&&n.push(...e.constructors[a])}return n.map((e=>new e))}};function iw(e,t,n,r,a,i,s,o,l){let u=new tw,d=[new ew,...aw.createCallbacks(t)];null!=e&&d.push(...e),d.push(u);let c=new Zx(d);return c.setParams({epochs:n,initialEpoch:r,samples:a,steps:i,batchSize:s,verbose:t,doValidation:o,metrics:l}),{callbackList:c,history:u}}function sw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return _b(e,Ah.SerializationMap.getMap().classNameMap,t,"layer",n)}function ow(e,t){return ss((()=>{"float32"!==e.dtype&&(e=bo(e,"float32"));let n=fu(vv(e),t,!0),r=vl(n.shape,ov()),a=pu(od(n,r));return So(e,a)}))}function lw(e,t){return ss((()=>ld(vv(Ku(t,e)),-1)))}function uw(e,t){return ss((()=>ld(No(Ku(t,e)),-1)))}function dw(e,t){return ss((()=>{let n=Ku(e,t),r=xl(No(e),ov(),Number.MAX_VALUE),a=No(So(n,r));return Io(100,ld(a,-1))}))}function cw(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return ss((()=>{if(n)t=_c(t);else{let e=fu(t,t.shape.length-1,!0);t=So(t,e)}return t=xl(t,ov(),1-ov()),Hu(fu(Io(bo(e,"float32"),Ou(t)),t.shape.length-1))}))}function pw(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return ss((()=>{let r=bo(Su(function(e){let t=[rv(e.shape)];return Zo(e,t)}(e)),"int32"),a=(t=xl(t,ov(),1-ov())).shape;return cw(Zo(vd(r,a[a.length-1]),a),t,n)}))}function hw(e,t){return ss((()=>{let n;return n=xl(t,ov(),1-ov()),n=Ou(So(n,Ku(1,n))),ld(function(e,t){if(!_a.arraysEqual(e.shape,t.shape))throw new hb(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ss((()=>{let n=lc(t),r=Hu(No(t));return wo(Ku(n,Io(t,e)),Pu(bu(r)))}))}(e,n),-1)}))}function fw(e,t){return ss((()=>{let n=ow(e,-1),r=ow(t,-1),a=Io(n,r);return Hu(fu(a,-1))}))}aw.constructors={};var mw={meanSquaredError:lw,meanAbsoluteError:uw,meanAbsolutePercentageError:dw,meanSquaredLogarithmicError:function(e,t){return ss((()=>{let n=xl(t,ov(),Number.MAX_VALUE),r=Ou(wo(1,n)),a=xl(e,ov(),Number.MAX_VALUE),i=Ou(wo(1,a));return ld(vv(Ku(r,i)),-1)}))},squaredHinge:function(e,t){return ss((()=>{let n=od(0,Ku(1,Io(e,t)));return ld(vv(n),-1)}))},hinge:function(e,t){return ss((()=>{let n=od(0,Ku(1,Io(e,t)));return ld(n,-1)}))},categoricalHinge:function(e,t){return ss((()=>{let n=fu(Io(e,t),-1),r=lu(Io(Ku(1,e),t),-1);return od(0,wo(1,Ku(r,n)))}))},logcosh:function(e,t){return ss((()=>{let n=Math.log(2),r=Ku(t,e),a=Ku(wo(r,ju(Io(-2,r))),n);return ld(a,-1)}))},categoricalCrossentropy:cw,sparseCategoricalCrossentropy:pw,binaryCrossentropy:hw,kullbackLeiblerDivergence:function(e,t){return ss((()=>{let n=xl(e,ov(),1),r=xl(t,ov(),1);return fu(Io(e,Ou(So(n,r))),-1)}))},poisson:function(e,t){return ss((()=>{let n=Ou(wo(ov(),t));return ld(Ku(t,Io(e,n)),-1)}))},cosineProximity:fw};function gw(e){if("string"==typeof e){if(e in mw)return mw[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new hb(t)}return e}function yw(e,t){return ss((()=>{let n=Io(.5,xd(t)),r=lv(Nu(t,n),e.dtype);return ld(Hl(e,r),-1)}))}function bw(e,t){return ss((()=>lv(Hl($o(e,-1),$o(t,-1)),"float32")))}function vw(e,t){return ss((()=>bo(fu(Qu(Hl(e,1),Hl(t,1))),"float32")))}function xw(e,t){return ss((()=>{let n=vw(e,t),r=function(e,t){return ss((()=>bo(fu(Qu(Hl(e,0),Hl(t,1))),"float32")))}(e,t),a=wo(n,r);return bo(jl(Nu(a,0),So(n,a),0),"float32")}))}function ww(e,t){return ss((()=>{let n=vw(e,t),r=function(e,t){return ss((()=>bo(fu(Qu(Hl(e,1),Hl(t,0))),"float32")))}(e,t),a=wo(n,r);return bo(jl(Nu(a,0),So(n,a),0),"float32")}))}function kw(e,t){return hw(e,t)}function Sw(e,t){return e.rank===t.rank&&(e=Dc(e,[e.rank-1])),(t=$o(t,-1)).dtype!==e.dtype&&(t=bo(t,e.dtype)),bo(Hl(e,t),"float32")}var Iw=cw,Nw=pw,Tw={binaryAccuracy:yw,categoricalAccuracy:bw,precision:xw,categoricalCrossentropy:Iw,sparseCategoricalCrossentropy:Nw,mse:lw,MSE:lw,mae:uw,MAE:uw,mape:dw,MAPE:dw,cosine:fw};function _w(e){if("string"==typeof e&&e in Tw)return Tw[e];if("string"!=typeof e&&null!=e)return e;throw new hb(`Unknown metric ${e}`)}function Cw(e){if(bb(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(mw))if(mw[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(Tw))if(Tw[n]===e){t=n;break}return void 0!==t?t:e.name}}function Ew(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Aw(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Aw(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!Aw(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!Aw(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function $w(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log,i=function(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];if(i?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!i){s.push("Receives inputs"),r=[];for(let t in e.nodesByDepth)r.push(...e.nodesByDepth[t])}a("_".repeat(t)),Rw(s,n,a),a("=".repeat(t));let o=e.layers;for(let d=0;d<o.length;++d)i?Fw(o[d],n,a):Dw(o[d],n,r,a),a((d===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=function(e){let t;return t=null!=e.collectedTrainableWeights?Yv(e.collectedTrainableWeights):Yv(e.trainableWeights),t}(e),u=Yv(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a("_".repeat(t))}function Rw(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function Fw(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(i){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(i){r="multiple"}Rw([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function Dw(e,t,n,r){let a,i;try{i=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(d){i="multiple"}try{a=JSON.stringify(e.outputShape)}catch(d){a="multiple"}let s=[];for(let c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){let t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];s.push(`${t}[${n}][${r}]`)}let o=e.name,l=e.getClassName(),u=0===s.length?"":s[0];Rw([`${o} (${l})`,i,a,e.countParams().toString(),u],t,r);for(let c=1;c<s.length;++c)Rw(["","","","",s[c]],t,r)}function Mw(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function Ow(e,t){if(null===e)return null;if("string"==typeof e)return Sb(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];Mw(t,a,r)?n.push(r):n.push(Ow(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=Sb(n);t[e]=Ow(r,e)}}return t}}function Pw(e,t){if(null==e)return null;if("string"==typeof e)return kb(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];Mw(t,a,r)?n.push(r):n.push(Pw(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=kb(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?Pw(r,n):r}return t}}var Lw="4.21.0",zw=class e extends sx{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=zb(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Eb(this.inputs).length!==this.inputs.length)throw new hb(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);Eb(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let e of this.outputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(let e of this.inputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;bb(0===n,"input layer has >1 nodes"),bb(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){let n=this.inputLayers[e];if(!(n instanceof lx))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(let e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let n={},r={},a={},i={},s={},o=[],l=(t,n,r,a,i,u)=>{(null==a||null==i||null==u)&&(a=t.sourceLayer,i=t.nodeIndex,u=t.tensorIndex);let d=a.inboundNodes[i];if(-1!==r.indexOf(d))throw new pb(`The tensor ${t.name} at layer "${a.name}" is part of a cycle.`);if(-1!==n.indexOf(d))return;this.containerNodes.add(e.nodeKey(a,i)),a.id in s||(s[a.id]=Object.keys(s).length),-1===r.indexOf(d)&&r.push(d);let c=d.inboundLayers.length;for(let e=0;e<c;e++){let t=d.inputTensors[e],a=d.inboundLayers[e],i=d.nodeIndices[e],s=d.tensorIndices[e];l(t,n,r,a,i,s)}for(n.push(d);r.indexOf(d)>=0;)r.splice(r.indexOf(d),1);o.push(d)},u=[],d=[];for(let e of this.outputs)l(e,u,d);let c=o.slice().reverse();for(let e of c){r[e.id]=e,e.id in n||(n[e.id]=0);let t=n[e.id],s=null==a[e.outboundLayer.id]?0:a[e.outboundLayer.id];t=Math.max(t,s),a[e.outboundLayer.id]=t,i[e.outboundLayer.id]=e.outboundLayer,n[e.id]=t;for(let a=0;a<e.inboundLayers.length;a++){let i=e.inboundLayers[a],s=e.nodeIndices[a],o=i.inboundNodes[s],l=null==n[o.id]?0:n[o.id];n[o.id]=Math.max(t+1,l),r[o.id]=o}}let p={};for(let e in n){let t=n[e];t in p||(p[t]=[]),p[t].push(r[e])}let h={};for(let e in a){let t=a[e];t in h||(h[t]=[]),h[t].push(i[e])}let f=Object.keys(h).map((e=>parseInt(e,10))).sort(Cb);this.layers=[];for(let b of f){let t=h[b];t.sort(((e,t)=>{let n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(let n of t)n instanceof e&&this.internalContainerRefs.push(n),this.layers.push(n)}this.layersByDepth=h,f=Object.keys(p).map((e=>parseInt(e,10))).sort(Cb);let m=this.inputs.slice(),g=[];for(let e of f)for(let t of p[e]){let e=t.outboundLayer;if(null!=e){for(let n of t.inputTensors)if(-1===m.indexOf(n))throw new pb(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${g}`);for(let e of t.outputTensors)m.push(e);g.push(e.name)}}this.nodesByDepth=p;let y=this.layers.map((e=>e.name));for(let e of y){let t=y.filter((t=>t===e)).length;if(1!==t)throw new pb(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new ax({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new hb("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n={},r=0,a=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(let s of this.layers)for(let[e,t]of s.weights.entries()){let i=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[i])throw new hb(`Duplicate weight name: ${i}`);n[i]=t,r++}let i=[];for(let s in e){let r=s;if(null==n[s]){let e=s.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])i.push([n[r],e[s]]);else if(t)throw new hb(`Provided weight data has no target variable: ${s}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new hb(`${e.length} of ${r} weights are not set: ${e}`)}ex(i)}parseWeights(e){for(let t in Object.keys(e)){let n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Lw}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=Pw(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return ss((()=>{e=wb(e);let n=new dx;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return hx(this.outputs,n,t)}))}computeMask(e,t){return ss((()=>{let n;return e=wb(e),n=null==t?yb(null,e.length):wb(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=qv(e);if(t.length!==this.inputLayers.length)throw new hb(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let s=0;s<t.length;s++){let e=this.inputLayers[s],r=t[s];n[e.name+"_0_0"]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Cb);if(r.length>1)for(let s of r){let e=this.nodesByDepth[s];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let s=0;s<t.inboundLayers.length;s++){let e=t.inboundLayers[s],a=t.nodeIndices[s],i=t.tensorIndices[s],o=n[`${e.name}_${a}_${i}`];r.push(o)}let a=qv(e.computeOutputShape(xb(r))),i=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${i}_${t}`]=a[t]}}}let a=[],i=[];for(let s=0;s<this.outputLayers.length;s++){let e=this.outputLayers[s],t=this.outputLayersNodeIndices[s],n=this.outputLayersTensorIndices[s],r=`${e.name}_${t}_${n}`;i.push(r)}for(let s=0;s<i.length;s++){let e=i[s];bb(e in n),a.push(n[e])}return xb(a)}runInternalGraph(e,t){null==t&&(t=yb(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let r=this.inputs[o],a=e[o],i=t[o];n[r.id]=[a,i]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Cb);for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,i=new Array;for(let t of r)t.id in n&&i.push(n[t.id]);if(i.length===r.length){let r,s,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===i.length){let[t,n]=i[0];null==u.mask&&(u.mask=n),o=wb(e.call(t,u)),l=wb(e.computeMask(t,n)),r=[t],s=[n]}else r=i.map((e=>e[0])),s=i.map((e=>e[1])),null==u.mask&&(u.mask=s),o=wb(e.call(r,u)),l=wb(e.computeMask(r,s));if(e.activityRegularizer)throw new fb("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],i=l[e];n[t.id]=[r,i]}}}}let a=[],i=[],s=[];for(let o of this.outputs){bb(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[e,t]=n[o.id];s.push(e.shape),a.push(e),i.push(t)}return[a,i,s]}buildNodeConversionMap(t){let n,r={};for(let a of this.layers){n=a instanceof e?1:0;for(let t=0;t<a.inboundNodes.length;t++){let i=e.nodeKey(a,t);this.containerNodes.has(i)&&(r[i]=n,n+=1)}}return r}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new hb("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let n of this.layers)if(n.name===e)return n;throw new hb(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new hb(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ss((()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=e.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t}))}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let o of this.layers){let t=o.getClassName(),a=o.getConfig(),i=[];for(let r=0;r<o.inboundNodes.length;r++){let t=o.inboundNodes[r],a=e.nodeKey(o,r),l={};if(this.containerNodes.has(a)){if(t.callArgs)try{JSON.stringify(t.callArgs),l=t.callArgs}catch(s){console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),l={}}if(t.inboundLayers.length>0){let r=[];for(let a=0;a<t.inboundLayers.length;a++){let i=t.inboundLayers[a],s=t.nodeIndices[a],o=t.tensorIndices[a],u=n[e.nodeKey(i,s)];null==u&&(u=0),r.push([i.name,u,o,l])}i.push(r)}}}let l={};l.name=o.name,l.className=t,l.config=a,l.inboundNodes=i,r.push(l)}t.layers=r;let a=[];for(let o=0;o<this.inputLayers.length;o++){let t=this.inputLayers[o],r=this.inputLayersNodeIndices[o],i=e.nodeKey(t,r);if(!this.containerNodes.has(i))continue;let s=n[i];null==s&&(s=0);let l=this.inputLayersTensorIndices[o];a.push([t.name,s,l])}t.inputLayers=a;let i=[];for(let o=0;o<this.outputLayers.length;o++){let t=this.outputLayers[o],r=this.outputLayersNodeIndices[o],a=e.nodeKey(t,r);if(!this.containerNodes.has(a))continue;let s=n[a];null==s&&(s=0);let l=this.outputLayersTensorIndices[o];i.push([t.name,s,l])}return t.outputLayers=i,t}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function s(e,t){let n,a=[];for(let s of t){let o=s[0],l=s[1],u=s[2];if(n=null==s[3]?{}:s[3],!(o in r))return void i(e,t);let d=r[o];if(d.inboundNodes.length<=l)return void i(e,t);let c=d.inboundNodes[l];a.push(c.outputTensors[u])}a.length>0&&e.apply(xb(a),n)}function o(e){let a=e.name,s=sw(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(n),r[a]=s,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new hb(`Corrupted configuration, expected array for nodeData: ${e}`);i(s,e)}))}let l=t.name,u=t.layers;for(let f of u)o(f);for(;!Ab(a);)for(let e of u){let t=r[e.name];if(t.name in a){let e=a[t.name];delete a[t.name];for(let n of e)s(t,n)}}let d=[],c=[],p=t.inputLayers;for(let f of p){let e=f[0],t=f[1],n=f[2];bb(e in r);let a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}let h=t.outputLayers;for(let f of h){let e=f[0],t=f[1],n=f[2];bb(e in r);let a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}return new e({inputs:d,outputs:c,name:l})}get stateful(){if(this._stateful)throw new hb("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ss((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function Bw(e,t){return function(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function Ww(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=ss((()=>{if(1===e.shape.length)return vo(e);if(2===e.shape.length){if(e.shape[1]>1)return $o(e,1);if(1===e.shape[1])return Zo(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());os(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),zc(a,"float32")}return null}function Uw(e,t){return Io(e,t)}function Vw(e,t){let n,r,a=t;n=a.xs,r=a.ys,_a.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let i=Gw("input",e.inputNames,n),s=Gw("output",e.outputNames,r),o=i[0].shape[0];_a.assert(i.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),_a.assert(s.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<i.length;l++)_a.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<s.length;l++)_a.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:i,ys:s}}function Gw(e,t,n){if(n instanceof li)return[n];if(Array.isArray(n))return _a.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new hb(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function Hw(e,t,n){let r=null!=n.batchesPerEpoch;if(_a.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),_a.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),_a.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),_a.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),_a.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,i,s=null!=n.validationData;if(s)if(jw(n.validationData))_a.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=function(e){if(3===e.length)throw new fb("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=s?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let d=rw(n.callbacks,n.yieldEvery),c=null==n.verbose?1:n.verbose,{callbackList:p,history:h}=iw(d,c,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,s,o);p.setModel(e),e.history=h,await p.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await p.onEpochBegin(f);let d=0,c=0;for(r||(m=await t.iterator());!r||d<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${d} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=Vw(e,t.value),i={};i.batch=c,i.size=r[0].shape[0],await p.onBatchBegin(c,i);let s=[];if(null!=n.classWeight){let t=Bw(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)s.push(await Ww(a[e],null,t[e]))}let o=r.concat(a).concat(s),h=l(o);os(o);for(let e=0;e<u.length;++e){let t=u[e],n=h[e];i[t]=n,ls(n)}await p.onBatchEnd(c,i),Qx(i),c++,d++}if(r?d>=n.batchesPerEpoch:t.done){if(s){let t;t=jw(n.validationData)?wb(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):wb(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(f,o),f++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function jw(e){return"function"==typeof e.iterator}function qw(e){_a.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function Kw(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>dv(e,t,n-t))):dv(e,t,n-t)}function Xw(e,t){return ss((()=>null==e?null:Array.isArray(e)?e.map((e=>Xw(e,t))):bv(e,"int32"===t.dtype?t:bo(t,"int32"))))}function Yw(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function Qw(e){let t=[];e instanceof li&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(uv(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Jw(e,t){if(null==e)return;let n=[];if(t instanceof li)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof li)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Zw(e){return Array.isArray(e)}function ek(e){return!function(e){return e instanceof li}(e)&&!Zw(e)}function tk(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(Zw(e)&&e.length>0)t=!0;else if(ek(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new hb(`Error when checking model ${i} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(ek(e)){r=[];for(let n of t){if(null==e[n])throw new hb(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(Zw(e)){if(e.length!==t.length)throw new hb(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new hb(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=Qw(r),null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;let e=r[s];if(e.shape.length!==n[s].length)throw new hb(`Error when checking ${i}: expected ${t[s]} to have ${n[s].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[s].length;++t){if(0===t&&!a)continue;let r=e.shape[t],o=n[s][t];if(null!=o&&o>=0&&r!==o)throw new hb(`${i} expected a batch of elements where each example has shape [${n[s].slice(1,n[s].length)}] (i.e.,tensor shape [*,${n[s].slice(1,n[s].length)}]) but the ${i} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function nk(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new hb(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new hb(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;let e=r[s];if(e.shape.length!==n[s].length)throw new hb(`Error when checking ${i}: expected ${t[s]} to have ${n[s].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[s].length;++r){if(0===r&&!a)continue;let o=e.shape[r],l=n[s][r];if(null!=l&&l!==o)throw new hb(`Error when checking ${i}: expected ${t[s]} to have shape ${JSON.stringify(n[s])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}var rk=class extends zw{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new hb("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");$w(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>Yf.adagrad(.01),Adadelta:()=>Yf.adadelta(1,.95,ov()),Adam:()=>Yf.adam(.001,.9,.999,ov()),Adamax:()=>Yf.adamax(.002,.9,.999,ov(),0),RMSProp:()=>Yf.rmsprop(.001,.9,0,ov()),SGD:()=>Yf.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new hb(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ph))throw new hb("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new hb(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>gw(e)))}else{let n=gw(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new hb(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(gw(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let e=this.internalOutputShapes[i],t=this.outputNames[i];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Yb("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Yb("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,i;for(let s of t){if("string"==typeof s&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(s)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===hw?-1!==["accuracy","acc"].indexOf(s)?r=yw:-1!==["crossentropy","ce"].indexOf(s)&&(r=kw):this.lossFunctions[e]===pw?-1!==["accuracy","acc"].indexOf(s)?r=Sw:-1!==["crossentropy","ce"].indexOf(s)&&(r=Nw):-1!==["accuracy","acc"].indexOf(s)?r=bw:-1!==["crossentropy","ce"].indexOf(s)&&(r=Iw),-1!==["accuracy","acc"].indexOf(s)?t="acc":-1!==["crossentropy","ce"].indexOf(s)&&(t="ce"),i=r,n=""+t}else i=_w(s),n=""+Cw(s);let t;Yb(n,(()=>{t=i})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=null==n.batchSize?32:n.batchSize;qw(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction;return xb(this.testLoop(t,e,r,n.verbose,n.steps))}finally{Jw(a[0],e),Jw(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,i=[];if(n.verbose>0)throw new fb("Verbose mode is not implemented yet.");_a.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let s=function(e){return"function"==typeof e.next}(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await s.next();if(i=ss((()=>{if(t.value){let{xs:n,ys:r}=Vw(e,t.value),s=n.concat(r),u=ss((()=>a(s)));if(os(s),0===l)for(let e=0;e<u.length;++e)i.push(cu(0));let d=s[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=i[e];i[e]=ss((()=>wo(i[e],Io(d,t)))),l>0&&os(n)}os(u),o+=d,++l}return i})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){let e=i[u];i[u]=So(i[u],o),os(e)}return xb(i)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new hb(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new hb(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new hb("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),i=new dx;if(e instanceof li&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new hb(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)i.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new hb(`No value is provided for the model's input ${o.name}`);i.add(o,t)}let s=hx(a,i);return n?s:s[0]}retrieveSymbolicTensors(e){let t=yb(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],i=a.map((e=>e.name));for(let r=0;r<e.length;++r){let s=i.indexOf(e[r]);if(-1!==s&&(t[r]=a[s],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new hb(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return ss((()=>{let r=this.checkNumSamples(e);if(n)throw new fb("Verbose predictLoop() is not implemented yet.");let a=Yw(r,t),i=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)ss((()=>{let n=a[t][0],r=a[t][1],i=Kw(e,n,r),s=[];if(Array.isArray(i))for(let e=0;e<i.length;++e)s.push({key:this.inputs[e],value:i[e]});else s.push({key:this.inputs[0],value:i});let o=new dx(s);return hx(this.outputs,o)})).forEach(((e,t)=>i[t].push(e)));return xb(i.map((e=>nl(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=Qw(e);nk(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return qw(e),this.predictLoop(n,e)}finally{Jw(n,e)}}predictOnBatch(e){nk(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new pb("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let a=0;a<this.feedOutputShapes.length;++a){let e=this.feedOutputShapes[a];this.feedLossFns[a]===pw?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){let n=Eb(e.map((e=>e.shape[0])));n.sort();let r=Eb(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new hb(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new hb(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!_a.arraysEqual(n,r))throw new hb(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=tk(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=tk(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){let r=[lw,hw,cw];for(let a=0;a<e.length;++a){let i=e[a],s=t[a],o=n[a];if(null!=s){if(s===cw&&1===i.shape[i.shape.length-1])throw new hb(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(s)){let e=i.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new hb(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new hb(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=arguments.length>5?arguments[5]:void 0,[s,o]=this.standardizeUserDataXY(e,t,a,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=Bw(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await Ww(o[t],null,e[t]))}return[s,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return ss((()=>{let i=this.checkNumSamples(t,n,a,"steps"),s=[];if(r>0)throw new fb("Verbose mode is not implemented yet.");if(null!=a)throw new fb("steps mode in testLoop() is not implemented yet");{let r=Yw(i,n),a=zc(sv(0,i));for(let n=0;n<r.length;++n){let i=r[n][0],o=r[n][1],l=dv(a,i,o-i),u=Xw(t,l),d=e(u);if(0===n)for(let e=0;e<d.length;++e)s.push(cu(0));for(let e=0;e<d.length;++e){let t=d[e];s[e]=wo(s[e],Io(o-i,t))}}for(let e=0;e<s.length;++e)s[e]=So(s[e],i)}return s}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(vb(e,r)>1){a+=`_${vb(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],s=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let s,o=new dx(e),l=hx(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],l[n]);null!=a[n]&&(e=Uw(e,a[n]));let i=ld(e);t.push(i),s=0===n?e:wo(s,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=ld(t(r[a],l[a]))}ls(e),i.push(e)}return s=ld(s),this.calculateLosses().forEach((e=>{s=wo(s,e)})),s}),!0,s)].concat(i)}}makeTestFunction(){this.testFunction=e=>ss((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:r[e]});let s=new dx(i),o=hx(this.outputs,s);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],i=ld(r(a[e],o[e]));t=0===e?i:wo(t,i),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],i=ld(t(a[r],o[r]));n.push(i)}return n}))}async fit(e,t){let n,r,a,i,s,o,l,u,d,c=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let p=null==c.batchSize?32:c.batchSize;qw(p);let h=await this.standardizeUserData(e,t,c.sampleWeight,c.classWeight,!1,p);n=h[0],r=h[1],d=h[2];let f,m=!1;if(null!=c.validationData&&c.validationData.length>0){if(m=!0,2!==c.validationData.length)throw 3===c.validationData.length?new fb("validationData including sample weights is not supported yet."):new hb(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${c.validationData} is invalid.`);s=c.validationData[0],o=c.validationData[1];let e=await this.standardizeUserData(s,o,null,null,!0,p);l=e[0],u=e[1],f=l.concat(u)}else if(null!=c.validationSplit&&c.validationSplit>0&&c.validationSplit<1){m=!0;let e=Math.floor(n[0].shape[0]*(1-c.validationSplit)),t=n[0].shape[0];l=Kw(n,e,t),a=n,n=Kw(n,0,e),u=Kw(r,e,t),i=r,r=Kw(r,0,e),f=l.concat(u)}else null!=c.validationSteps&&(m=!0);let g=n.concat(r).concat(d);this.checkTrainableWeightsConsistency();let y,b,v=this.makeTrainFunction(),x=this.getDedupedMetricsNames();m?(this.makeTestFunction(),y=this.testFunction,b=x.slice().concat(x.map((e=>"val_"+e)))):(y=null,f=[],b=x.slice());let w=rw(c.callbacks,c.yieldEvery);return await this.fitLoop(v,g,x,p,c.epochs,c.verbose,w,y,f,c.shuffle,b,c.initialEpoch,null,null)}finally{this.isTraining=!1,Jw(n,e),Jw(r,t),Jw(a,e),Jw(i,t),Jw(l,s),Jw(u,o),null!=d&&os(d)}}async fitLoop(e,t,n,r,a,i,s,o,l,u,d,c,p,h){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==c&&(c=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=h&&(f=!0,null==p))throw new hb("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,r,p,"steps_per_epoch");null!=g&&(m=sv(0,g)),null==i&&(i=1);let{callbackList:y,history:b}=iw(s,i,a,c,g,p,r,f,d);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=c;v<a;++v){await y.onEpochBegin(v);let a={};if(null!=p)throw new fb("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new fb("batch shuffling is not implemneted yet");u&&_a.shuffle(m);let i=zc(m),s=Yw(g,r);for(let u=0;u<s.length;++u){let d={};if(await y.onBatchBegin(u,d),ss((()=>{let c=s[u][0],p=s[u][1],h=dv(i,c,p-c);d.batch=u,d.size=p-c;let m=Xw(t,h),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];d[t]=r,ls(r)}if(u===s.length-1&&f){let e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){let r=n[t],i=e[t];ls(i),a["val_"+r]=i}}})),await y.onBatchEnd(u,d),Qx(d),this.stopTraining_)break}i.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Hw(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],i=this.makeTrainFunction()(r.concat(a)),s=[];for(let o of i){let e=await o.data();s.push(e[0])}return os(i),Jw(n[0],e),Jw(n[1],t),xb(s)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let i=0;i<r.length;++i)n&&!r[i].trainable||t.push({name:r[i].originalName,tensor:a[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=as().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-as().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=kb(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>kb(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=kb(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[kb(Cw(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>kb(Cw(e))));{let e={};for(let t in this.metrics)e[t]=kb(Cw(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=sw(Ow(e.optimizer_config));if("string"==typeof e.loss)t=Sb(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>Sb(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=Sb(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>Sb(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=Sb(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:r})}async save(e,t){if("string"==typeof e){let t=jh.getSaveHandlers(e);if(0===t.length)throw new hb(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new hb(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new hb("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await jh.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Lw}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:a}=await jh.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=jh.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(Ew(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){Ew(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};rk.className="Model",Ah.registerClass(rk);var ak=class extends rk{};async function ik(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=sw(Ow(n),t);if(null!=e.weightsManifest){let t=await jh.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(let e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),os(t)}return r}async function sk(e,t){if(null==t&&(t={}),"string"==typeof e){let n=jh.getLoadHandlers(e,t);if(0===n.length)n.push(jh.browserHTTPRequest(e,t));else if(n.length>1)throw new hb(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new hb("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let i=null==n.strict||n.strict,s=null!=r.weightData&&null!=r.weightSpecs&&i,o=sw(Ow(a),t,s),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new hb("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=function(e,t){let n=jh.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);o.loadWeights(e,i),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),os(e),os(t.map((e=>e.tensor)))}return o}(e,void 0,t)}ak.className="Functional",Ah.registerClass(ak);var ok=class e extends rk{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:zb("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new hb(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n,r=t instanceof e||t instanceof rk;if(r){if(n=t,1!==n.outputs.length)throw new hb("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new hb("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new hb("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let e=ux({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new hb(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new hb("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=ox(this.outputs[0])}this.inboundNodes=[],new ax({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:yb(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Xv(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new rk({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,n){let r,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new hb("Legacy serialization format not supported yet.");r=n}else _a.assert(null!=n.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),r=n.layers,delete n.layers,i=n;let s=new t(i);if(!(s instanceof e))throw new fb(`Sequential.fromConfig called on non-Sequential input: ${s}`);for(let e of r){let t=sw(e,void 0,a);a&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(e){if(null==this.model)throw new hb("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new hb("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function lk(e){return new rk(e)}function uk(e){return new ok(e)}function dk(e){return ux(e)}function ck(e,t){aw.registerCallbackConstructor(e,t)}ok.className="Sequential",Ah.registerClass(ok);var pk=class extends Ah.Serializable{getConfig(){return{}}},hk=class extends pk{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new fb(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Ql(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}};hk.className="elu",Ah.registerClass(hk);var fk=class extends pk{apply(e){return yc(e)}};fk.className="selu",Ah.registerClass(fk);var mk=class extends pk{apply(e){return lc(e)}};mk.className="relu",Ah.registerClass(mk);var gk=class extends pk{apply(e){return ss((()=>pd(6,lc(e))))}};gk.className="relu6",Ah.registerClass(gk);var yk=class extends pk{apply(e){return e}};yk.className="linear",Ah.registerClass(yk);var bk=class extends pk{apply(e){return al(e)}};bk.className="sigmoid",Ah.registerClass(bk);var vk=class extends pk{apply(e){return function(e){return ss((()=>{let t=wo(.5,Io(.2,e));return xl(t,0,1)}))}(e)}};vk.className="hardSigmoid",Ah.registerClass(vk);var xk=class extends pk{apply(e){return ju(e)}};xk.className="softplus",Ah.registerClass(xk);var wk=class extends pk{apply(e){return function(e){return ss((()=>So(e,wo(No(e),1))))}(e)}};wk.className="softsign",Ah.registerClass(wk);var kk=class extends pk{apply(e){return sl(e)}};kk.className="tanh",Ah.registerClass(kk);var Sk=class extends pk{apply(e){return _c(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};Sk.className="softmax",Ah.registerClass(Sk);var Ik=class extends pk{apply(e){return Xu(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};Ik.className="logSoftmax",Ah.registerClass(Ik);var Nk=class extends pk{apply(e){return ss((()=>ss((()=>{let t=Math.sqrt(2),n=Io(.5,wo(1,Zl(So(e,t))));return Io(e,n)}))))}};Nk.className="gelu",Ah.registerClass(Nk);var Tk=class extends pk{apply(e){return ss((()=>Io(.5,Io(e,wo(1,sl(Io(pu(So(2,Math.PI)),wo(e,Io(.044715,du(e,3))))))))))}};Tk.className="gelu_new",Ah.registerClass(Tk);var _k=class extends pk{apply(e){return ss((()=>Io(e,sl(ju(e)))))}};_k.className="mish",Ah.registerClass(_k);var Ck=class extends pk{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return ss((()=>Io(al(Io(e,t)),e)))}};function Ek(e){return e.getClassName()}function Ak(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _b(e,Ah.SerializationMap.getMap().classNameMap,t,"activation")}function $k(e){if(null==e){let e={className:"linear",config:{}};return Ak(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},Ak(t)}return e instanceof pk?e:Ak(e)}function Rk(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}Ck.className="swish",Ah.registerClass(Ck);var Fk=class extends Ah.Serializable{},Dk=class extends Fk{constructor(e){super(),Rk(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return ss((()=>{let t=ud([1]);return this.hasL1&&(t=wo(t,fu(Io(this.l1,No(e))))),this.hasL2&&(t=wo(t,fu(Io(this.l2,vv(e))))),Zo(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Dk.className="L1L2",Ah.registerClass(Dk);var Mk={l1l2:"L1L2"};function Ok(e){return Nb(e)}function Pk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _b(e,Ah.SerializationMap.getMap().classNameMap,t,"regularizer")}function Lk(e){if(null==e)return null;if("string"==typeof e){return Pk({className:e in Mk?Mk[e]:e,config:{}})}return e instanceof Fk?e:Pk(e)}var zk=class extends sx{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Kv(e);let n=lc(e);return null!=this.maxValue&&(n=xl(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};zk.className="ReLU",Ah.registerClass(zk);var Bk=class extends sx{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Kv(e);return $u(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Bk.className="LeakyReLU",Ah.registerClass(Bk);var Wk=class extends sx{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Hv(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Lk(e.alphaRegularizer),this.alphaConstraint=_x(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new hb(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){let t=(e=Xv(e)).slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new tx({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Kv(e),Ed(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Gv(this.alphaInitializer),alphaRegularizer:Ok(this.alphaRegularizer),alphaConstraint:Nx(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};Wk.className="PReLU",Ah.registerClass(Wk);var Uk=class extends sx{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new fb(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Kv(e);return Ql(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Uk.className="ELU",Ah.registerClass(Uk);var Vk=class extends sx{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=Kv(e);return Io(n,bo(Nu(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};Vk.className="ThresholdedReLU",Ah.registerClass(Vk);var Gk=class extends sx{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Sk).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return ss((()=>{let n=Kv(e),r=t.mask;if(null!=r){let e=Io(Ku(dd(n.shape),bo(r,n.dtype)),cu(-1e9));n=wo(n,e)}return this.axis instanceof Array?this.axis.length>1?bu(Ku(n,Yu(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function Hk(e,t,n){if("number"==typeof e)return yb(e,t);if(e.length!==t)throw new hb(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!nv(a))throw new hb(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function jk(e,t,n,r){let a;return null==e?e:(a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r))}function qk(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+iv([n-t,0]);else{if("same"!==r)throw new hb(`Unsupport padding mode: ${r}.`);e*=t}return e}function Kk(e,t){return ss((()=>(jb(t),"channelsFirst"===t?sp(e,[0,2,3,1]):e)))}function Xk(e,t){return ss((()=>(jb(t),"channelsFirst"===t?sp(e,[0,2,3,4,1]):e)))}function Yk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return ss((()=>{if(null==i&&(i="channelsLast"),jb(i),3!==e.rank&&4!==e.rank)throw new hb(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new hb(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=Kk(e,i);if("causal"===a)throw new fb("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=mp.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:s,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(l=sp(l,[0,3,1,2])),l}))}Gk.className="Softmax",Ah.registerClass(Gk);var Qk=class e extends sx{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyArgs(n),this.rank=t,Fb(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new fb(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Hk(n.kernelSize,t,"kernelSize"),this.strides=Hk(null==n.strides?1:n.strides,t,"strides"),this.padding=null==n.padding?"valid":n.padding,qb(this.padding),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,jb(this.dataFormat),this.activation=$k(n.activation),this.useBias=null==n.useBias||n.useBias,this.biasInitializer=Hv(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=_x(n.biasConstraint),this.biasRegularizer=Lk(n.biasRegularizer),this.activityRegularizer=Lk(n.activityRegularizer),this.dilationRate=Hk(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new hb(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new hb(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new hb(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(bb("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!Rb(e.kernelSize,"number",1,3))throw new hb(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ek(this.activation),useBias:this.useBias,biasInitializer:Gv(this.biasInitializer),biasRegularizer:Ok(this.biasRegularizer),activityRegularizer:Ok(this.activityRegularizer),biasConstraint:Nx(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Jk=class e extends Qk{constructor(t,n){super(t,n),this.kernel=null,e.verifyArgs(n),this.filters=n.filters,Fb(this.filters,"filters"),this.kernelInitializer=Hv(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=_x(n.kernelConstraint),this.kernelRegularizer=Lk(n.kernelRegularizer)}build(e){e=Xv(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new hb(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return ss((()=>{e=Kv(e);let t,n=null==this.bias?null:this.bias.read(),r=Mb(this.activation.getClassName());if(null!=r&&2===this.rank)t=Yk(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return ss((()=>{if(null==i&&(i="channelsLast"),jb(i),3!==e.shape.length)throw new hb(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new hb(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new hb(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===i&&(e=sp(e,[0,2,1])),"causal"===a)throw new fb("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Tl(e,t,r,"same"===a?"same":"valid","NWC",s);return null!=n&&(o=wv(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Yk(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new fb("convolutions greater than 3D are not implemented yet.");t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0;return ss((()=>{if(null==i&&(i="channelsLast"),jb(i),4!==e.rank&&5!==e.rank)throw new hb(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new hb(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Xk(e,i);if("causal"===a)throw new fb("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=El(o,t,r,"same"===a?"same":"valid","NDHWC",s),null!=n&&(o=wv(o,n)),"channelsFirst"===i&&(o=sp(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Xv(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=jk(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:Gv(this.kernelInitializer),kernelRegularizer:Ok(this.kernelRegularizer),kernelConstraint:Nx(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new hb(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Zk=class e extends Jk{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Rb(e.kernelSize,"number",1,2))throw new hb(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};Zk.className="Conv2D",Ah.registerClass(Zk);var eS=class e extends Jk{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new hb(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};eS.className="Conv3D",Ah.registerClass(eS);var tS=class extends Zk{constructor(e){if(super(e),this.inputSpec=[new tx({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new hb(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Xv(e)).length)throw new hb("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new hb("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new tx({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ss((()=>{let t=Kv(e);if(4!==t.shape.length)throw new hb(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,i=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let s=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],d=this.strides[0],c=this.strides[1],p=[i,qk(s,d,l,this.padding),qk(o,c,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=sp(t,[0,2,3,1]));let h=Cl(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(h=sp(h,[0,3,1,2])),null!=this.bias&&(h=wv(h,this.bias.read(),this.dataFormat)),null!=this.activation&&(h=this.activation.apply(h)),h}))}computeOutputShape(e){let t,n,r,a=(e=Xv(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let i=this.kernelSize[0],s=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=qk(a[n],o,i,this.padding),a[r]=qk(a[r],l,s,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};tS.className="Conv2DTranspose",Ah.registerClass(tS);var nS=class extends eS{constructor(e){if(super(e),this.inputSpec=[new tx({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new hb(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Xv(e)).length)throw new hb("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new hb("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new tx({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ss((()=>{let t=Kv(e);if(5!==t.shape.length)throw new hb(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,i=t.shape,s=i[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=i[a],l=i[n],u=i[r],d=this.kernelSize[0],c=this.kernelSize[1],p=this.kernelSize[2],h=this.strides[0],f=this.strides[1],m=this.strides[2],g=[s,qk(o,h,d,this.padding),qk(l,f,c,this.padding),qk(u,m,p,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=sp(t,[0,2,3,4,1]));let y=$l(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=sp(y,[0,4,1,2,3])),null!==this.bias&&(y=wv(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){let t,n,r,a,i=(e=Xv(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let s=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],d=this.strides[1],c=this.strides[2];return i[t]=this.filters,i[n]=qk(i[n],u,s,this.padding),i[r]=qk(i[r],d,o,this.padding),i[a]=qk(i[a],c,l,this.padding),i}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};nS.className="Conv3DTranspose",Ah.registerClass(nS);var rS=class extends Jk{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new hb("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new hb("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new hb(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Hv(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Lk(t.depthwiseRegularizer),this.depthwiseConstraint=_x(t.depthwiseConstraint),this.pointwiseInitializer=Hv(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Lk(t.pointwiseRegularizer),this.pointwiseConstraint=_x(t.pointwiseConstraint)}build(e){if((e=Xv(e)).length<this.rank+2)throw new hb(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new hb(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let s=0;s<this.rank;++s)a.push(1);a.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new tx({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ss((()=>{let t;if(e=Kv(e),1===this.rank)throw new fb("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=sp(e,[0,2,3,1])),t=bc(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=wv(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=sp(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Gv(this.depthwiseInitializer),e.pointwiseInitializer=Gv(this.pointwiseInitializer),e.depthwiseRegularizer=Ok(this.depthwiseRegularizer),e.pointwiseRegularizer=Ok(this.pointwiseRegularizer),e.depthwiseConstraint=Nx(this.depthwiseConstraint),e.pointwiseConstraint=Nx(this.pointwiseConstraint),e}};rS.className="SeparableConv";var aS=class extends rS{constructor(e){super(2,e)}};aS.className="SeparableConv2D",Ah.registerClass(aS);var iS=class e extends Jk{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Rb(e.kernelSize,"number",1,1))throw new hb(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};iS.className="Conv1D",Ah.registerClass(iS);var sS=class extends sx{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ss((()=>{if(e=Kv(e),"channelsLast"===this.dataFormat){let t=pv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return pv(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=pv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return pv(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};sS.className="Cropping2D",Ah.registerClass(sS);var oS=class extends sx{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,jb(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){$b(Wb,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ss((()=>{let t=Kv(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=sp(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?Nh.resizeNearestNeighbor(t,[e,r]):Nh.resizeBilinear(t,[e,r]);return sp(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?Nh.resizeNearestNeighbor(t,[e,r]):Nh.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};oS.className="UpSampling2D",Ah.registerClass(oS);var lS=class extends Qk{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Hv(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=_x(e.depthwiseConstraint),this.depthwiseRegularizer=Lk(e.depthwiseRegularizer)}build(e){if((e=Xv(e)).length<4)throw new hb(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new hb(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ss((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0;return ss((()=>{null==a&&(a="channelsLast"),jb(a);let s=Kk(e,a);if(4!==e.rank)throw new hb(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new hb(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return s=Ll(s,t,n,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===a&&(s=sp(s,[0,3,1,2])),s}))}(e=Kv(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=wv(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Xv(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=jk(t,this.kernelSize[0],this.padding,this.strides[0]),i=jk(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,i]:[e[0],a,i,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Gv(this.depthwiseInitializer),e.depthwiseRegularizer=Ok(this.depthwiseRegularizer),e.depthwiseConstraint=Nx(this.depthwiseRegularizer),e}};function uS(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new hb("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function dS(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return ss((()=>{let l=t.shape.length;if(l<3)throw new hb(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(sv(2,l));if(t=sp(t,u),null!=i)throw new fb("The rnn() functoin of the deeplearn.js backend does not support constants yet.");s&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=bo(bo(a,"bool"),"float32"),a.rank===l-1&&(a=vu(a,-1)),a=sp(a,u)),r&&(t=dc(t,0),null!=a&&(a=dc(a,0)));let d,c,p,h=[],f=n,m=t.shape[0],g=ep(t);null!=a&&(c=ep(a));for(let t=0;t<m;++t){let n=g[t],r=ss((()=>e(n,f)));if(null==a)d=r[0],f=r[1];else{let e=ss((()=>{let e=c[t],n=Ku(xd(e),e);return{output:wo(Io(r[0],e),Io(f[0],n)),newStates:f.map(((t,a)=>wo(Io(r[1][a],e),Io(t,n))))}}));d=e.output,f=e.newStates}o&&h.push(d)}return o&&(p=Mc(h,1)),[d,p,f]}))}lS.className="DepthwiseConv2D",Ah.registerClass(lS);var cS=class e extends sx{constructor(e){let t;if(super(e),null==e.cell)throw new hb("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new vS({cells:e.cell}):e.cell,null==t.stateSize)throw new hb("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new tx({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return sv(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){jv(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return ss((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new fb("Constants support is not implemented in RNN yet.");jv(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new tx({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!_a.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new hb(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new tx({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];ss((()=>{if(!this.stateful)throw new cb("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new hb("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>ud([n,e]))):this.states_=[ud([n,this.cell.stateSize])];else if(null==e)os(this.states_),null!=this.keptStates&&(os(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>ud([n,e]))):this.states_[0]=ud([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new hb(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):os(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,i=[n,a];if(!_a.arraysEqual(r.shape,i))throw new hb(`State ${t} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>ls(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=uS(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let i=[],s=[];if(null!=n){t.initialState=n,i=i.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new tx({shape:e.shape}));s=s.concat(this.stateSpec)}if(null!=r&&(t.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof nx){let n=[e].concat(i),r=this.inputSpec.concat(s),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return ss((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=Kv(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new hb(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let s={training:r},o=dS(((e,t)=>{let n=this.cell.call([e].concat(t),s);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],d=o[2];this.stateful&&this.resetStates(d,r);let c=this.returnSequences?u:l;return this.returnState?[c].concat(d):c}))}getInitialState(e){return ss((()=>{let t=ud(e.shape);return t=fu(t,[1,2]),t=uv(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?mv(t,[1,e]):t)):this.cell.stateSize>1?[mv(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===e.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=sw(t.cell,n);return new e(Object.assign(t,{cell:r}))}};cS.className="RNN",Ah.registerClass(cS);var pS=class extends sx{},hS=class extends pS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Fb(this.units,"units"),this.activation=$k(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Hv(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Hv(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Hv(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Lk(e.kernelRegularizer),this.recurrentRegularizer=Lk(e.recurrentRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.kernelConstraint=_x(e.kernelConstraint),this.recurrentConstraint=_x(e.recurrentConstraint),this.biasConstraint=_x(e.biasConstraint),this.dropout=av([1,iv([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=av([1,iv([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xv(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ss((()=>{if(2!==e.length)throw new hb(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>xd(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>xd(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,i=this.dropoutMask,s=this.recurrentDropoutMask;a=yv(null!=i?Io(e,i):e,this.kernel.read()),null!=this.bias&&(a=wv(a,this.bias.read())),null!=s&&(n=Io(n,s));let o=wo(a,yv(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ek(this.activation),useBias:this.useBias,kernelInitializer:Gv(this.kernelInitializer),recurrentInitializer:Gv(this.recurrentInitializer),biasInitializer:Gv(this.biasInitializer),kernelRegularizer:Ok(this.kernelRegularizer),recurrentRegularizer:Ok(this.recurrentRegularizer),biasRegularizer:Ok(this.biasRegularizer),activityRegularizer:Ok(this.activityRegularizer),kernelConstraint:Nx(this.kernelConstraint),recurrentConstraint:Nx(this.recurrentConstraint),biasConstraint:Nx(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};hS.className="SimpleRNNCell",Ah.registerClass(hS);var fS=class extends cS{constructor(e){e.cell=new hS(e),super(e)}call(e,t){return ss((()=>{null!=this.cell.dropoutMask&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};fS.className="SimpleRNN",Ah.registerClass(fS);var mS=class extends pS{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new hb("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Fb(this.units,"units"),this.activation=$k(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$k(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Hv(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Hv(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Hv(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Lk(e.kernelRegularizer),this.recurrentRegularizer=Lk(e.recurrentRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.kernelConstraint=_x(e.kernelConstraint),this.recurrentConstraint=_x(e.recurrentConstraint),this.biasConstraint=_x(e.biasConstraint),this.dropout=av([1,iv([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=av([1,iv([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=Xv(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ss((()=>{if(2!==e.length)throw new hb(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>xd(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>xd(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,i,s,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=Io(e,o[0]));let u=yv(e,this.kernel.read());this.useBias&&(u=wv(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Io(r,l[0]));let d=this.recurrentKernel.read(),[c,p]=$c(d,[2*this.units,this.units],d.rank-1),h=yv(r,c),[f,m,g]=$c(u,3,u.rank-1),[y,b]=$c(h,2,h.rank-1);a=this.recurrentActivation.apply(wo(f,y)),i=this.recurrentActivation.apply(wo(m,b));let v=yv(Io(i,r),p);s=this.activation.apply(wo(g,v));let x=wo(Io(a,r),Io(wo(1,Hu(a)),s));return[x,x]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ek(this.activation),recurrentActivation:Ek(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Gv(this.kernelInitializer),recurrentInitializer:Gv(this.recurrentInitializer),biasInitializer:Gv(this.biasInitializer),kernelRegularizer:Ok(this.kernelRegularizer),recurrentRegularizer:Ok(this.recurrentRegularizer),biasRegularizer:Ok(this.biasRegularizer),activityRegularizer:Ok(this.activityRegularizer),kernelConstraint:Nx(this.kernelConstraint),recurrentConstraint:Nx(this.recurrentConstraint),biasConstraint:Nx(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};mS.className="GRUCell",Ah.registerClass(mS);var gS=class extends cS{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mS(e),super(e)}call(e,t){return ss((()=>{null!=this.cell.dropoutMask&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};gS.className="GRU",Ah.registerClass(gS);var yS=class extends pS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Fb(this.units,"units"),this.activation=$k(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$k(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Hv(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Hv(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Hv(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Lk(e.kernelRegularizer),this.recurrentRegularizer=Lk(e.recurrentRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.kernelConstraint=_x(e.kernelConstraint),this.recurrentConstraint=_x(e.recurrentConstraint),this.biasConstraint=_x(e.biasConstraint),this.dropout=av([1,iv([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=av([1,iv([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,r=(e=Xv(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new((t=class extends Tv{apply(t,n){let a=e.apply([r]),i=(new Cv).apply([r]),s=e.apply([2*r]);return fv(fv(a,i),s)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ss((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new hb(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>xd(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>xd(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i,s,o,l,u=this.dropoutMask,d=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=Io(e,u[0]));let c=yv(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Io(r,d[0])),c=wo(c,yv(r,this.recurrentKernel.read())),this.useBias&&(c=wv(c,this.bias.read()));let[p,h,f,m]=$c(c,4,c.rank-1);i=this.recurrentActivation.apply(p),s=this.recurrentActivation.apply(h),o=wo(Io(s,a),Io(i,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=Io(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ek(this.activation),recurrentActivation:Ek(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Gv(this.kernelInitializer),recurrentInitializer:Gv(this.recurrentInitializer),biasInitializer:Gv(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ok(this.kernelRegularizer),recurrentRegularizer:Ok(this.recurrentRegularizer),biasRegularizer:Ok(this.biasRegularizer),activityRegularizer:Ok(this.activityRegularizer),kernelConstraint:Nx(this.kernelConstraint),recurrentConstraint:Nx(this.recurrentConstraint),biasConstraint:Nx(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};yS.className="LSTMCell",Ah.registerClass(yS);var bS=class extends cS{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new yS(e),super(e)}call(e,t){return ss((()=>{null!=this.cell.dropoutMask&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};bS.className="LSTM",Ah.registerClass(bS);var vS=class extends pS{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ss((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,i=[];for(let s=0;s<this.cells.length;++s){let o=this.cells[s];n=r[s],a=0===s?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),i.push(a.slice(1))}n=[];for(let e of i.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;jv(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{Yb(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=[];for(let a of t.cells)r.push(sw(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Zv(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}ex(t)}};function xS(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:i}=e,s=()=>null!=i?i(t(),n):kv(t(),n),o=()=>Sv(s,t,r);return!a||a<=1?ls(o().clone()):Array(a).fill(void 0).map(o).map((e=>ls(e.clone())))}vS.className="StackedRNNCells",Ah.registerClass(vS);var wS=class extends cS{constructor(e){if(e.unroll)throw new fb("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new fb("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new tx({ndim:5})]}call(e,t){return ss((()=>{if(null!=this.cell.dropoutMask&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new hb("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ss((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=ud([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];ss((()=>{if(!this.stateful)throw new cb("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new hb("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>ud(a))):this.states_=[ud(a)];else if(null==e)os(this.states_),null!=this.keptStates&&(os(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>ud(a))):this.states_[0]=ud(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new hb(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):os(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!_a.arraysEqual(n.shape,r))throw new hb(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>ls(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:i,dilationRate:s}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],d=jk(l,r[0],a,i[0],s[0]),c=jk(u,r[1],a,i[1],s[1]);return[...e.slice(0,2),...o?[n,d,c]:[d,c,n]]}};wS.className="ConvRNN2D";var kS=class extends yS{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:i,dilationRate:s}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Fb(this.filters,"filters"),this.kernelSize=Hk(n,2,"kernelSize"),this.kernelSize.forEach((e=>Fb(e,"kernelSize"))),this.strides=Hk(r||1,2,"strides"),this.strides.forEach((e=>Fb(e,"strides"))),this.padding=a||"valid",qb(this.padding),this.dataFormat=i||"channelsLast",jb(this.dataFormat),this.dilationRate=Hk(s||1,2,"dilationRate"),this.dilationRate.forEach((e=>Fb(e,"dilationRate")))}build(e){var t;e=Xv(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new hb(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new((t=class extends Tv{apply(e,t){return hv([n.apply([r]),dd([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ss((()=>{if(3!==e.length)throw new hb(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],i=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>xd(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,o=(e,t,n)=>t&&t[n]?Io(t[n],e):e,l=o(r,s,0),u=o(r,s,1),d=o(r,s,2),c=o(r,s,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>xd(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,h=o(a,p,0),f=o(a,p,1),m=o(a,p,2),g=o(a,p,3),[y,b,v,x]=$c(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?$c(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),d=this.inputConv(d,v,S,this.padding),c=this.inputConv(c,x,I,this.padding);let[N,T,_,C]=$c(this.recurrentKernel.read(),4,3);h=this.recurrentConv(h,N),f=this.recurrentConv(f,T),m=this.recurrentConv(m,_),g=this.recurrentConv(g,C);let E=this.recurrentActivation.apply(wo(l,h)),A=this.recurrentActivation.apply(wo(u,f)),$=wo(Io(A,i),Io(E,this.activation.apply(wo(d,m)))),R=Io(this.recurrentActivation.apply(wo(c,g)),this.activation.apply($));return[R,R,$]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=Nl(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?wv(a,n,this.dataFormat):a}recurrentConv(e,t){return Nl(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};kS.className="ConvLSTM2DCell",Ah.registerClass(kS);var SS=class extends wS{constructor(e){let t=new kS(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};SS.className="ConvLSTM2D",Ah.registerClass(SS);var IS=class extends sx{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return Sv((()=>kv(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};IS.className="Dropout",Ah.registerClass(IS);var NS=class extends IS{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};NS.className="SpatialDropout1D",Ah.registerClass(NS);var TS=class extends sx{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Fb(this.units,"units"),this.activation=$k(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Hv(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Hv(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=_x(e.kernelConstraint),this.biasConstraint=_x(e.biasConstraint),this.kernelRegularizer=Lk(e.kernelRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.activityRegularizer=Lk(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=Xv(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=Xv(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n,r=Kv(e),a=Mb(this.activation.getClassName());return null!=a?n=yv(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=yv(r,this.kernel.read()),null!=this.bias&&(n=wv(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:Ek(this.activation),useBias:this.useBias,kernelInitializer:Gv(this.kernelInitializer),biasInitializer:Gv(this.biasInitializer),kernelRegularizer:Ok(this.kernelRegularizer),biasRegularizer:Ok(this.biasRegularizer),activityRegularizer:Ok(this.activityRegularizer),kernelConstraint:Nx(this.kernelConstraint),biasConstraint:Nx(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};TS.className="Dense",Ah.registerClass(TS);var _S=class extends sx{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Xv(e);for(let t of e.slice(1))if(null==t)throw new hb(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],rv(e,1)]}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=sp(n,e)}return function(e){if(e.rank<=1)throw new hb(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],rv(e.shape,1)];return Zo(e,t)}(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};_S.className="Flatten",Ah.registerClass(_S);var CS=class extends sx{constructor(e){super(e),this.supportsMasking=!0,this.activation=$k(e.activation)}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e);return this.activation.apply(n)}))}getConfig(){let e={activation:Ek(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};CS.className="Activation",Ah.registerClass(CS);var ES=class extends sx{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ss((()=>function(e,t){return ss((()=>{if(2!==e.shape.length)throw new hb(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return mv(uv(e,1),[1,t,1])}))}(e=Kv(e),this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};ES.className="RepeatVector",Ah.registerClass(ES);var AS=class extends sx{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,i=null;for(let o=0;o<r.length;++o){let e=r[o];if(this.isUnknown(e)){if(null!==i)throw new hb("Can only specifiy one unknown dimension.");i=o}else a*=e}let s=rv(e);if(null!==i){if(0===a||s%a!==0)throw new hb(n);r[i]=s/a}else if(s!==a)throw new hb(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Zo(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};AS.className="Reshape",Ah.registerClass(AS);var $S=class extends sx{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=sv(1,e.dims.length+1);if(!_a.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new tx({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=Xv(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return sp(Kv(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};$S.className="Permute",Ah.registerClass($S);var RS=class extends sx{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Kv(e);return Ao(bd(n,this.maskValue),-1)}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e),r=Ao(bd(n,this.maskValue),-1,!0);return Io(n,bo(r,n.dtype))}))}};RS.className="Masking",Ah.registerClass(RS);var FS=class extends sx{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(wb(e.inputLength))}this.inputDim=e.inputDim,Fb(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Fb(this.outputDim,"outputDim"),this.embeddingsInitializer=Hv(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Lk(e.embeddingsRegularizer),this.activityRegularizer=Lk(e.activityRegularizer),this.embeddingsConstraint=_x(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ss((()=>this.maskZero?(e=Kv(e),bd(e,ql(e))):null))}computeOutputShape(e){if(e=Xv(e),null==this.inputLength)return[...e,this.outputDim];let t=wb(this.inputLength);if(t.length!==e.length-1)throw new hb(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],i=e[r+1];if(null!=a&&null!=i&&a!==i)throw new hb(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e);"int32"!==n.dtype&&(n=lv(n,"int32"));let r=bv(this.embeddings.read(),Zo(n,[n.size]));return Zo(r,Xv(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Gv(this.embeddingsInitializer),embeddingsRegularizer:Ok(this.embeddingsRegularizer),activityRegularizer:Ok(this.activityRegularizer),embeddingsConstraint:Nx(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};FS.className="Embedding",Ah.registerClass(FS);var DS=class extends sx{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new fb}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],i=t[r];if(null==a||null==i||a<0||i<0)n.push(null);else if(1===a)n.push(i);else if(1===i)n.push(a);else{if(a!==i)throw new hb("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Xv(e)]),e.length<2)throw new hb(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=Eb(t),t.length>1)throw new hb(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===Eb(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ss((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=iv(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=uv(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let i of e){let e=i.rank;if(null==e){let e=i.shape,r=e[0],a=e.slice(1).concat([r]),s=Zo(i,[r].concat(rv(e.slice(1))));s=sp(s,[1,0]),s=Zo(s,a),t.push(s),n=!0}else if(e>1){let r=sv(1,e).concat([0]);t.push(sp(i,r)),n=!0}else t.push(i)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Zo(sp(Zo(r,[-1,t]),[1,0]),n)}else if(a>1){let e=[a-1].concat(sv(0,a-1));r=sp(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=Eb(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return ss((()=>{if(null==t)return null;if(!Array.isArray(t))throw new hb("`mask` should be an Array");if(!Array.isArray(e))throw new hb("`inputs` should be an Array");if(t.length!==e.length)throw new hb(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:vu(e,0))))[0];for(let e=1;e<t.length-1;++e)n=Qu(n,t[e]);return n}))}},MS=class extends DS{constructor(e){super(e)}mergeFunction(e){return ss((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=wo(t,e[n]);return t}))}};MS.className="Add",Ah.registerClass(MS);var OS=class extends DS{constructor(e){super(e)}mergeFunction(e){return ss((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Io(t,e[n]);return t}))}};OS.className="Multiply",Ah.registerClass(OS);var PS=class extends DS{constructor(e){super(e)}mergeFunction(e){return ss((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=wo(t,e[n]);return Io(1/e.length,t)}))}};PS.className="Average",Ah.registerClass(PS);var LS=class extends DS{constructor(e){super(e)}mergeFunction(e){return ss((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=od(t,e[n]);return t}))}};LS.className="Maximum",Ah.registerClass(LS);var zS=class extends DS{constructor(e){super(e)}mergeFunction(e){return ss((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=pd(t,e[n]);return t}))}};zS.className="Minimum",Ah.registerClass(zS);var BS=class extends DS{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new hb("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(_a.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new hb("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ss((()=>hv(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new hb("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new hb("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new hb("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new hb(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ss((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let i=0;i<e.length;++i)null==t[i]?r.push(bo(xd(e[i]),"bool")):t[i].rank<e[i].rank?r.push(vu(t[i],-1)):r.push(t[i]);let a=nl(r,this.axis);return Eo(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function WS(e,t){for(;e<0;)e+=t;return e}BS.className="Concatenate",Ah.registerClass(BS);var US=class extends DS{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){_a.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new fb("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new hb(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new hb(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>WS(t,e[n].shape.length))):[WS(this.axes,n.shape.length),WS(this.axes,r.shape.length)],this.normalize&&(n=ow(n,t[0]),r=ow(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new fb("batchDot is not implemented for tensors of 4D or higher rank yet");if(_a.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),_a.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new fb("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let i=n;return ss((()=>{let n,s;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=Zo(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=Zo(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)s=i[0]===i[1]?fu(Io(e,t),i[0]):fu(Io(sp(e,[1,0]),t),i[1]);else{let n=i[0]!==e.shape.length-1,r=i[1]===t.shape.length-1;s=rl(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);s=Dc(s,t)}return 1===s.shape.length&&(s=vu(s,1)),s}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[WS(this.axes,e.length),WS(this.axes,t.length)],n}computeOutputShape(e){_a.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new fb("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};US.className="Dot",Ah.registerClass(US);var VS=class extends sx{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e);return Sv((()=>wo(gv(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};VS.className="GaussianNoise",Ah.registerClass(VS);var GS=class extends sx{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ss((()=>{this.invokeCallHook(e,t);let n=Kv(e);return this.rate>0&&this.rate<1?Sv((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return Io(n,gv(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};GS.className="GaussianDropout",Ah.registerClass(GS);var HS=class extends sx{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Kv(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ss((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Sv((()=>{let t=Kv(e),r=-1.7580993408473766,a=Tu(rc(n),this.rate);a=lv(a,"float32");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,s=-i*r*this.rate,o=wo(Io(t,a),Io(wo(a,-1),r));return wo(Io(o,i),s)}),(()=>Kv(e)),t.training||!1)}return e}))}};function jS(e,t,n,r,a){let i,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)i=cl(e,t,n,r,a,s);else if(3===e.rank)i=pl(e,t,n,r,a,s);else{if(4!==e.rank)throw new fb(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=hl(e,t,n,r,a,s)}return i}function qS(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return _a.arraysEqual(r.slice().sort(),sv(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return ss((()=>{let i=md(e,r),s=i.mean,o=i.variance;return[jS(e,s,o,n,t,a),s,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return ss((()=>{let i=md(e,r),s=i.mean,o=i.variance,l=[];for(let t of sv(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=Zo(s,l),d=Zo(o,l),c=null==t?null:Zo(t,l),p=null==n?null:Zo(n,l);return[jS(e,u,d,p,c,a),s,o]}))}(e,t,n,r,a)}HS.className="AlphaDropout",Ah.registerClass(HS);var KS=class extends sx{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Hv(e.betaInitializer||"zeros"),this.gammaInitializer=Hv(e.gammaInitializer||"ones"),this.movingMeanInitializer=Hv(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Hv(e.movingVarianceInitializer||"ones"),this.betaConstraint=_x(e.betaConstraint),this.gammaConstraint=_x(e.gammaConstraint),this.betaRegularizer=Lk(e.betaRegularizer),this.gammaRegularizer=Lk(e.gammaRegularizer)}build(e){e=Xv(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new hb(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new tx({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ss((()=>{let n=null!=t.training&&t.training,r=Kv(e),a=r.shape,i=a.length,s=sv(0,i),o=this.axis>=0?this.axis:this.axis+i;s.splice(o,1);let l=yb(1,i);l[o]=a[o];let u=s.slice();u.sort();let d=!_a.arraysEqual(u,sv(0,i).slice(0,i-1));if(!n)return(()=>{if(d){let e=Zo(this.movingMean.read(),l),t=Zo(this.movingVariance.read(),l),n=this.center?Zo(this.beta.read(),l):null,a=this.scale?Zo(this.gamma.read(),l):null;return jS(r,e,t,n,a,this.epsilon)}return jS(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[c,p,h]=qS(r,this.gamma.read(),this.beta.read(),s,this.epsilon),f=(e,t,n)=>{ss((()=>{let r=1-n,a=e.read(),i=Io(Ku(a,t),r);e.write(Ku(a,i))}))};return f(this.movingMean,p,this.momentum),f(this.movingVariance,h,this.momentum),c}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Gv(this.betaInitializer),gammaInitializer:Gv(this.gammaInitializer),movingMeanInitializer:Gv(this.movingMeanInitializer),movingVarianceInitializer:Gv(this.movingVarianceInitializer),betaRegularizer:Ok(this.betaRegularizer),gammaRegularizer:Ok(this.gammaRegularizer),betaConstraint:Nx(this.betaConstraint),gammaConstraint:Nx(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};KS.className="BatchNormalization",Ah.registerClass(KS);var XS=class extends sx{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Hv(e.betaInitializer||"zeros"),this.gammaInitializer=Hv(e.gammaInitializer||"ones"),this.betaRegularizer=Lk(e.betaRegularizer),this.gammaRegularizer=Lk(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=Xv(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Eb(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Kv(e),r=n.shape,a=r.length;return ss((()=>{let{mean:e,variance:t}=md(n,this.axis,!0),i=yb(1,a);for(let n of this.axis)i[n]=r[n];let s=e=>null!=e&&e.shape.length!==a?Zo(e,i):e,o=this.scale?s(this.gamma.read()):null,l=this.center?s(this.beta.read()):null,u=[],d=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),d.push(1)):(u.push(1),d.push(r[n]));return e=wu(e,u),t=wu(t,u),null!=o&&(o=wu(o,d)),null!=l&&(l=wu(l,d)),jS(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Gv(this.betaInitializer),gammaInitializer:Gv(this.gammaInitializer),betaRegularizer:Ok(this.betaRegularizer),gammaRegularizer:Ok(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};XS.className="LayerNormalization",Ah.registerClass(XS);var YS=class extends sx{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new hb(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new hb(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new hb(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new tx({ndim:4})]}computeOutputShape(e){let t,n;return e=Xv(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return ss((()=>function(e,t,n){return ss((()=>{if(4!==e.rank)throw new hb(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new hb("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new hb(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],kd(e,r)}))}(Kv(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function QS(e,t,n,r,a,i){return ss((()=>{jb(a),Kb(i),qb(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==i&&(i="max"),e=Kk(e,a);let s,o="same"===r?"same":"valid";return s="max"===i?ad(e,t,n,o):el(e,t,n,o),"channelsFirst"===a&&(s=sp(s,[0,3,1,2])),s}))}function JS(e,t,n,r,a,i){return ss((()=>{jb(a),Kb(i),qb(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==i&&(i="max"),e=Xk(e,a);let s,o="same"===r?"same":"valid";return s="max"===i?id(e,t,n,o):tl(e,t,n,o),"channelsFirst"===a&&(s=sp(s,[0,4,1,2,3])),s}))}YS.className="ZeroPadding2D",Ah.registerClass(YS);var ZS=class extends sx{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new hb(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(Fb(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new hb(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}Fb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,qb(this.padding),this.inputSpec=[new tx({ndim:3})]}computeOutputShape(e){let t=jk((e=Xv(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ss((()=>{this.invokeCallHook(e,t),e=uv(Kv(e),2);let n=this.poolingFunction(Kv(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Dc(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},eI=class extends ZS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return jb(a),qb(r),QS(e,t,n,r,a,"max")}};eI.className="MaxPooling1D",Ah.registerClass(eI);var tI=class extends ZS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return jb(a),qb(r),QS(e,t,n,r,a,"avg")}};tI.className="AveragePooling1D",Ah.registerClass(tI);var nI=class extends sx{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new hb(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Fb(this.poolSize,"poolSize"),Fb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,jb(this.dataFormat),qb(this.padding),this.inputSpec=[new tx({ndim:4})]}computeOutputShape(e){e=Xv(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=jk(t,this.poolSize[0],this.padding,this.strides[0]),n=jk(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ss((()=>(this.invokeCallHook(e,t),this.poolingFunction(Kv(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},rI=class extends nI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return jb(a),qb(r),QS(e,t,n,r,a,"max")}};rI.className="MaxPooling2D",Ah.registerClass(rI);var aI=class extends nI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return jb(a),qb(r),QS(e,t,n,r,a,"avg")}};aI.className="AveragePooling2D",Ah.registerClass(aI);var iI=class extends sx{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new hb(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Fb(this.poolSize,"poolSize"),Fb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,jb(this.dataFormat),qb(this.padding),this.inputSpec=[new tx({ndim:5})]}computeOutputShape(e){e=Xv(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=jk(t,this.poolSize[0],this.padding,this.strides[0]),n=jk(n,this.poolSize[1],this.padding,this.strides[1]),r=jk(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ss((()=>(this.invokeCallHook(e,t),this.poolingFunction(Kv(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},sI=class extends iI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return jb(a),qb(r),JS(e,t,n,r,a,"max")}};sI.className="MaxPooling3D",Ah.registerClass(sI);var oI=class extends iI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return jb(a),qb(r),JS(e,t,n,r,a,"avg")}};oI.className="AveragePooling3D",Ah.registerClass(oI);var lI=class extends sx{constructor(e){super(e),this.inputSpec=[new tx({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new fb}},uI=class extends lI{constructor(e){super(e||{})}call(e,t){return ss((()=>{let t=Kv(e);return ld(t,1)}))}};uI.className="GlobalAveragePooling1D",Ah.registerClass(uI);var dI=class extends lI{constructor(e){super(e||{})}call(e,t){return ss((()=>{let t=Kv(e);return lu(t,1)}))}};dI.className="GlobalMaxPooling1D",Ah.registerClass(dI);var cI=class extends sx{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,jb(this.dataFormat),this.inputSpec=[new tx({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new fb}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},pI=class extends cI{call(e,t){return ss((()=>{let t=Kv(e);return"channelsLast"===this.dataFormat?ld(t,[1,2]):ld(t,[2,3])}))}};pI.className="GlobalAveragePooling2D",Ah.registerClass(pI);var hI=class extends cI{call(e,t){return ss((()=>{let t=Kv(e);return"channelsLast"===this.dataFormat?lu(t,[1,2]):lu(t,[2,3])}))}};hI.className="GlobalMaxPooling2D",Ah.registerClass(hI);var fI=class extends sx{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=sw(t.layer,n);delete t.layer;let a={layer:r};return Object.assign(a,t),new e(a)}},mI=class extends fI{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Xv(e)).length<3)throw new hb(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=Xv(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return ss((()=>dS(((e,n)=>[Kv(this.layer.call(e,t)),[]]),e=Kv(e),[],!1,null,null,!1,!0)[1]))}};mI.className="TimeDistributed",Ah.registerClass(mI);var gI=class extends fI{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=sw(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=sw(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){$b(Gb,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new fb("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):xb(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=uS(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let i=[],s=[];if(null!=n){let e=n.length;if(e%2>0)throw new hb("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);let r=n.map((e=>new tx({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),s.push(...r)}if(null!=r)throw new fb("Support for constants in Bidirectional layers is not implemented yet.");let o=i[0]instanceof nx;for(let l of i)if(l instanceof nx!==o)throw new hb("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(i),r=this.inputSpec.concat(s),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return ss((()=>{let n,r,a,i,s=t.initialState;if(null==s)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=s.slice(0,s.length/2),i=s.slice(s.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=dc(r,1)),"concat"===this.mergeMode?i=hv([n,r]):"sum"===this.mergeMode?i=wo(n,r):"ave"===this.mergeMode?i=Io(.5,wo(n,r)):"mul"===this.mergeMode?i=Io(n,r):null==this.mergeMode&&(i=[n,r]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Yb(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Yb(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=sw(t.layer);if(delete t.layer,null!=t.numConstants)throw new fb("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};gI.className="Bidirectional",Ah.registerClass(gI);var yI=class extends sx{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ss((()=>("float32"!==(e=Kv(e)).dtype&&(e=lv(e,"float32")),wo(Io(e,this.scale),this.offset))))}};yI.className="Rescaling",Ah.registerClass(yI);var{resizeBilinear:bI,cropAndResize:vI}=Nh,xI=class extends sx{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,i,s,o){return ss((()=>{let l,u=!1,d=[t/i,n/s,(r+t)/i,(a+n)/s],c=[];3===e.rank?(u=!0,l=Mc([e])):l=e;for(let e=0;e<l.shape[0];e++)c.push(d);let p=Xi(c,[c.length,4]),h=ic(0,c.length,1,"int32"),f=vI(l,p,h,[r,a],"nearest");return lv(u?Kv(ep(f)):f,o)}))}upsize(e,t,n,r){return ss((()=>lv(bI(e,[t,n]),r)))}call(e,t){return ss((()=>{let t=Kv(e),n=t.dtype,r=t.shape,a=r[r.length-3],i=r[r.length-2],s=0;a!==this.height&&(s=Math.floor((a-this.height)/2));let o=0;return i!==this.width&&(o=Math.floor((i-this.width)/2),0===o&&(o=1)),s>=0&&o>=0?this.centerCrop(t,s,o,this.height,this.width,a,i,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Xv(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};xI.className="CenterCrop",Ah.registerClass(xI);var wI=class extends sx{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=Xv(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ss((()=>{let n;if("int32"!==(e=Kv(e)).dtype&&(e=lv(e,"int32")),"undefined"!=typeof t.countWeights){if("count"!==this.outputMode)throw new hb(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Kv(t.countWeights)}let r=lu(e),a=uu(e),i=Nu(this.numTokens,r).bufferSync().get(0),s=Tu(a,0).bufferSync().get(0);if(!i||!s)throw new hb(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=Kv(e);if("int32"!==a.dtype&&(a=lv(a,"int32")),"int"===t)return a;let i=a.shape;if(0===a.rank&&(a=vu(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=vu(a,-1)),a.rank>2)throw new hb(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${a.rank}.`);let s,o=["multiHot","oneHot"].includes(t),l=a;if(s=Ol(l,"undefined"!=typeof r&&"count"===t?r:[],n,o),"tfIdf"!==t)return s;if(r)return Io(s,r);throw new hb("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}};wI.className="CategoryEncoding",Ah.registerClass(wI);var kI=new Set(["bilinear","nearest"]),SI=class extends sx{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!kI.has(e.interpolation))throw new hb(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=Xv(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ss((()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return Nh.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Nh.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...kI]} are supported`)}))}};SI.className="Resizing",Ah.registerClass(SI);var II=class{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}};II.className="RandomSeed";var NI=class extends sx{constructor(e){super(e),this.randomGenerator=new II(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};NI.className="BaseRandomLayer";var TI=new Set(["bilinear","nearest"]),_I=class extends NI{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new hb(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new hb(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new hb(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!TI.has(n))throw new hb(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Xv(e))[2];return[this.imgHeight,-1,t]}call(e,t){return ss((()=>{let t=Kv(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=rc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Nh.resizeBilinear(e,a);case"nearest":return Nh.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...TI]} are supported`)}}))}};function CI(e){return new lx(e)}function EI(e){return new Uk(e)}function AI(e){return new zk(e)}function $I(e){return new Bk(e)}function RI(e){return new Wk(e)}function FI(e){return new Gk(e)}function DI(e){return new Vk(e)}function MI(e){return new iS(e)}function OI(e){return new Zk(e)}function PI(e){return new tS(e)}function LI(e){return new eS(e)}function zI(e){return new nS(e)}function BI(e){return new aS(e)}function WI(e){return new sS(e)}function UI(e){return new oS(e)}function VI(e){return new lS(e)}function GI(e){return new CS(e)}function HI(e){return new TS(e)}function jI(e){return new IS(e)}function qI(e){return new NS(e)}function KI(e){return new _S(e)}function XI(e){return new ES(e)}function YI(e){return new AS(e)}function QI(e){return new $S(e)}function JI(e){return new FS(e)}function ZI(e){return new MS(e)}function eN(e){return new PS(e)}function tN(e){return new BS(e)}function nN(e){return new LS(e)}function rN(e){return new zS(e)}function aN(e){return new OS(e)}function iN(e){return new US(e)}function sN(e){return new KS(e)}function oN(e){return new XS(e)}function lN(e){return new YS(e)}function uN(e){return new tI(e)}function dN(e){return uN(e)}function cN(e){return uN(e)}function pN(e){return new aI(e)}function hN(e){return pN(e)}function fN(e){return pN(e)}function mN(e){return new oI(e)}function gN(e){return mN(e)}function yN(e){return mN(e)}function bN(e){return new uI(e)}function vN(e){return new pI(e)}function xN(e){return new dI(e)}function wN(e){return new hI(e)}function kN(e){return new eI(e)}function SN(e){return new rI(e)}function IN(e){return new sI(e)}function NN(e){return new gS(e)}function TN(e){return new mS(e)}function _N(e){return new bS(e)}function CN(e){return new yS(e)}function EN(e){return new fS(e)}function AN(e){return new hS(e)}function $N(e){return new SS(e)}function RN(e){return new kS(e)}function FN(e){return new cS(e)}function DN(e){return new vS(e)}function MN(e){return new gI(e)}function ON(e){return new mI(e)}_I.className="RandomWidth",Ah.registerClass(_I);var PN=xN,LN=wN,zN=kN,BN=SN;function WN(e){return new VS(e)}function UN(e){return new GS(e)}function VN(e){return new HS(e)}function GN(e){return new RS(e)}function HN(e){return new yI(e)}function jN(e){return new xI(e)}function qN(e){return new SI(e)}function KN(e){return new wI(e)}function XN(e){return new _I(e)}var YN={};function QN(e,t){return yw(e,t)}function JN(e,t){return kw(e,t)}function ZN(e,t){return Sw(e,t)}function eT(e,t){return bw(e,t)}function tT(e,t){return Iw(e,t)}function nT(e,t){return xw(e,t)}function rT(e,t){return ww(e,t)}function aT(e,t){return fw(e,t)}function iT(e,t){return uw(e,t)}function sT(e,t){return dw(e,t)}function oT(e,t){return dw(e,t)}function lT(e,t){return dw(e,t)}function uT(e,t){return lw(e,t)}function dT(e,t){return lw(e,t)}function cT(e,t){return lw(e,t)}function pT(e,t){return function(e,t){return ss((()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return cu(1).sub(n.div(r))}))}(e,t)}w(YN,{MAPE:()=>oT,MSE:()=>dT,binaryAccuracy:()=>QN,binaryCrossentropy:()=>JN,categoricalAccuracy:()=>eT,categoricalCrossentropy:()=>tT,cosineProximity:()=>aT,mape:()=>lT,meanAbsoluteError:()=>iT,meanAbsolutePercentageError:()=>sT,meanSquaredError:()=>uT,mse:()=>cT,precision:()=>nT,r2Score:()=>pT,recall:()=>rT,sparseCategoricalAccuracy:()=>ZN});var hT={};w(hT,{modelFromJSON:()=>ik});var fT={};function mT(e){return new Dk(e)}function gT(e){return function(e){return Rk(e),new Dk({l1:null!=e?e.l1:null,l2:0})}(e)}function yT(e){return function(e){return Rk(e),new Dk({l2:null!=e?e.l2:null,l1:0})}(e)}w(fT,{l1:()=>gT,l1l2:()=>mT,l2:()=>yT});var bT=class extends Jx{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof rk))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function vT(e,t){return e<t}function xT(e,t){return e>t}var wT=class extends bT{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new fb("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=vT:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=xT:this.monitorFunc=vT,this.monitorFunc===vT&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===vT?1/0:-1/0}async onEpochEnd(e,t){await Yx(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};var kT,ST,IT={earlyStopping:function(e){return new wT(e)}};Ge().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(kT||(kT={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(ST||(ST={}));var NT={};function TT(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};NT[e]=n}function _T(e){return NT[e]}function CT(e){delete NT[e]}function ET(e,t,n,r,a){let i=t.inputParams[e];if(i&&void 0!==i.inputIndexStart){let e=i.inputIndexStart,s=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?e+1:i.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===i.type)return AT(t.inputNames[o],n,r,a);if("tensors"===i.type){let i=t.inputs.slice(e,s);return t.inputNames.slice(e,s).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=i[t])||void 0===n?void 0:n.op)})).map((e=>AT(e,n,r,a)))}let l=AT(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===i.type?u[0]:_a.toNestedArray(l.shape,u)}let s=t.attrParams[e];return s&&s.value}function AT(e,t,n,r){let[a,i]=DT(e,n);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let s=n.currentContextIds.find((e=>!!t[FT(a,e)]));return void 0!==s?t[FT(a,s)][i]:void 0}function $T(e,t,n){return t[FT(e,n.currentContextId)]}function RT(e,t){let[n,r,a]=DT(e,t);return[FT(n,t&&t.currentContextId),r,a]}function FT(e,t){return t?`${e}-${t}`:e}function DT(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let r,a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function MT(e,t,n){let r=ET("pad",e,t,n);if("explicit"===r){r=ET("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function OT(e){return e.kept?e:vo(e)}var PT={};w(PT,{json:()=>LT});var LT=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zT={};w(zT,{json:()=>BT});var BT=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],WT={};w(WT,{json:()=>UT});var UT=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],VT={};w(VT,{json:()=>GT});var GT=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],HT={};w(HT,{json:()=>jT});var jT=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],qT={};w(qT,{json:()=>KT});var KT=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],XT={};w(XT,{json:()=>YT});var YT=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],QT={};w(QT,{json:()=>JT});var JT=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ZT={};w(ZT,{json:()=>e_});var e_=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],t_={};w(t_,{json:()=>n_});var n_=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],r_={};w(r_,{json:()=>a_});var a_=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],i_={};w(i_,{json:()=>s_});var s_=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],o_={};w(o_,{json:()=>l_});var l_=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],u_={};w(u_,{json:()=>d_});var d_=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],c_={};w(c_,{json:()=>p_});var p_=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],h_={};w(h_,{json:()=>f_});var f_=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],m_={};w(m_,{json:()=>g_});var g_=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],y_={};w(y_,{json:()=>b_});var b_=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],v_={};w(v_,{json:()=>x_});var x_=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],w_=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[PT,zT,WT,VT,HT,qT,XT,QT,ZT,t_,r_,i_,o_,u_,c_,h_,m_,y_,v_].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.node,r=[],a=[],i=[],s=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&i.push(e[t.name]),e)),{}),o=[],l=[],u={},d={};null!=t&&(u=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));let c=Object.keys(s);c.forEach((e=>{let t=s[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=RT(e),i=s[r];if(null!=i.outputs){let e=i.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)}))})),0===Object.keys(d).length?c.forEach((e=>{let t=s[e];0===t.children.length&&l.push(t)})):Object.keys(d).forEach((e=>{let[t]=RT(e),n=s[t];null!=n&&(n.signatureKey=d[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=RT(e),n=s[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let p={};null!=e.library&&null!=e.library.function&&(p=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let h={nodes:s,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:p};return i.length>0&&(h.initNodes=i),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=_T(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=S_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=S_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=F_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=F_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=N_(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=N_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=R_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=R_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=I_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=I_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=M_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=M_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=$_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=$_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=D_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=D_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=C_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=C_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=E_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=E_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=__(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=__(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));let a=[],i=[];e.signature.inputArg.forEach((e=>{let[t]=RT(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:T_(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n})),Object.keys(r).forEach((e=>{let t=r[e];t.inputNames.forEach(((e,n)=>{let[a,,i]=RT(e),s=r[a];if(null!=s.outputs){let e=s.outputs.indexOf(i);if(-1!==e){let r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(s),s.children.push(t)}))}));let s=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=RT(s[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,i.push(a))}));let o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:i,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function k_(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=Ge().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function S_(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return null!=a?k_(a.s,r):n}function I_(e,t,n){let r=e[t];return r?r.b:n}function N_(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function T_(e){switch("string"==typeof e&&(e=kT[e]),e){case kT.DT_FLOAT:case kT.DT_HALF:return"float32";case kT.DT_INT32:case kT.DT_INT64:case kT.DT_INT8:case kT.DT_UINT8:return"int32";case kT.DT_BOOL:return"bool";case kT.DT_DOUBLE:return"float32";case kT.DT_STRING:return"string";case kT.DT_COMPLEX64:case kT.DT_COMPLEX128:return"complex64";default:return null}}function __(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function C_(e,t,n){let r=e[t];return r&&r.type?T_(r.type):n}function E_(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>T_(e))):n}function A_(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function $_(e,t,n){let r=e[t];return r&&r.shape?A_(r.shape):n}function R_(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function F_(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>k_(e,r))):n}function D_(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>A_(e))):n}function M_(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var O_=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return AT(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return AT(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return N_(this.node.rawAttrs,e,t);if(null!=n.s)return S_(this.node.rawAttrs,e,t);if(null!=n.b)return I_(this.node.rawAttrs,e,t);if(null!=n.shape)return $_(this.node.rawAttrs,e,t);if(null!=n.type)return C_(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return R_(this.node.rawAttrs,e,t);if(null!=n.list.s)return F_(this.node.rawAttrs,e,t);if(null!=n.list.shape)return D_(this.node.rawAttrs,e,t);if(null!=n.list.b)return M_(this.node.rawAttrs,e,t);if(null!=n.list.type)return E_(this.node.rawAttrs,e,t)}return t}},P_={};w(P_,{OP_SCOPE_SUFFIX:()=>Hi,abs:()=>No,acos:()=>To,acosh:()=>_o,add:()=>wo,addN:()=>Co,all:()=>Eo,any:()=>Ao,argMax:()=>$o,argMin:()=>Ro,asin:()=>Fo,asinh:()=>Do,atan:()=>Mo,atan2:()=>Oo,atanh:()=>Po,avgPool:()=>el,avgPool3d:()=>tl,basicLSTMCell:()=>ol,batchNorm:()=>dl,batchNorm2d:()=>cl,batchNorm3d:()=>pl,batchNorm4d:()=>hl,batchToSpaceND:()=>ll,bincount:()=>fl,bitwiseAnd:()=>ml,booleanMaskAsync:()=>ip,broadcastArgs:()=>gl,broadcastTo:()=>yl,buffer:()=>yo,cast:()=>bo,ceil:()=>bl,clipByValue:()=>xl,clone:()=>vo,complex:()=>qi,concat:()=>nl,concat1d:()=>wl,concat2d:()=>kl,concat3d:()=>Sl,concat4d:()=>Il,conv1d:()=>Tl,conv2d:()=>Nl,conv2dTranspose:()=>Cl,conv3d:()=>El,conv3dTranspose:()=>$l,cos:()=>Rl,cosh:()=>Fl,cosineWindow:()=>hp,cumprod:()=>Dl,cumsum:()=>Ml,denseBincount:()=>Ol,depthToSpace:()=>Pl,depthwiseConv2d:()=>Ll,diag:()=>zl,dilation2d:()=>Bl,div:()=>So,divNoNan:()=>Kl,dot:()=>Xl,dropout:()=>cp,einsum:()=>Yl,elu:()=>Ql,enclosingPowerOfTwo:()=>pp,ensureShape:()=>Jl,equal:()=>Hl,erf:()=>Zl,euclideanNorm:()=>yu,exp:()=>bu,expandDims:()=>vu,expm1:()=>xu,eye:()=>ku,fft:()=>Cc,fill:()=>vl,floor:()=>Su,floorDiv:()=>ko,fused:()=>mp,gather:()=>Iu,gatherND:()=>dp,greater:()=>Nu,greaterEqual:()=>Tu,ifft:()=>Ec,imag:()=>_u,image:()=>Nh,inTopKAsync:()=>fp,irfft:()=>Ac,isFinite:()=>Cu,isInf:()=>Eu,isNaN:()=>Au,leakyRelu:()=>$u,less:()=>Ru,lessEqual:()=>Fu,linalg:()=>Th,linspace:()=>Du,localResponseNormalization:()=>Mu,log:()=>Ou,log1p:()=>Pu,logSigmoid:()=>qu,logSoftmax:()=>Xu,logSumExp:()=>Yu,logicalAnd:()=>Qu,logicalNot:()=>Ju,logicalOr:()=>Zu,logicalXor:()=>ed,losses:()=>_h,lowerBound:()=>rd,matMul:()=>rl,max:()=>lu,maxPool:()=>ad,maxPool3d:()=>id,maxPoolWithArgmax:()=>sd,maximum:()=>od,mean:()=>ld,meshgrid:()=>cd,min:()=>uu,minimum:()=>pd,mirrorPad:()=>hd,mod:()=>fd,moments:()=>md,movingAverage:()=>op,mul:()=>Io,multiRNNCell:()=>gd,multinomial:()=>yd,neg:()=>Hu,norm:()=>gu,notEqual:()=>bd,oneHot:()=>vd,ones:()=>dd,onesLike:()=>xd,op:()=>ji,outerProduct:()=>wd,pad:()=>kd,pad1d:()=>Sd,pad2d:()=>Id,pad3d:()=>Nd,pad4d:()=>Td,pool:()=>Cd,pow:()=>du,prelu:()=>Ed,print:()=>xo,prod:()=>Ad,raggedGather:()=>$d,raggedRange:()=>Rd,raggedTensorToTensor:()=>Fd,rand:()=>Dd,randomGamma:()=>ec,randomNormal:()=>tc,randomStandardNormal:()=>nc,randomUniform:()=>rc,randomUniformInt:()=>ac,range:()=>ic,real:()=>sc,reciprocal:()=>oc,relu:()=>lc,relu6:()=>uc,reshape:()=>Zo,reverse:()=>dc,reverse1d:()=>cc,reverse2d:()=>pc,reverse3d:()=>hc,reverse4d:()=>fc,rfft:()=>Rc,round:()=>mc,rsqrt:()=>gc,scalar:()=>cu,scatterND:()=>lp,searchSorted:()=>nd,selu:()=>yc,separableConv2d:()=>bc,setdiff1dAsync:()=>vc,sigmoid:()=>al,sign:()=>xc,signal:()=>Ih,sin:()=>wc,sinh:()=>kc,slice:()=>il,slice1d:()=>Sc,slice2d:()=>Ic,slice3d:()=>Nc,slice4d:()=>Tc,softmax:()=>_c,softplus:()=>ju,spaceToBatchND:()=>_d,sparse:()=>Ch,sparseToDense:()=>up,spectral:()=>Sh,split:()=>$c,sqrt:()=>pu,square:()=>hu,squaredDifference:()=>Fc,squeeze:()=>Dc,stack:()=>Mc,step:()=>Oc,stridedSlice:()=>Pc,string:()=>Eh,sub:()=>Ku,sum:()=>fu,tan:()=>Lc,tanh:()=>sl,tensor:()=>Xi,tensor1d:()=>zc,tensor2d:()=>Bc,tensor3d:()=>Wc,tensor4d:()=>Uc,tensor5d:()=>Vc,tensor6d:()=>Gc,tensorScatterUpdate:()=>Xc,tile:()=>wu,topk:()=>Yc,transpose:()=>sp,truncatedNormal:()=>Qc,unique:()=>Jc,unsortedSegmentSum:()=>Zc,unstack:()=>ep,upperBound:()=>tp,variable:()=>np,where:()=>jl,whereAsync:()=>ap,zeros:()=>ud,zerosLike:()=>ql});function L_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!=typeof e&&"number"!=typeof t){_a.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],i=t[r];_a.assert(a<0||i<0||a===i,(()=>n+` Shapes ${e} and ${t} must match`))}}}function z_(e){return!("number"==typeof e||e.some((e=>e<0)))}function B_(e,t,n){let r=W_(e,n),a=!z_(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=W_(e.shape,r)})),!z_(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function W_(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],i=t[r];if(a>=0&&i>=0&&a!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:i}return n}var U_=class{constructor(e,t,n,r,a,i,s){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=s,this.tensors=[],this.closed_=!1,this.idTensor=cu(0),ls(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),L_(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,ls(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Xi([],[0].concat(this.elementShape));let n=this.readMany(e);return L_(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Mc(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Xi([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return L_(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),nl(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,ep(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,i=[];ss((()=>{t=Zo(t,[1,n,a]);for(let n=0;n<e.length;++n){let s=[0,0===n?0:r[n-1],0],o=[1,e[n],a];i[n]=Zo(il(t,s,o),this.elementShape)}return i}));let s=[];for(let o=0;o<e.length;o++)s[o]=o;this.writeMany(s,i)}},V_=class e{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);L_(t,e.shape,"TensorList shape mismatch: "),ls(e)})),this.idTensor=cu(0),this.maxNumElements=r,ls(this.idTensor)}copy(){return new e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);L_(e,this.elementShape,"TensorList shape mismatch: ");let r=B_(this.elementShape,this.tensors,e);return ss((()=>{let e=this.tensors.map((e=>Zo(e,r)));return Mc(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=B_(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,L_(r.shape,e,"TensorList shape mismatch: "),Zo(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(L_(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ls(e),this.tensors.push(e)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new e([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let e=0;e<Math.min(this.tensors.length,t);++e)n.tensors[e]=this.tensors[e];return n}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);L_(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=B_(this.elementShape,this.tensors,t);return Zo(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);L_(this.elementShape,t.shape,"TensorList shape mismatch: "),ls(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);L_(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=B_(this.elementShape,this.tensors,n);return 0===e.length?Xi([],[0].concat(r)):ss((()=>{let t=e.map((e=>Zo(this.tensors[e],r)));return Mc(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);L_(this.elementShape,t,"TensorList shape mismatch: ");let n=B_(this.elementShape,this.tensors,t);return 0===this.size()?Xi([],[0].concat(n)):ss((()=>{let e=this.tensors.map((e=>Zo(e,n)));return nl(e,0)}))}};var G_=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=ET("thenBranch",e,t,n),a=ET("elseBranch",e,t,n),i=ET("cond",e,t,n),s=ET("args",e,t,n);return(await i.data())[0]?n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=ET("body",e,t,n),a=ET("cond",e,t,n),i=ET("args",e,t,n),s=await n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),o=i.map((e=>e.id)),l=await s[0].data();s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=i;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let i=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await i[0].data(),i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":return[OT(ET("pred",e,t,n))];case"Switch":{let r=ET("pred",e,t,n),a=ET("data",e,t,n);return a.kept||(a=OT(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==AT(e,t,n)));if(r){return[OT(AT(r,t,n))]}return}case"Enter":{let r=ET("frameName",e,t,n),a=ET("tensor",e,t,n);return n.enterFrame(r),[OT(a)]}case"Exit":{let r=ET("tensor",e,t,n);return n.exitFrame(),[OT(r)]}case"NextIteration":{let r=ET("tensor",e,t,n);return n.nextIteration(),[OT(r)]}case"TensorArrayV3":{let r=ET("size",e,t,n),a=ET("dtype",e,t,n),i=ET("elementShape",e,t,n),s=ET("dynamicSize",e,t,n),o=ET("clearAfterRead",e,t,n),l=ET("identicalElementShapes",e,t,n),u=ET("name",e,t,n),d=new U_(u,a,r,i,l,s,o);return n.addTensorArray(d),[d.idTensor,cu(1)]}case"TensorArrayWriteV3":{let r=ET("tensorArrayId",e,t,n),a=ET("index",e,t,n),i=ET("tensor",e,t,n),s=n.getTensorArray(r.id);return s.write(a,i),[s.idTensor]}case"TensorArrayReadV3":{let r=ET("tensorArrayId",e,t,n),a=ET("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=ET("tensorArrayId",e,t,n),a=ET("indices",e,t,n),i=ET("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,i)]}case"TensorArrayScatterV3":{let r=ET("tensorArrayId",e,t,n),a=ET("indices",e,t,n),i=ET("tensor",e,t,n),s=n.getTensorArray(r.id);return s.scatter(a,i),[s.idTensor]}case"TensorArrayConcatV3":{let r=ET("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),i=ET("dtype",e,t,n);return[a.concat(i)]}case"TensorArraySplitV3":{let r=ET("tensorArrayId",e,t,n),a=ET("tensor",e,t,n),i=ET("lengths",e,t,n),s=n.getTensorArray(r.id);return s.split(i,a),[s.idTensor]}case"TensorArraySizeV3":{let r=ET("tensorArrayId",e,t,n);return[cu(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{let r=ET("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=ET("tensorListId",e,t,n),a=ET("index",e,t,n),i=ET("tensor",e,t,n),s=n.getTensorList(r.id);return s.setItem(a,i),[s.idTensor]}case"TensorListGetItem":{let r=ET("tensorListId",e,t,n),a=ET("index",e,t,n),i=ET("elementShape",e,t,n),s=ET("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,i,s)]}case"TensorListScatterV2":case"TensorListScatter":{let r=ET("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let i=new V_([],n,e.dtype,r),s=ep(e,0);return t.forEach(((e,t)=>{i.setItem(e,s[t])})),i}(ET("tensor",e,t,n),r,ET("elementShape",e,t,n),ET("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=ET("elementShape",e,t,n),i=ET("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let s=ET(r,e,t,n),o=function(e,t,n,r){return new V_([],e,t,r)}(a,i,0,"TensorListReserve"===e.op?-1:s);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=ET("tensorListId",e,t,n),a=ET("indices",e,t,n),i=ET("elementShape",e,t,n),s=ET("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,s,i)]}case"TensorListStack":{let r=ET("tensorListId",e,t,n),a=ET("elementShape",e,t,n),i=ET("elementDType",e,t,n),s=ET("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,i,s)]}case"TensorListFromTensor":{let r=function(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);L_(e.shape.slice(1),t,"TensorList shape mismatch: ");let a=ep(e);return new V_(a,t,r)}(ET("tensor",e,t,n),ET("elementShape",e,t,n),ET("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=ET("tensorListId",e,t,n),a=n.getTensorList(r.id),i=ET("dtype",e,t,n),s=ET("elementShape",e,t,n);return[a.concat(i,s)]}case"TensorListPushBack":{let r=ET("tensorListId",e,t,n),a=ET("tensor",e,t,n),i=n.getTensorList(r.id);return i.pushBack(a),[i.idTensor]}case"TensorListPopBack":{let r=ET("tensorListId",e,t,n),a=ET("elementShape",e,t,n),i=ET("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,i)]}case"TensorListSplit":{let r=ET("tensor",e,t,n),a=ET("elementShape",e,t,n),i=function(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let i=W_(e.shape.slice(1),n),s=0===r?0:e.size/r,o=ss((()=>{let n=[];e=Zo(e,[1,r,s]);for(let r=0;r<t.length;++r){let o=[0,0===r?0:a[r-1],0],l=[1,t[r],s];n[r]=Zo(il(e,o,l),i)}return e.dispose(),n})),l=new V_([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,ET("lengths",e,t,n),a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=ET("tensorListId",e,t,n);return[cu(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{let r=ET("tensorListId",e,t,n),a=ET("size",e,t,n),i=n.getTensorList(r.id).resize(a);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function H_(e,t,n){let[r,a]=ET("fusedOps",e,t,n),i="biasadd"===r,s=!i,o="prelu"===a,l="fusedbatchnorm"===r,u=ET("numArgs",e,t,n);if(i){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let d=ET("strides",e,t,n),c=MT(e,t,n),p=ET("dataFormat",e,t,n).toUpperCase(),h=ET("dilations",e,t,n),[f,m]=ET("args",e,t,n);return s&&(m=f,f=void 0),{stride:d,pad:c,dataFormat:p,dilations:h,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:ET("leakyreluAlpha",e,t,n)}}function j_(e,t,n){return{boxes:ET("boxes",e,t,n),scores:ET("scores",e,t,n),maxOutputSize:ET("maxOutputSize",e,t,n),iouThreshold:ET("iouThreshold",e,t,n),scoreThreshold:ET("scoreThreshold",e,t,n),softNmsSigma:ET("softNmsSigma",e,t,n)}}var q_=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=cu(0),this.tensorMap=new Map,ls(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return cu(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),ss((()=>{let e=ep(t),r=n.length,a=e.length;_a.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];ls(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ss((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],i=this.findWithDefault(a,t);e.push(i)}return Mc(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};function K_(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ss,i=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(ET("a",e,t,n),ET("b",e,t,n))];case"AddN":return[r.addN(ET("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(ET("a",e,t,n),ET("b",e,t,n))];case"Mul":return[r.mul(ET("a",e,t,n),ET("b",e,t,n))];case"RealDiv":case"Div":return[r.div(ET("a",e,t,n),ET("b",e,t,n))];case"DivNoNan":return[r.divNoNan(ET("a",e,t,n),ET("b",e,t,n))];case"FloorDiv":return[r.floorDiv(ET("a",e,t,n),ET("b",e,t,n))];case"Sub":return[r.sub(ET("a",e,t,n),ET("b",e,t,n))];case"Minimum":return[r.minimum(ET("a",e,t,n),ET("b",e,t,n))];case"Maximum":return[r.maximum(ET("a",e,t,n),ET("b",e,t,n))];case"Pow":return[r.pow(ET("a",e,t,n),ET("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(ET("a",e,t,n),ET("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(ET("x",e,t,n))];case"Acos":return[r.acos(ET("x",e,t,n))];case"Acosh":return[r.acosh(ET("x",e,t,n))];case"Asin":return[r.asin(ET("x",e,t,n))];case"Asinh":return[r.asinh(ET("x",e,t,n))];case"Atan":return[r.atan(ET("x",e,t,n))];case"Atan2":return[r.atan2(ET("x",e,t,n),ET("y",e,t,n))];case"Atanh":return[r.atanh(ET("x",e,t,n))];case"Ceil":return[r.ceil(ET("x",e,t,n))];case"Complex":return[r.complex(ET("real",e,t,n),ET("imag",e,t,n))];case"Cos":return[r.cos(ET("x",e,t,n))];case"Cosh":return[r.cosh(ET("x",e,t,n))];case"Elu":return[r.elu(ET("x",e,t,n))];case"Erf":return[r.erf(ET("x",e,t,n))];case"Exp":return[r.exp(ET("x",e,t,n))];case"Expm1":return[r.expm1(ET("x",e,t,n))];case"Floor":return[r.floor(ET("x",e,t,n))];case"Log":return[r.log(ET("x",e,t,n))];case"Log1p":return[r.log1p(ET("x",e,t,n))];case"Imag":return[r.imag(ET("x",e,t,n))];case"Neg":return[r.neg(ET("x",e,t,n))];case"Reciprocal":return[r.reciprocal(ET("x",e,t,n))];case"Real":return[r.real(ET("x",e,t,n))];case"Relu":return[r.relu(ET("x",e,t,n))];case"Round":return[r.round(ET("x",e,t,n))];case"Selu":return[r.selu(ET("x",e,t,n))];case"Sigmoid":return[r.sigmoid(ET("x",e,t,n))];case"Sin":return[r.sin(ET("x",e,t,n))];case"Sign":return[r.sign(ET("x",e,t,n))];case"Sinh":return[r.sinh(ET("x",e,t,n))];case"Softplus":return[r.softplus(ET("x",e,t,n))];case"Sqrt":return[r.sqrt(ET("x",e,t,n))];case"Square":return[r.square(ET("x",e,t,n))];case"Tanh":return[r.tanh(ET("x",e,t,n))];case"Tan":return[r.tan(ET("x",e,t,n))];case"ClipByValue":return[r.clipByValue(ET("x",e,t,n),ET("clipValueMin",e,t,n),ET("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(ET("x",e,t,n))];case"Rsqrt":return[r.rsqrt(AT(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(ET("x",e,t,n),ET("alpha",e,t,n))];case"Prelu":return[r.prelu(ET("x",e,t,n),ET("alpha",e,t,n))];case"IsNan":return[r.isNaN(AT(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(AT(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(AT(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return G_(e,t,n);case"convolution":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"Conv1D":{let a=ET("stride",e,t,n),i=ET("pad",e,t,n),s=ET("dataFormat",e,t,n).toUpperCase(),o=ET("dilation",e,t,n);return[r.conv1d(ET("x",e,t,n),ET("filter",e,t,n),a,i,s,o)]}case"Conv2D":{let a=ET("strides",e,t,n),i=MT(e,t,n),s=ET("dataFormat",e,t,n).toUpperCase(),o=ET("dilations",e,t,n);return[r.conv2d(ET("x",e,t,n),ET("filter",e,t,n),[a[1],a[2]],i,s,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:i,dataFormat:s,dilations:o,biasArg:l,preluArg:u,activationFunc:d,leakyreluAlpha:c}=H_(e,t,n);return[r.fused.conv2d({x:ET("x",e,t,n),filter:ET("filter",e,t,n),strides:[a[1],a[2]],pad:i,dataFormat:s,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:i,dataFormat:s,dilations:o,biasArg:l,preluArg:u,activationFunc:d,leakyreluAlpha:c}=H_(e,t,n);return[r.fused.depthwiseConv2d({x:ET("x",e,t,n),filter:ET("filter",e,t,n),strides:[a[1],a[2]],pad:i,dataFormat:s,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=ET("outputShape",e,t,n),i=ET("strides",e,t,n),s=MT(e,t,n);return[r.conv2dTranspose(ET("x",e,t,n),ET("filter",e,t,n),a,[i[1],i[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=ET("strides",e,t,n),i=MT(e,t,n),s=ET("dilations",e,t,n),o=ET("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(ET("input",e,t,n),ET("filter",e,t,n),[a[1],a[2]],i,o,[s[1],s[2]])]}case"Conv3D":{let a=ET("strides",e,t,n),i=ET("pad",e,t,n),s=ET("dataFormat",e,t,n).toUpperCase(),o=ET("dilations",e,t,n);return[r.conv3d(ET("x",e,t,n),ET("filter",e,t,n),[a[1],a[2],a[3]],i,s,[o[1],o[2],o[3]])]}case"AvgPool":{let a=ET("strides",e,t,n),i=ET("pad",e,t,n),s=ET("kernelSize",e,t,n);return[r.avgPool(ET("x",e,t,n),[s[1],s[2]],[a[1],a[2]],i)]}case"MaxPool":{let a=ET("strides",e,t,n),i=ET("pad",e,t,n),s=ET("kernelSize",e,t,n);return[r.maxPool(ET("x",e,t,n),[s[1],s[2]],[a[1],a[2]],i)]}case"MaxPoolWithArgmax":{let a=ET("strides",e,t,n),i=ET("pad",e,t,n),s=ET("kernelSize",e,t,n),o=ET("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(ET("x",e,t,n),[s[1],s[2]],[a[1],a[2]],i,o);return[l,u]}case"AvgPool3D":{let a=ET("strides",e,t,n),i=ET("pad",e,t,n),s=ET("kernelSize",e,t,n);return[r.avgPool3d(ET("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],i)]}case"MaxPool3D":{let a=ET("strides",e,t,n),i=ET("pad",e,t,n),s=ET("kernelSize",e,t,n);return[r.maxPool3d(ET("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],i)]}case"Dilation2D":{let a=ET("strides",e,t,n),i=ET("pad",e,t,n),s=ET("dilations",e,t,n),o=a[1],l=a[2],u=s[1],d=s[2];return[r.dilation2d(ET("x",e,t,n),ET("filter",e,t,n),[o,l],i,[u,d],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"Fill":{let a=ET("shape",e,t,n),i=ET("dtype",e,t,n),s=ET("value",e,t,n);return[r.fill(a,s,i)]}case"LinSpace":{let a=ET("start",e,t,n),i=ET("stop",e,t,n),s=ET("num",e,t,n);return[r.linspace(a,i,s)]}case"Multinomial":{let a=ET("logits",e,t,n),i=ET("numSamples",e,t,n),s=ET("seed",e,t,n);return[r.multinomial(a,i,s)]}case"OneHot":{let a=ET("indices",e,t,n),i=ET("depth",e,t,n),s=ET("onValue",e,t,n),o=ET("offValue",e,t,n),l=ET("dtype",e,t,n);return[r.oneHot(a,i,s,o,l)]}case"Ones":return[r.ones(ET("shape",e,t,n),ET("dtype",e,t,n))];case"OnesLike":return[r.onesLike(ET("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(ET("shape",e,t,n),ET("dtype",e,t,n),ET("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(ET("shape",e,t,n),ET("minval",e,t,n),ET("maxval",e,t,n),ET("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(ET("shape",e,t,n),ET("minval",e,t,n),ET("maxval",e,t,n),ET("seed",e,t,n))];case"Range":{let a=ET("start",e,t,n),i=ET("stop",e,t,n),s=ET("step",e,t,n);return[r.range(a,i,s,ET("dtype",e,t,n))]}case"TruncatedNormal":{let a=ET("shape",e,t,n),i=ET("mean",e,t,n),s=ET("stdDev",e,t,n),o=ET("seed",e,t,n);return[r.truncatedNormal(a,i,s,ET("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(ET("shape",e,t,n),ET("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(ET("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:P_;switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:i,maxOutputSize:s,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=j_(e,t,n),d=await a.image.nonMaxSuppressionWithScoreAsync(r,i,s,o,l,u);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:i,maxOutputSize:s,iouThreshold:o,scoreThreshold:l}=j_(e,t,n),u=ET("padToMaxOutputSize",e,t,n),d=await a.image.nonMaxSuppressionPaddedAsync(r,i,s,o,l,u);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:i,maxOutputSize:s,iouThreshold:o,scoreThreshold:l}=j_(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,i,s,o,l)]}case"Where":{let r=a.cast(ET("condition",e,t,n),"bool"),i=[await a.whereAsync(r)];return r.dispose(),i}case"ListDiff":return a.setdiff1dAsync(ET("x",e,t,n),ET("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"LowerBound":{let a=ET("sortedSequence",e,t,n),i=ET("values",e,t,n);return[r.lowerBound(a,i)]}case"TopKV2":{let a=ET("x",e,t,n),i=ET("k",e,t,n),s=ET("sorted",e,t,n),o=r.topk(a,i,s);return[o.values,o.indices]}case"UpperBound":{let a=ET("sortedSequence",e,t,n),i=ET("values",e,t,n);return[r.upperBound(a,i)]}case"Unique":{let a=ET("x",e,t,n),i=r.unique(a);return[i.values,i.indices]}case"UniqueV2":{let a=ET("x",e,t,n),i=ET("axis",e,t,n),s=r.unique(a,i);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"ResizeBilinear":{let a=ET("images",e,t,n),i=ET("size",e,t,n),s=ET("alignCorners",e,t,n),o=ET("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[i[0],i[1]],s,o)]}case"ResizeNearestNeighbor":{let a=ET("images",e,t,n),i=ET("size",e,t,n),s=ET("alignCorners",e,t,n),o=ET("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[i[0],i[1]],s,o)]}case"CropAndResize":{let a=ET("image",e,t,n),i=ET("boxes",e,t,n),s=ET("boxInd",e,t,n),o=ET("cropSize",e,t,n),l=ET("method",e,t,n),u=ET("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,i,s,o,l,u)]}case"ImageProjectiveTransformV3":{let a=ET("images",e,t,n),i=ET("transforms",e,t,n),s=ET("outputShape",e,t,n),o=ET("fillValue",e,t,n),l=ET("interpolation",e,t,n),u=ET("fillMode",e,t,n);return[r.image.transform(a,i,l.toLowerCase(),u.toLowerCase(),o,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=ET("default",e,t,n);return[AT(e.name,t,n)||a];case"Placeholder":return[AT(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[OT(ET("x",e,t,n))];case"IdentityN":return ET("x",e,t,n).map((e=>OT(e)));case"Shape":return[r.tensor1d(ET("x",e,t,n).shape,"int32")];case"ShapeN":return ET("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(ET("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(ET("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=ET("x",e,t,n),s=ET("data",e,t,n),o=ET("message",e,t,n),l=ET("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<s.length;e++)console.log(Array.prototype.slice.call(s[e].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"Equal":return[r.equal(ET("a",e,t,n),ET("b",e,t,n))];case"NotEqual":return[r.notEqual(ET("a",e,t,n),ET("b",e,t,n))];case"Greater":return[r.greater(ET("a",e,t,n),ET("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(ET("a",e,t,n),ET("b",e,t,n))];case"Less":return[r.less(ET("a",e,t,n),ET("b",e,t,n))];case"LessEqual":return[r.lessEqual(ET("a",e,t,n),ET("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(ET("a",e,t,n),ET("b",e,t,n))];case"LogicalNot":return[r.logicalNot(ET("a",e,t,n))];case"LogicalOr":return[r.logicalOr(ET("a",e,t,n),ET("b",e,t,n))];case"Select":case"SelectV2":return[r.where(ET("condition",e,t,n),ET("a",e,t,n),ET("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(ET("a",e,t,n),ET("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(ET("a",e,t,n),ET("b",e,t,n),ET("transposeA",e,t,n),ET("transposeB",e,t,n))];case"Einsum":return[r.einsum(ET("equation",e,t,n),...ET("tensors",e,t,n))];case"Transpose":return[r.transpose(ET("x",e,t,n),ET("perm",e,t,n))];case"_FusedMatMul":let[a,i]=ET("fusedOps",e,t,n),s="biasadd"===a,o="prelu"===i,l=ET("numArgs",e,t,n),u=ET("leakyreluAlpha",e,t,n);if(s){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[d,c]=ET("args",e,t,n);return[r.fused.matMul({a:ET("a",e,t,n),b:ET("b",e,t,n),transposeA:ET("transposeA",e,t,n),transposeB:ET("transposeB",e,t,n),bias:d,activation:i,preluActivationWeights:c,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(ET("a",e,t,n),ET("numLower",e,t,n),ET("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(ET("x",e,t,n),ET("axis",e,t,n),ET("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(ET("x",e,t,n),ET("mean",e,t,n),ET("variance",e,t,n),ET("offset",e,t,n),ET("scale",e,t,n),ET("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(ET("x",e,t,n),ET("radius",e,t,n),ET("bias",e,t,n),ET("alpha",e,t,n),ET("beta",e,t,n))];case"Softmax":return[r.softmax(ET("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(ET("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:i}=r.raggedGather(ET("paramsNestedSplits",e,t,n),ET("paramsDenseValues",e,t,n),ET("indices",e,t,n),ET("outputRaggedRank",e,t,n));return a.concat(i)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:i}=r.raggedRange(ET("starts",e,t,n),ET("limits",e,t,n),ET("splits",e,t,n));return[a,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(ET("shape",e,t,n),ET("values",e,t,n),ET("defaultValue",e,t,n),ET("rowPartitionTensors",e,t,n),ET("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"Max":{let a=ET("axis",e,t,n),i=ET("keepDims",e,t,n);return[r.max(ET("x",e,t,n),a,i)]}case"Mean":{let a=ET("axis",e,t,n),i=ET("keepDims",e,t,n);return[r.mean(ET("x",e,t,n),a,i)]}case"Min":{let a=ET("axis",e,t,n),i=ET("keepDims",e,t,n);return[r.min(ET("x",e,t,n),a,i)]}case"Sum":{let a=ET("axis",e,t,n),i=ET("keepDims",e,t,n);return[r.sum(ET("x",e,t,n),a,i)]}case"All":{let a=ET("axis",e,t,n),i=ET("keepDims",e,t,n);return[r.all(ET("x",e,t,n),a,i)]}case"Any":{let a=ET("axis",e,t,n),i=ET("keepDims",e,t,n);return[r.any(ET("x",e,t,n),a,i)]}case"ArgMax":{let a=ET("axis",e,t,n);return[r.argMax(ET("x",e,t,n),a)]}case"ArgMin":{let a=ET("axis",e,t,n);return[r.argMin(ET("x",e,t,n),a)]}case"Prod":{let a=ET("axis",e,t,n),i=ET("keepDims",e,t,n);return[r.prod(ET("x",e,t,n),a,i)]}case"Cumprod":{let a=ET("axis",e,t,n),i=ET("exclusive",e,t,n),s=ET("reverse",e,t,n);return[r.cumprod(ET("x",e,t,n),a,i,s)]}case"Cumsum":{let a=ET("axis",e,t,n),i=ET("exclusive",e,t,n),s=ET("reverse",e,t,n);return[r.cumsum(ET("x",e,t,n),a,i,s)]}case"Bincount":let a=ET("x",e,t,n),i=ET("weights",e,t,n),s=ET("size",e,t,n);return[r.bincount(a,i,s)];case"DenseBincount":{let a=ET("x",e,t,n),i=ET("weights",e,t,n),s=ET("size",e,t,n),o=ET("binaryOutput",e,t,n);return[r.denseBincount(a,i,s,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"ConcatV2":case"Concat":{let a=ET("n",e,t,n),i=ET("axis",e,t,n),s=ET("tensors",e,t,n);return s=s.slice(0,a),[r.concat(s,i)]}case"Gather":{let a=ET("x",e,t,n),i=ET("indices",e,t,n);return[r.gather(a,r.cast(i,"int32"),0)]}case"GatherV2":{let a=ET("axis",e,t,n),i=ET("batchDims",e,t,n),s=ET("x",e,t,n),o=ET("indices",e,t,n);return[r.gather(s,r.cast(o,"int32"),a,i)]}case"Reverse":{let a=ET("dims",e,t,n),i=[];for(let e=0;e<a.length;e++)a[e]&&i.push(e);let s=ET("x",e,t,n);return[r.reverse(s,i)]}case"ReverseV2":{let a=ET("axis",e,t,n),i=ET("x",e,t,n);return[r.reverse(i,a)]}case"Slice":{let a=ET("begin",e,t,n),i=ET("size",e,t,n);return[r.slice(ET("x",e,t,n),a,i)]}case"StridedSlice":{let a=ET("begin",e,t,n),i=ET("end",e,t,n),s=ET("strides",e,t,n),o=ET("beginMask",e,t,n),l=ET("endMask",e,t,n),u=ET("ellipsisMask",e,t,n),d=ET("newAxisMask",e,t,n),c=ET("shrinkAxisMask",e,t,n),p=ET("x",e,t,n);return[r.stridedSlice(p,a,i,s,o,l,u,d,c)]}case"Pack":return ss((()=>{let a=ET("axis",e,t,n),i=ET("tensors",e,t,n),s=i[0].shape,o=r.squeeze(i[0]).shape,l=i.map((e=>{let t=_a.arraysEqual(e.shape,s);if(!t&&!_a.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,s)}));return[r.stack(l,a)]}));case"Unpack":{let a=ET("axis",e,t,n),i=ET("tensor",e,t,n);return r.unstack(i,a)}case"Tile":{let a=ET("reps",e,t,n);return[r.tile(ET("x",e,t,n),a)]}case"Split":case"SplitV":{let a=ET("axis",e,t,n),i=ET("numOrSizeSplits",e,t,n),s=ET("x",e,t,n);return r.split(s,i,a)}case"ScatterNd":{let a=ET("indices",e,t,n),i=ET("values",e,t,n),s=ET("shape",e,t,n);return[r.scatterND(a,i,s)]}case"GatherNd":{let a=ET("x",e,t,n),i=ET("indices",e,t,n);return[r.gatherND(a,i)]}case"SparseToDense":{let a=ET("sparseIndices",e,t,n),i=ET("outputShape",e,t,n),s=ET("sparseValues",e,t,n),o=ET("defaultValue",e,t,n);return[r.sparseToDense(a,s,i,s.dtype===o.dtype?o:r.cast(o,s.dtype))]}case"TensorScatterUpdate":{let a=ET("indices",e,t,n),i=ET("values",e,t,n),s=ET("tensor",e,t,n);return[r.tensorScatterUpdate(s,a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:i,emptyRowIndicator:s,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(ET("indices",e,t,n),ET("values",e,t,n),ET("denseShape",e,t,n),ET("defaultValue",e,t,n));return[a,i,s,o]}case"SparseReshape":{let{outputIndices:a,outputShape:i}=r.sparse.sparseReshape(ET("inputIndices",e,t,n),ET("inputShape",e,t,n),ET("newShape",e,t,n));return[a,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(ET("data",e,t,n),ET("indices",e,t,n),ET("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(ET("data",e,t,n),ET("indices",e,t,n),ET("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"FFT":return[r.fft(ET("x",e,t,n))];case"IFFT":return[r.ifft(ET("x",e,t,n))];case"RFFT":return[r.rfft(ET("x",e,t,n))];case"IRFFT":return[r.irfft(ET("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(ET("input",e,t,n),ET("pattern",e,t,n),ET("rewrite",e,t,n),ET("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:i}=r.string.stringNGrams(ET("data",e,t,n),ET("dataSplits",e,t,n),ET("separator",e,t,n),ET("nGramWidths",e,t,n),ET("leftPad",e,t,n),ET("rightPad",e,t,n),ET("padWidth",e,t,n),ET("preserveShortSequences",e,t,n));return[a,i]}case"StringSplit":{let{indices:a,values:i,shape:s}=r.string.stringSplit(ET("input",e,t,n),ET("delimiter",e,t,n),ET("skipEmpty",e,t,n));return[a,i,s]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(ET("input",e,t,n),ET("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P_;switch(e.op){case"Cast":return[r.cast(ET("x",e,t,n),ET("dtype",e,t,n))];case"ExpandDims":{let a=ET("axis",e,t,n);return[r.expandDims(ET("x",e,t,n),a)]}case"Squeeze":{let a=ET("axis",e,t,n);return[r.squeeze(ET("x",e,t,n),a)]}case"Reshape":return[r.reshape(ET("x",e,t,n),ET("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(ET("x",e,t,n),ET("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(ET("x",e,t,n),ET("padding",e,t,n),ET("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(ET("x",e,t,n),ET("padding",e,t,n),ET("constantValue",e,t,n))];case"SpaceToBatchND":{let a=ET("blockShape",e,t,n),i=ET("paddings",e,t,n);return[r.spaceToBatchND(ET("x",e,t,n),a,i)]}case"BatchToSpaceND":{let a=ET("blockShape",e,t,n),i=ET("crops",e,t,n);return[r.batchToSpaceND(ET("x",e,t,n),a,i)]}case"DepthToSpace":{let a=ET("blockSize",e,t,n),i=ET("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(ET("x",e,t,n),a,i)]}case"BroadcastTo":return[r.broadcastTo(ET("x",e,t,n),ET("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(ET("s0",e,t,n),ET("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=ET("keyDType",e,t,n),i=ET("valueDType",e,t,n),s=new q_(a,i);return r.addHashTable(e.name,s),[s.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=ET("tableHandle",e,t,n,r),i=ET("keys",e,t,n),s=ET("values",e,t,n);return[await r.getHashTableById(a.id).import(i,s)]}case"LookupTableFind":case"LookupTableFindV2":{let a=ET("tableHandle",e,t,n,r),i=ET("keys",e,t,n),s=ET("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(i,s)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=ET("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":let i=_T(e.op);if(i&&i.customExecutor)return i.customExecutor(new O_(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return _a.isPromise(i)?i.then((e=>[].concat(e))):[].concat(i)}var X_=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function Y_(e,t,n,r){let a=new Set,i=[],s=null,o=null,l=new Set,u=new Set(Object.keys(e).map((e=>DT(e)[0])));r=r||[];let d=new Set(r.map((e=>DT(e.name)[0]))),c=[...t];for(;c.length>0;){let e=c.pop();if((nC(e)||rC(e)||aC(e))&&null==s&&(s=e,o=s.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&!u.has(e.name)&&!d.has(e.name)){if(0===e.inputs.length){i.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),c.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:i,dynamicNode:s,syncInputs:o}}function Q_(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>DT(e)[0])).map((t=>e.nodes[t])),i=e.initNodes||[],s=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}let l=o([...a,...e.weights,...i]).filter(s),u=o([...l,...Object.values(e.nodes)]).filter(s),d=new Map(u.map((e=>[e.name,e]))),c={};for(let m of u){c[m.name]=c[m.name]||0;for(let e of m.children)s(e)||(c[e.name]=Number.POSITIVE_INFINITY),c[e.name]=(c[e.name]||0)+1}let p=Object.entries(c).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),h=[...p];for(;p.length>0;){let e=p.pop(),t=d.get(e);for(let n of t.children.filter(s))0===--c[n.name]&&(h.push(n.name),p.push(n.name))}let f=function(e,t){let n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let i of t.children)!n.has(i.name)||a.has(i.name)||(a.add(i.name),r.push(i.name))}return e.filter((e=>a.has(e.name)))}(h.map((e=>d.get(e))),l);return function(e,t){let n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"==typeof e?e:e.name),i=new Set(e.map((e=>e.name))),s=e=>i.has("string"==typeof e?e:e.name);for(let o of e){for(let e of o.children.filter(s)){if(!n.has(e.name))throw new J_(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new J_(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(let e of o.inputs){if(!n.has(e.name))throw new J_(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new J_(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}var J_=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};var Z_=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),eC=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),tC=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function nC(e){return Z_.has(e.op)}function rC(e){return eC.has(e.op)}function aC(e){return tC.has(e.op)}var iC=class e{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((n=>{this._functionExecutorMap[n]=new e(t.functions[n],this)}))}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=Y_(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:i}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}let s=Q_(this.graph,n),o=function(e){let t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>nC(e)?n:t)),a=e=>{let n=r[t.get(e.name)];return null==n?-1:n},i=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),s=new Map;for(let o=0;o<e.length;++o){let t=i[o];if(t===n)continue;let r=e[o],a=e[t];s.has(a.name)||s.set(a.name,[]),s.get(a.name).push(r)}return s}(s);return{orderedNodes:s,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return ls(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[DT(e)[0]])),a=t.map((e=>DT(e)[0])),i=new Set(a),s=a.map((e=>this.graph.nodes[e]));0===s.length&&(s=this._outputs);let o=this.getCompilationKey(r,s),l=this.compiledMap.get(o);null==l&&(l=this.compile(e,s),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=Ge().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let u={},d={};return ss((()=>{let n=new X_(this.weightMap,u,d,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{let[a,i]=DT(t,n),s=[];s[i]=e[t],r[a]=s,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(s))}));let a=this.getFrozenTensorIds(r),{orderedNodes:s,nodeLiveUntilMap:o}=l;for(let e of s){if(r[e.name])continue;let t=K_(e,r,n,this._resourceManager);if(_a.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,i,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>AT(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,i,s){if(!nC(t)&&!i.has(e)){for(let r of n[e])null!=r&&(s[r.id]=(s[r.id]||0)+t.children.length);for(let e of t.inputs){if(nC(e))continue;let t=$T(e.name,n,r);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=s[e.id];1===t?(e.dispose(),delete s[e.id]):null!=t&&s[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,i){function s(e){return nC(e)||a.has(e.name)}if(!nC(e)&&null!=i)for(let o of i){if(s(o))continue;let e=$T(o.name,t,n);for(let t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ge().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let i=new X_(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let s=await this.executeWithControlFlow(e,i,t,n),o=t.map((e=>AT(e,s,i))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),d=new Set([...l,...u,...this.weightIds]);return Object.values(s).forEach((e=>{e.forEach((e=>{e&&!e.isDisposed&&!d.has(e.id)&&e.dispose()}))})),null==this.parent&&i.dispose(d),o}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),i=a.map((e=>this.graph.nodes[DT(e)[0]])),s=n.map((e=>DT(e)[0])),o=new Set(s),l=s.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:d,dynamicNode:c,syncInputs:p}=Y_(e,l,this.weightMap,this._initNodes),h=[...i,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=DT(t),a=[];a[r]=e[t],f[n]=a}));let m={},g=this.getFrozenTensorIds(f),y={};for(;h.length>0;){let e=this.processStack(i,h,t,f,y,g,o,m,u);await Promise.all(e)}null==c&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter((e=>!nC(e)&&!AT(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${e}`)}return f}processStack(e,t,n,r,a,i,s,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let d="";if("Enter"===e.node.op&&ET("isConstant",e.node,r,n)&&([d]=RT(e.node.name,n)),null==r[e.node.name]){let c=K_(e.node,r,n,this._resourceManager);d||([d]=RT(e.node.name,n));let p=n.currentContext;_a.isPromise(c)?u.push(c.then((u=>(r[d]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(u)),n.currentContext=p,this.checkTensorForDisposal(d,e.node,r,n,i,s,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[d]=c,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(c)),this.checkTensorForDisposal(d,e.node,r,n,i,s,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,i){e.children.forEach((e=>{let[s]=RT(e.name,n);a[s]||!i.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!AT(e,r,n)))&&(a[s]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!AT(e,r,n)))&&(a[s]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=DT(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));_a.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&_a.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;let r={};for(let a in e){let i=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=i?r[i.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=DT(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;let r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{let[t]=DT(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},sC=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},oC="?tfjs-format=file",lC="model.json",uC=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:jh;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new sC}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return _a.isPromise(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");let t=await Ns(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new iC(w_.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=w_.Instance.transformGraph(e.modelInitializer);this.initializer=new iC(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t={};return(e instanceof li?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof li)&&!Array.isArray(e)){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,i,s;let o=null===(s=null===(i=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===i?void 0:i[n])||void 0===s?void 0:s.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&os(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function dC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:jh;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${lC}${oC}`}(e));let r=new uC(e,t,n);return await r.load(),r}function cC(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let a=jh.getWeightSpecs(n.weightsManifest),i=jh.getModelArtifactsForJSONSync(n,a,r);t=jh.fromMemorySync(i)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=jh.fromMemorySync(e)}let n=new uC(t);return n.load(),n}var pC="4.21.0",hC={};w(hC,{CSVDataset:()=>iE,Dataset:()=>jC,FileDataSource:()=>bE,TextLineDataset:()=>JC,URLDataSource:()=>vE,array:()=>KC,csv:()=>xE,func:()=>wE,generator:()=>kE,microphone:()=>IE,version_data:()=>NE,webcam:()=>SE,zip:()=>XC});var fC=k(D()),mC=k(D());function gC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(wC(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let s=gC(e[i],t,n,r);a[i]=s}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function yC(e){return bC(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:vC)}function bC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set,r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(wC(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let r=bC(e.map((e=>e[i])),t,n);a[i]=r}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function vC(e){return null===e?null:wC(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function xC(e,t){let n=new Map;gC(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(_a.isPromise(e)){let t=await e;n.set(r,t)}}return gC(e,t,n)}function wC(e){let t=!1;if(Ge().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=M();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof li)&&!(e instanceof Promise)&&!t)}function kC(e){return function(e,t){return gC(e,t)}(e,SC)}function SC(e){return e instanceof li?{value:e.clone(),recurse:!1}:wC(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var IC=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},NC=class e extends IC{constructor(){super(e.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function TC(e){return new AC(e)}function _C(e){return new $C(e)}NC.INITIAL_CAPACITY=32;var CC,EC=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new LC(this,e)}filter(e){return new OC(this,e)}map(e){return new PC(this,e)}mapAsync(e){return new zC(this,e)}serialMapAsync(e){return new zC(this,e).serial()}flatmap(e){return new WC(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new MC(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:vC;return this.rowMajorBatch(e,t).map((e=>yC(e,n)))}concatenate(e,t){return new UC(TC([this,e]),t)}take(e){return e<0||null==e?this:new DC(this,e)}skip(e){return e<0||null==e?this:new FC(this,e)}prefetch(e){return new GC(this,e)}shuffle(e,t){return new HC(this,e,t)}serial(){return new RC(this)}},AC=class extends EC{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:kC(e),done:!1}}},$C=class extends EC{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(pi){throw pi.message=`Error thrown while iterating through a dataset: ${pi.message}`,pi}}},RC=class extends EC{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},FC=class extends EC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;os(e.value)}return this.upstream.next()}},DC=class extends EC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},MC=class extends EC{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},OC=class extends EC{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;os(e.value)}}},PC=class extends EC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=yi.getTensorsInContainer(e.value),n=this.transform(e.value),r=yi.getTensorsInContainer(n);for(let a of t)yi.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},LC=class extends EC{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(pi){if(!this.handler(pi))return{value:null,done:!0}}}},zC=class extends EC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=yi.getTensorsInContainer(e.value),n=await this.transform(e.value),r=yi.getTensorsInContainer(n);for(let a of t)yi.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},BC=class extends EC{constructor(){super(),this.outputQueue=new NC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},WC=class extends BC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=yi.getTensorsInContainer(e.value),n=this.transform(e.value),r=yi.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)yi.isTensorInList(a,r)||a.dispose();return!0}},UC=class extends EC{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(CC||(CC={}));var VC=class extends EC{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:CC.FAIL;super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;let r=await xC(this.iterators,(function(e){return e instanceof EC?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case CC.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case CC.SHORTEST:return{value:null,done:!0};case CC.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},GC=class extends EC{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new IC(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},HC=class extends GC{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=mC.alea(n||_a.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},jC=class{constructor(){this.size=null}batch(e){let t,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=this;return _a.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),t=this.size===1/0||null==this.size?this.size:n?Math.ceil(this.size/e):Math.floor(this.size/e),qC((async()=>(await r.iterator()).columnMajorBatch(e,n,YC)),t)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,qC((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,qC((async()=>(await n.iterator()).filter((t=>ss((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return qC((async()=>(await t.iterator()).map((t=>ss((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return qC((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return qC((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,qC((async()=>function(e,t){return new UC(e,t)}(_C((async()=>({value:await n.iterator(),done:!1}))).take(e))),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,qC((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=fC.alea(t||_a.now().toString());return qC((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,qC((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function qC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends jC{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function KC(e){return qC((async()=>TC(e)),e.length)}function XC(e){if(!wC(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return qC((async()=>function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:CC.FAIL;return new VC(e,t)}(await xC(e,(e=>{if(e instanceof jC)return{value:e.iterator(),recurse:!1};if(wC(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),CC.SHORTEST)),t)}function YC(e){if(null===e)return null;return function(e){return null==e||function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof li||_a.isTypedArray(e)}(e[0])?{value:QC(e),recurse:!1}:{value:null,recurse:!0}}function QC(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof li?Mc(e):Xi(e)}jC.MAX_BUFFER_SIZE=1e4;var JC=class extends jC{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},ZC='"',eE=Symbol("out"),tE=Symbol("field"),nE=Symbol("quote"),rE=Symbol("quoteafterquote"),aE=Symbol("quoteinquote"),iE=class extends jC{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&_a.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(_a.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new JC(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(_a.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let i=this.fullColumnNames[a],s=this.columnConfigs?this.columnConfigs[i]:null;if(!this.configuredColumnsOnly||s){let o=t[a],l=null;if(""===o)if(s&&void 0!==s.default)l=s.default;else{if(s&&(s.required||s.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=s&&"bool"===s.dtype?this.getBoolean(o):o;else if(s&&s.dtype)switch(s.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}s&&s.isLabel?r[i]=l:n[i]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=[],r=0,a=e.length,i=eE;for(let s=0;s<a;s++)switch(i){case eE:switch(e.charAt(s)){case ZC:r=s+1,i=nE;break;case this.delimiter:if(r=s+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),i=eE;break;default:i=tE,r=s}break;case tE:if(e.charAt(s)===this.delimiter)n.push(e.substring(r,s)),i=eE,r=s+1;break;case nE:if(e.charAt(s)===ZC)i=rE;break;case rE:switch(e.charAt(s)){case this.delimiter:n.push(e.substring(r,s-1)),i=eE,r=s+1;break;case ZC:i=nE;break;default:i=aE}break;case aE:if(e.charAt(s)===ZC)i=nE}if(i===rE?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},sE=class e extends EC{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!Ge().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new e(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(_a.sizeFromShape(t));return n.set(e,n.length-e.length),Xi(n,t)}},oE=class e extends EC{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=zc([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,i=t+r;this.cropBox=Bc([r,n,i,a],[1,4])}else this.cropBox=Bc([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Ge().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new e(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&_a.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=gf.fromPixels(this.webcamVideoElement)}catch(NZ){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(NZ)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(NZ){throw new Error(`Error thrown cropping the video: ${NZ.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return ss((()=>{let t,n=vu(bo(e,"float32"),0);t=Nh.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return Zo(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},lE=class{},uE=class extends EC{split(e){return new dE(this,e)}},dE=class extends uE{constructor(e,t){super(),this.upstream=e,this.impl=new cE(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},cE=class extends BC{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},pE=class extends EC{decodeUTF8(){return new hE(this)}},hE=class extends uE{constructor(e){super(),this.upstream=e,this.impl=new fE(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},fE=class extends BC{constructor(e){if(super(),this.upstream=e,Ge().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=M();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=Ge().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},mE=class extends pE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.file=e,this.options=t,_a.assert(e instanceof Uint8Array||!!Ge().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};var gE=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function yE(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var bE=class extends lE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.input=e,this.options=t}async iterator(){if(yE(this.input)&&Ge().get("IS_NODE")){let e=O();this.input=e.readFileSync(this.input.slice(7))}return new mE(this.input,this.options)}},vE=class extends lE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.url=e,this.fileOptions=t}async iterator(){return yE(this.url)?new bE(this.url,this.fileOptions).iterator():async function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2?arguments[2]:void 0;"string"==typeof e?t=e:(t=e.url,n=gE(e));let i=await(a||_a.fetch)(t,n);if(i.ok){let e=new Uint8Array(await i.arrayBuffer());return new mE(e,r)}throw new Error(i.statusText)}(this.url,this.fileOptions)}};function xE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new iE(new vE(e),t)}function wE(e){let t=_C(e);return qC((async()=>t))}function kE(e){return qC((async()=>{let t=await e();return _C((()=>t.next()))}))}async function SE(e,t){return oE.create(e,t)}async function IE(e){return sE.create(e)}var NE="4.21.0";function TE(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&_a.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var _E=sg.whereImpl,CE=class e extends H{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new G(this,rs())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Ge().get("IS_NODE")&&em.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&_a.isString(n[0])){let a=n.map((e=>_a.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return em.mergeRealAndImagArrays(e,t)}return _a.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>_a.decodeString(e)));return yo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return yo(e.shape,e.dtype,t)}makeOutput(e,t,n){return rs().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=_a.now();return e(),{kernelMs:_a.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){TE([e],"where");let t=this.readSync(e.dataId);return _E(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};CE.nextDataId=0;var EE={};function AE(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}w(EE,{addImpl:()=>HE,bincountImpl:()=>XE,bincountReduceImpl:()=>YE,bitwiseAndImpl:()=>QE,castImpl:()=>BE,ceilImpl:()=>rA,concatImpl:()=>sA,equalImpl:()=>oA,expImpl:()=>dA,expm1Impl:()=>hA,floorDivImpl:()=>vA,floorImpl:()=>gA,gatherNdImpl:()=>kA,gatherV2Impl:()=>SA,greaterEqualImpl:()=>_A,greaterImpl:()=>IA,lessEqualImpl:()=>FA,lessImpl:()=>AA,linSpaceImpl:()=>OA,logImpl:()=>PA,maxImpl:()=>BA,maximumImpl:()=>WA,minimumImpl:()=>GA,multiplyImpl:()=>qA,negImpl:()=>QA,notEqualImpl:()=>ZA,prodImpl:()=>i$,raggedGatherImpl:()=>d$,raggedRangeImpl:()=>p$,raggedTensorToTensorImpl:()=>y$,rangeImpl:()=>b$,rsqrtImpl:()=>v$,scatterImpl:()=>k$,sigmoidImpl:()=>S$,simpleAbsImpl:()=>AE,sliceImpl:()=>T$,sparseFillEmptyRowsImpl:()=>E$,sparseReshapeImpl:()=>A$,sparseSegmentReductionImpl:()=>$$,sqrtImpl:()=>R$,squaredDifferenceImpl:()=>M$,staticRegexReplaceImpl:()=>L$,stridedSliceImpl:()=>W$,stringNGramsImpl:()=>V$,stringSplitImpl:()=>H$,stringToHashBucketFastImpl:()=>j$,subImpl:()=>q$,tileImpl:()=>Q$,topKImpl:()=>eR,transposeImpl:()=>n$,uniqueImpl:()=>tR});var $E={kernelName:Xe,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;TE(t,"abs");let r=new Float32Array(_a.sizeFromShape(t.shape));return r=AE(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function RE(e){return(t,n,r,a,i)=>{let s=em.assertAndGetBroadcastShape(t,n),o=s.length,l=_a.computeStrides(s),u=_a.sizeFromShape(s),d=_a.getTypedArrayFromDType(i,u),c=t.length,p=n.length,h=_a.computeStrides(t),f=_a.computeStrides(n),m=em.getBroadcastDims(t,s),g=em.getBroadcastDims(n,s);if(m.length+g.length===0)for(let y=0;y<d.length;++y)d[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<d.length;++y){let t=_a.indexToLoc(y,o,l),n=t.slice(-c);m.forEach((e=>n[e]=0));let i=_a.locToIndex(n,c,h),s=t.slice(-p);g.forEach((e=>s[e]=0));let u=_a.locToIndex(s,p,f);d[y]=e(r[i],a[u])}return[d,s]}}function FE(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",i),imag:n.makeTensorInfo(a.shape,"float32",s)},o}var DE={kernelName:kt,backendName:"cpu",kernelFunc:FE};function ME(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return FE({inputs:{real:ME(e,t,"float32"),imag:ME(e,t,"float32")},backend:e})}let r=_a.makeZerosTypedArray(_a.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function OE(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var PE={kernelName:pn,backendName:"cpu",kernelFunc:OE};function LE(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}var zE={kernelName:dr,backendName:"cpu",kernelFunc:LE};function BE(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){let r=_a.toTypedArray([0],n),[a,i]=RE(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function WE(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===a.dtype)return OE({inputs:{x:a},backend:n});let e=ME(n,a.shape,a.dtype),t=WE({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=FE({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=LE({inputs:{input:a},backend:n}),t=WE({inputs:{x:e},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(e),t}if(!_a.hasEncodingLoss(a.dtype,i)){let e=OE({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:i}}let s=n.data.get(a.dataId).values,[o,l,u]=BE(s,a.shape,a.dtype,i);return n.makeTensorInfo(o,l,u)}var UE={kernelName:vt,backendName:"cpu",kernelFunc:WE};function VE(e,t,n,r){return null==n?n=>{let{inputs:a,backend:i}=n,{a:s,b:o}=a,l=i;TE([s,o],e);let u=l.data.get(s.dataId).values,d=l.data.get(o.dataId).values,c="string"===s.dtype?em.fromUint8ToStringArray(u):u,p="string"===s.dtype?em.fromUint8ToStringArray(d):d,h=r||s.dtype,[f,m]=t(s.shape,o.shape,c,p,h);return l.makeTensorInfo(m,h,f)}:e=>{let{inputs:a,backend:i}=e,{a:s,b:o}=a,l=i;if("complex64"===s.dtype||"complex64"===o.dtype){let e=WE({inputs:{x:s},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,i=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,d=WE({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(d.dataId),p=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,f=l.data.get(p.dataId).values,m=l.data.get(h.dataId).values,[g,y,b]=n(s.shape,o.shape,i,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=FE({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(d),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{let e=l.data.get(s.dataId).values,n=l.data.get(o.dataId).values,a=r||s.dtype,[i,u]=t(s.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,i)}}}function GE(e){return(t,n,r,a,i,s)=>{let o=em.assertAndGetBroadcastShape(t,n),l=_a.sizeFromShape(o),u=o.length,d=_a.computeStrides(o),c=_a.getTypedArrayFromDType("float32",l),p=_a.getTypedArrayFromDType("float32",l),h=em.getBroadcastDims(t,o),f=em.getBroadcastDims(n,o),m=em.mergeRealAndImagArrays(r,a),g=em.mergeRealAndImagArrays(i,s),y=t.length,b=_a.computeStrides(t),v=n.length,x=_a.computeStrides(n);if(h.length+f.length===0)for(let w=0;w<c.length;w++){let t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);c[w]=r.real,p[w]=r.imag}else for(let w=0;w<c.length;w++){let t=_a.indexToLoc(w,u,d),n=t.slice(-y);h.forEach((e=>n[e]=0));let r=_a.locToIndex(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));let i=_a.locToIndex(a,v,x),s=e(m[2*r],m[2*r+1],g[2*i],g[2*i+1]);c[w]=s.real,p[w]=s.imag}return[c,p,o]}}var HE=RE(((e,t)=>e+t)),jE=GE(((e,t,n,r)=>({real:e+n,imag:t+r}))),qE=VE(Je,HE,jE),KE={kernelName:Je,backendName:"cpu",kernelFunc:qE};function XE(e,t,n,r,a){let i=_a.sizeFromShape(r),s=_a.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(s[n]+=i>0?t[o]:1)}return s}function YE(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e.shape[0],i=e.shape[1],s=yo([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<i;a++){let i=e.get(o,a);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(r?s.set(1,o,i):t.size>0?s.set(s.get(o,i)+t.get(o,a),o,i):s.set(s.get(o,i)+1,o,i))}return s}var QE=RE(((e,t)=>e&t)),JE=VE(gt,QE),ZE={kernelName:gt,backendName:"cpu",kernelFunc:JE};function eA(e){return(t,n,r)=>{let a=_a.getArrayFromDType(n,t.length);for(let i=0;i<t.length;++i)a[i]=e(t[i],r);return a}}function tA(e,t,n){return nA(e,eA(t),n)}function nA(e,t,n){return r=>{let{inputs:a,attrs:i,backend:s}=r,{x:o}=a;TE(o,e);let l,u=s,d=u.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(d))throw new Error("String tensor's value was not an instance of Array");l=em.fromUint8ToStringArray(d)}else l=d;let c=n||o.dtype,p=t(l,c,i);return u.makeTensorInfo(o.shape,c,p)}}var rA=eA((e=>Math.ceil(e))),aA=nA(xt,rA),iA={kernelName:xt,backendName:"cpu",kernelFunc:aA};function sA(e,t,n,r){let a=_a.getArrayFromDType(n,_a.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=_a.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let i="string"===n?em.fromUint8ToStringArray(e.vals):e.vals,s=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=i[s++]}r+=e.shape[1]}))}return a}var oA=RE(((e,t)=>e===t?1:0)),lA=VE(Qt,oA,null,"bool"),uA={kernelName:Qt,backendName:"cpu",kernelFunc:lA},dA=eA((e=>Math.exp(e))),cA=nA(Jt,dA,"float32"),pA={kernelName:Jt,backendName:"cpu",kernelFunc:cA},hA=eA((e=>Math.expm1(e))),fA=nA(en,hA),mA={kernelName:en,backendName:"cpu",kernelFunc:fA},gA=eA((e=>Math.floor(e))),yA=nA(an,gA),bA={kernelName:an,backendName:"cpu",kernelFunc:yA},vA=RE(((e,t)=>Math.floor(e/t))),xA=VE(sn,vA,null,"int32"),wA={kernelName:sn,backendName:"cpu",kernelFunc:xA};function kA(e,t,n,r,a,i,s,o,l){let u=yo([r,i],n);for(let d=0;d<r;d++){let n=[],r=0;for(let t=0;t<a;t++){let i=e[d*a+t];r+=i*s[t],n.push(i)}if(r<0||r>=l/i)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<i;e++)u.values[d*i+e]=t.get(...t.indexToLoc(r*i+e))}return u}function SA(e,t,n){let r=yo(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),i=n[0],s=n[2],o=t.locToIndex([i,s]);n[2]=t.values[o];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var IA=RE(((e,t)=>e>t?1:0)),NA=VE(dn,IA,null,"bool"),TA={kernelName:dn,backendName:"cpu",kernelFunc:NA},_A=RE(((e,t)=>e>=t?1:0)),CA=VE(cn,_A,null,"bool"),EA={kernelName:cn,backendName:"cpu",kernelFunc:CA},AA=RE(((e,t)=>e<t?1:0)),$A=VE(vn,AA,null,"bool"),RA={kernelName:vn,backendName:"cpu",kernelFunc:$A},FA=RE(((e,t)=>e<=t?1:0)),DA=VE(xn,FA,null,"bool"),MA={kernelName:xn,backendName:"cpu",kernelFunc:DA};function OA(e,t,n){let r=(t-e)/(n-1),a=_a.makeZerosTypedArray(n,"float32");a[0]=e;for(let i=1;i<a.length;i++)a[i]=a[i-1]+r;return a}var PA=eA((e=>Math.log(e))),LA=nA(kn,PA),zA={kernelName:kn,backendName:"cpu",kernelFunc:LA};function BA(e,t,n,r){let a=_a.getTypedArrayFromDType(r,_a.sizeFromShape(n));for(let i=0;i<a.length;++i){let n=i*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[i]=r}return a}var WA=RE(((e,t)=>Math.max(e,t))),UA=VE(Dn,WA),VA={kernelName:Dn,backendName:"cpu",kernelFunc:UA},GA=RE(((e,t)=>Math.min(e,t))),HA=VE(Un,GA),jA={kernelName:Un,backendName:"cpu",kernelFunc:HA},qA=RE(((e,t)=>e*t)),KA=GE(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),XA=VE(jn,qA,KA),YA={kernelName:jn,backendName:"cpu",kernelFunc:XA};function QA(e,t,n){let r=_a.createScalarValue(-1,n);return qA([],t,r,e,n)}var JA={kernelName:qn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t;TE(r,"neg");let a=n.data.get(r.dataId).values,[i,s]=QA(a,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,i)}},ZA=RE(((e,t)=>e!==t?1:0)),e$=VE(Kn,ZA,null,"bool"),t$={kernelName:Kn,backendName:"cpu",kernelFunc:e$};function n$(e,t,n,r,a){let i=t.length,s=_a.sizeFromShape(t),o=_a.computeStrides(t),l=_a.computeStrides(a),u=_a.getTypedArrayFromDType(n,_a.sizeFromShape(a));for(let d=0;d<s;++d){let t=_a.indexToLoc(d,i,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[_a.locToIndex(n,i,l)]=e[d]}return u}function r$(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:i}=n;TE(a,"transpose");let s=a.shape.length,o=new Array(s);for(let u=0;u<o.length;u++)o[u]=a.shape[i[u]];let l=n$(r.data.get(a.dataId).values,a.shape,a.dtype,i,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}var a$={kernelName:na,backendName:"cpu",kernelFunc:r$};function i$(e,t,n,r){let[a,i]=em.computeOutAndReduceShapes(e,r),s=vi(t,"int32"),o=_a.makeZerosTypedArray(_a.sizeFromShape(a),s),l=_a.sizeFromShape(i);for(let u=0;u<o.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:s}}var s$={kernelName:ir,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;TE(a,"prod");let o=a.shape.length,l=_a.parseAxisParam(i,a.shape),u=em.getAxesPermutation(l,o),d=l,c=a,p=[];null!=u&&(c=r$({inputs:{x:a},backend:n,attrs:{perm:u}}),p.push(c),d=em.getInnerMostAxes(d.length,o));let h=n.data.get(c.dataId).values,{outVals:f,outShape:m,outDtype:g}=i$(c.shape,c.dtype,h,d),y=m;return s&&(y=em.expandShapeToKeepDim(m,l)),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function o$(e,t,n,r){let a=[],i=0,s=t.length-1+n.length,o=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],s=e[u]+1;for(let e=0;e<n.length;++e){let a=n[e],i=e+t.length-1;if(i>=0){let e=o[i],t=e[e.length-1]-a[r];for(let n=r;n<s;++n)o[i].push(a[n+1]+t)}r=a[r],s=a[s]}s!==r&&(a.push([r,s]),i+=s-r)}return{outSplits:o,valueSlices:a,numValues:i}}function l$(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function u$(e,t,n,r,a){let i=t.slice();i[0]=a;let s=_a.getArrayFromDType(n,_a.sizeFromShape(i)),o=e.length;return function(e,t,n,r,a,i){let s=l$(t,2)[1],o=l$(i,2)[1],l=0;for(let u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*s+n];++l}}(e,t,r,0===o?0:o/t[0],s,i),[s,i]}function d$(e,t,n,r,a,i,s,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){let a=_a.indexToLoc(r,t.length,_a.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(i,s,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:d,numValues:c}=o$(i,s,e,l),p=function(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=_a.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(u),h=u$(n,r,a,d,c);return[p,h[0],h[1]]}var c$=2147483647;function p$(e,t,n,r,a,i,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===s.length,d=[];o||d.push(t[0]),l||d.push(a[0]),u||d.push(s[0]);for(let g=1;g<d.length;++g)if(d[g]!==d[g-1])throw new Error("starts, limits, and deltas must have the same shape");let c=0===d.length?1:d[0],p=_a.getArrayFromDType("int32",c+1);p[0]=0;for(let g=0;g<c;++g){let t,n=o?e[0]:e[g],a=l?r[0]:r[g],s=u?i[0]:i[g];if(0===s)throw new Error("Requires delta != 0");if(s>0&&a<n||s<0&&a>n)t=0;else if(t=Math.ceil(Math.abs((a-n)/s)),t>c$)throw new Error(`Requires ((limit - start) / delta) <= ${c$}`);p[g+1]=p[g]+t}let h=p[c],f=_a.getArrayFromDType(n,h),m=0;for(let g=0;g<c;++g){let t=p[g+1]-p[g],n=o?e[0]:e[g],r=u?i[0]:i[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[p,f]}var h$=em.RowPartitionType,f$=class e{constructor(e,t,n,r,a,i,s,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=s,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=em.getRowPartitionTypesHelper(u),this.raggedRank=em.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===h$.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===h$.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case h$.VALUE_ROWIDS:return e.getMaxWidthValueRowID(n);case h$.ROW_SPLITS:return e.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${h$[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let i=1;i<t;++i){let t=e[i];t!==r&&(r=t,a=Math.max(i-n,a),n=i)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return g$(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;em.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=em.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],i=0;for(let s=0;s<r;++s,i+=t)a.push(i);for(let s=r;s<e;++s)a.push(-1);return _a.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,i=[];for(let s=0;s<a-1;++s){let a=e[s+1]-e[s],o=Math.min(r,a),l=t[s];-1===l&&(o=0);for(let e=0;e<o;++e)i.push(l),l+=n;for(let e=0;e<a-o;++e)i.push(-1)}if(a>0&&i.length!==e[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,i=[];if(0===a)return[];let s=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];i.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++s,s<r?l+=n:l=-1);else{if(s=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case h$.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case h$.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${h$[i]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case h$.FIRST_DIM_SIZE:return e[0];case h$.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case h$.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${h$[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*t[i+1];let r=g$(t,!1),a=_a.getArrayFromDType(this.valuesDType,_a.sizeFromShape(r));if(n[0]*t[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)i=this.calculateOutputIndex(e-1,i,n[e],t[e]);this.setOutput(this.raggedRank,i,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,i=n,s=r.slice();s=s.slice(e+1);let o=_a.sizeFromShape(s),l=t.length,u=this.defaultValue;if(u.length!==o&&1!==u.length){let e=this.defaultValueShape;ss((()=>{let t=Zo(u,e);u=yl(t,s).dataSync()}))}let d=0,c=0,p=0;for(let h=0;h<=l;++h){let e=h<l?t[h]:-1;if(e!==p){if(c<p){let e=a.subarray(d*o);m$(i.subarray(c*o),e,(p-c)*o)}if(h>=l){let t=n.length;e=Math.floor(t/o)}if(e>p)if(1===this.defaultValue.length)i.subarray(p*o,e*o).fill(this.defaultValue[0]),p=e;else for(;e>p;){m$(i.slice(p*o),u,o),++p}e<0?(d=h+1,c=p):(d=h,c=p,p=c+1)}else++p}}};function m$(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function g$(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function y$(e,t,n,r,a,i,s,o,l,u){return new f$(e,t,n,r,a,i,s,o,l,u).compute()}function b$(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return _a.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((t-e)/n)),i=_a.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),i[0]=e;for(let s=1;s<i.length;s++)i[s]=i[s-1]+n;return i}var v$=eA((e=>1/Math.sqrt(e))),x$=nA(wr,v$),w$={kernelName:wr,backendName:"cpu",kernelFunc:x$};function k$(e,t,n,r,a,i,s,o,l,u){let d=[r/a,a],c=e.values,p=t.values;if(0===r)return yo(n,t.dtype);let h=l instanceof ii?l:yo(d,t.dtype);"string"==typeof l||"number"==typeof l?h.values.fill(l):"boolean"==typeof l&&h.values.fill(+l);for(let f=0;f<i;f++){let e=[],i=0;for(let t=0;t<s;t++){let n=c[f*s+t];e.push(n),i+=n*o[t]}if(i<0||i>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?h.values[i*a+n]+=p[f*a+n]:h.values[i*a+n]=0===t.rank?p[0]:p[f*a+n]}return h}var S$=eA((e=>1/(1+Math.exp(-e)))),I$=tA($r,(e=>1/(1+Math.exp(-e)))),N$={kernelName:$r,backendName:"cpu",kernelFunc:I$};function T$(e,t,n,r,a){let i=Cf.isSliceContinous(r,t,n),s=_a.sizeFromShape(n),o=_a.computeStrides(r);if(i){let n=Cf.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+s):e.subarray(n,n+s)}let l=yo(r,a,"string"===a?em.fromUint8ToStringArray(e):e),u=yo(n,a);for(let d=0;d<u.size;++d){let e=u.indexToLoc(d),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?em.fromStringArrayToUint8(u.values):u.values}function _$(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,size:s}=r;TE(a,"slice");let[o,l]=Cf.parseSliceParams(a,i,s);Cf.assertParamsValid(a,o,l);let u=T$(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var C$={kernelName:_r,backendName:"cpu",kernelFunc:_$};function E$(e,t,n,r,a,i,s){let o=t[0],l=i[0],u=new Array(l),d=new Array(o),c=t[1];if(0===l){if(0!==o)throw new Error(em.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[_a.getArrayFromDType(n,0),[0,c],_a.getArrayFromDType(a,0),u,d]}let p=!0,h=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let t=e[g*c];if(t<0)throw new Error(em.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(em.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],p=p&&t>=h,h=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&p){let t=e,n=r;for(let e=0;e<o;++e)d[e]=e;return[t,[o,c],n,u,d]}{let t=f[l-1],i=_a.getArrayFromDType(n,t*c),p=_a.getArrayFromDType(a,t),h=new Array(l).fill(0);for(let n=0;n<o;++n){let t=e[n*c],a=h[t],s=(0===t?0:f[t-1])+a;h[t]++;for(let r=0;r<c;++r)i[s*c+r]=e[n*c+r];p[s]=r[n],d[n]=s}for(let e=0;e<l;++e)if(0===h[e]){let t=0===e?0:f[e-1];i[t*c+0]=e;for(let e=1;e<c;++e)i[t*c+e]=0;p[t]=s}return[i,[t,c],p,u,d]}}function A$(e,t,n,r,a){let i=_a.sizeFromShape(r),s=t[0],o=a.length,l=[],u=1,d=-1;for(let m=0;m<o;++m){let e=a[m];if(-1===e){if(-1!==d)throw new Error(em.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,m));d=m,l.push(1)}else{if(e<0)throw new Error(em.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==d){if(u<=0)throw new Error(em.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(i/u);if(u*e!==i)throw new Error(em.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[d]=e}if(_a.sizeFromShape(l)!==i)throw new Error(em.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let c=r.length,p=[];if(c>0){p[c-1]=1;for(let e=c-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}let h=[];if(o>0){h[o-1]=1;for(let e=o-2;e>=0;--e)h[e]=h[e+1]*l[e+1]}let f=_a.getArrayFromDType(n,s*o);for(let m=0;m<s;++m){let t=0;for(let n=0;n<c;++n)t+=e[m*c+n]*p[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/h[e]),t%=h[e]}return[f,[s,o],l]}function $$(e,t,n,r,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=r.length,l=[t[0],e.length/t[0]],u=l[1],d=o>0?a[o-1]+1:0;if(d<0)throw new Error(em.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=t.slice();c[0]=d;let p=c.reduce(((e,t)=>e*t),1),h=_a.getArrayFromDType(n,p);if(0===o)return d>0&&h.fill(s),[h,c];if(d<=0)throw new Error(em.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(em.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=d)throw new Error(em.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,d));y>g&&h.fill(s,g*u,y*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(em.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)h[y*u+n]+=e[t*u+n]}if(i)for(let e=0;e<u;e++)h[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<d&&h.fill(s,g*u,d*u),[h,c]}var R$=eA((e=>Math.sqrt(e))),F$=tA(Fr,(e=>Math.sqrt(e))),D$={kernelName:Fr,backendName:"cpu",kernelFunc:F$},M$=RE(((e,t)=>{let n=e-t;return n*n})),O$=VE(Vr,M$),P$={kernelName:Vr,backendName:"cpu",kernelFunc:O$},L$=eA(((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),z$=nA(Hr,L$),B$={kernelName:Hr,backendName:"cpu",kernelFunc:z$};function W$(e,t,n,r){let a=yo(e,t.dtype);for(let i=0;i<a.size;i++){let e=a.indexToLoc(i),s=new Array(e.length);for(let t=0;t<s.length;t++)s[t]=e[t]*n[t]+r[t];a.set(t.get(...s),...e)}return a}var U$=class{constructor(e,t,n,r,a,i){this.separator=_a.encodeString(e),this.nGramWidths=t,this.leftPad=_a.encodeString(n),this.rightPad=_a.encodeString(r),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,i){for(let s=0;s<a;++s){let o=this.getPadWidth(i),l=Math.max(0,o-s),u=Math.max(0,o-(a-(s+1))),d=i-(l+u),c=t+(l>0?0:s-o),p=0;p+=l*this.leftPad.length;for(let t=0;t<d;++t)p+=e[c+t].length;p+=u*this.rightPad.length,p+=(l+u+d-1)*this.separator.length,n[r+s]=new Uint8Array(p);let h=n[r+s],f=0,m=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<d-1;++t)m(e[c+t]),m(this.separator);if(d>0){m(e[c+d-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,i=_a.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)i[t]=0;return[e,i]}i[0]=0;for(let o=1;o<=a;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),i[o]=i[o-1]+n}let s=new Array(i[a]);for(let o=0;o<a;++o){let n=t[o],r=i[o];if(this.nGramWidths.forEach((a=>{let i=t[o+1]-t[o],l=this.getNumNGrams(i,a);this.createNGrams(e,n,s,r,l,a),r+=l})),this.preserveShort&&r===i[o]){let a=t[o+1]-t[o];if(0===a)continue;let i=a+2*this.padWidth;this.createNGrams(e,n,s,r,1,i)}}return[s,i]}};function V$(e,t,n,r,a,i,s,o){return new U$(n,r,a,i,s,o).compute(e,t)}function G$(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],i=e.indexOf(a);for(;-1!==i;){let t=e.subarray(0,i);(!n||0!==t.length)&&r.push(t),i=(e=e.subarray(i+1)).indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){let t=e.subarray(a,i);(!n||0!==t.length)&&r.push(t),a=i+1}}function H$(e,t,n){let r=e.length,a=[],i=0,s=0,o=new Array(r);for(let p=0;p<r;++p){let r=a.length;G$(e[p],t,n,a);let l=a.length-r;o[p]=l,i+=l,s=Math.max(s,l)}let l=_a.getArrayFromDType("int32",2*i),u=new Array(i),d=[r,s],c=0;for(let p=0;p<r;++p)for(let e=0;e<o[p];++e)l[2*c]=p,l[2*c+1]=e,u[c]=a[c],++c;return[l,u,d]}function j$(e,t){let n=_a.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=_a.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var q$=RE(((e,t)=>e-t)),K$=GE(((e,t,n,r)=>({real:e-n,imag:t-r}))),X$=VE(Yr,q$,K$),Y$={kernelName:Yr,backendName:"cpu",kernelFunc:X$};function Q$(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=yo(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let i=e.locToIndex(n);r.values[a]=e.values[i]}return r}var J$=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function Z$(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){let a=r-n+1,i=t-n+1,s=Math.log(a),o=.5*Math.exp(2*s/3),l=.5*Math.sqrt(s*o*(a-o)/a)*Math.sign(i-a/2);Z$(e,t,Math.max(n,Math.floor(t-i*o/a+l)),Math.min(r,Math.floor(t+(a-i)*o/a+l)))}let a=e[t],i=n,s=r;for(_a.swap(e,n,t),J$(e[r],a)>0&&_a.swap(e,n,r);i<s;){for(_a.swap(e,i,s),i++,s--;J$(e[i],a)<0;)i+=1;for(;J$(e[s],a)>0;)s-=1}0===J$(e[n],a)?_a.swap(e,n,s):(s+=1,_a.swap(e,s,r)),s<=t&&(n=s+1),t<=s&&(r=s-1)}}function eR(e,t,n,r,a){let i=t[t.length-1],[s,o]=[e.length/i,i],l=_a.getTypedArrayFromDType(n,s*r),u=_a.getTypedArrayFromDType("int32",s*r);for(let c=0;c<s;c++){let t=c*o,n=e.subarray(t,t+o),i=new Array(n.length);n.forEach(((e,t)=>i[t]={value:e,index:t})),r<i.length&&(Z$(i,r),i=i.slice(0,r)),a&&i.sort(J$);let s=c*r,d=l.subarray(s,s+r),p=u.subarray(s,s+r);for(let e=0;e<r;e++)d[e]=i[e].value,p[e]=i[e].index}let d=t.slice();return d[d.length-1]=r,[yo(d,n,l),yo(d,"int32",u)]}function tR(e,t,n,r){let a=_a.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let f=0;f<a;f++)i[0]*=n[f];i[1]=n[a];for(let f=a+1;f<n.length;f++)i[2]*=n[f];let s=new Map,o=new Int32Array(n[a]),l=new ii(i,r,e),u=[],d=1===i[0]&&1===i[2];for(let f=0;f<n[a];f++){let t;if(d)t=e[f].toString();else{let e=[];for(let t=0;t<i[0];t++)for(let n=0;n<i[2];n++)e.push(l.get(t,f,n));t=e.join(",")}let n=s.get(t);if(null!=n)o[f]=n;else{let e=s.size;s.set(t,e),o[f]=e,u.push(f)}}let c=i.slice();c[1]=s.size;let p=new ii(c,r);u.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)p.set(l.get(n,e,r),n,t,r)}));let h=n.slice();return h[a]=c[1],{outputValues:p.values,outputShape:h,indices:o}}var nR="4.21.0";gs("cpu",(()=>new CE),1);var rR=tA(Kt,(e=>e>=0?e:Math.exp(e)-1)),aR={kernelName:Kt,backendName:"cpu",kernelFunc:rR};function iR(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:i}=r;TE([a],"leakyRelu");let s=_a.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=_a.getTypedArrayFromDType("float32",s);for(let u=0;u<o.length;u++)l[u]=o[u]<0?i*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var sR={kernelName:bn,backendName:"cpu",kernelFunc:iR},oR=RE(((e,t)=>e<0?t*e:e));function lR(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;TE([r,a],"prelu");let i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,[o,l]=oR(r.shape,a.shape,i,s,"float32");return n.makeTensorInfo(l,"float32",o)}var uR={kernelName:ar,backendName:"cpu",kernelFunc:lR},dR=tA(pr,(e=>Math.max(0,e))),cR={kernelName:pr,backendName:"cpu",kernelFunc:dR},pR=tA(br,(e=>Math.min(Math.max(0,e),6))),hR={kernelName:br,backendName:"cpu",kernelFunc:pR};function fR(e,t,n,r,a){if("linear"===n)return OE({inputs:{x:t},backend:e});if("relu"===n)return dR({inputs:{x:t},backend:e});if("elu"===n)return rR({inputs:{x:t},backend:e});if("relu6"===n)return pR({inputs:{x:t},backend:e});if("prelu"===n)return lR({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return iR({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return I$({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function mR(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:i}=r,s=_a.sizeFromShape(a.shape),o=_a.inferFromImplicitShape(i,s),l=_a.sizeFromShape(o);_a.assert(s===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var gR={kernelName:hr,backendName:"cpu",kernelFunc:mR};function yR(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i}=t,{transposeA:s,transposeB:o}=r;TE([a,i],"matMul");let l=a.shape.length,u=i.shape.length,d=s?a.shape[l-2]:a.shape[l-1],c=o?i.shape[u-1]:i.shape[u-2],p=s?a.shape[l-1]:a.shape[l-2],h=o?i.shape[u-2]:i.shape[u-1],f=a.shape.slice(0,-2),m=i.shape.slice(0,-2),g=_a.sizeFromShape(f),y=_a.sizeFromShape(m),b=Wl.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,h]);_a.assert(d===c,(()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`));let v=o?[y,h,c]:[y,c,h],x=mR({inputs:{x:a},backend:n,attrs:{shape:s?[g,d,p]:[g,p,d]}}),w=mR({inputs:{x:i},backend:n,attrs:{shape:v}}),k=s?x.shape[1]:x.shape[2],S=s?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],N=Math.max(g,y),T=n.data.get(x.dataId).values,_=n.data.get(w.dataId).values,C=_a.computeStrides(x.shape),E=_a.computeStrides(w.shape),[A,$,R]=s?[C[0],1,C[1]]:[C[0],C[1],1],[F,D,M]=o?[1,E[1],E[0]]:[E[1],1,E[0]],O=S*I,P=yo([N,S,I],x.dtype),L=P.values,z=n.blockSize;for(let B=0;B<N;B++){let e=B%g,t=B%y;for(let n=0;n<S;n+=z){let r=Math.min(n+z,S);for(let a=0;a<I;a+=z){let i=Math.min(a+z,I);for(let s=0;s<k;s+=z){let o=Math.min(s+z,k);for(let l=n;l<r;l++)for(let n=a;n<i;n++){let r=0;for(let a=s;a<o;a++){r+=T[e*A+l*$+a*R]*_[a*F+n*D+t*M]}L[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}var bR={kernelName:ht,backendName:"cpu",kernelFunc:yR};var vR={kernelName:ca,backendName:"cpu",kernelFunc:function(e){let t,n,r,{inputs:a,backend:i,attrs:s}=e,{a:o,b:l,bias:u,preluActivationWeights:d}=a,{transposeA:c,transposeB:p,activation:h,leakyreluAlpha:f}=s,m=[];t=yR({inputs:{a:o,b:l},attrs:{transposeA:c,transposeB:p},backend:i}),u&&(n=qE({inputs:{a:t,b:u},backend:i}),m.push(t),t=n),h&&(r=fR(i,t,h,d,f),m.push(t),t=r);for(let g of m)i.disposeIntermediateTensorInfo(g);return t}},xR=tA(Ye,(e=>Math.acos(e))),wR={kernelName:Ye,backendName:"cpu",kernelFunc:xR},kR=tA(Qe,(e=>Math.acosh(e))),SR={kernelName:Qe,backendName:"cpu",kernelFunc:kR};var IR={kernelName:Ze,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,r=t;TE(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),i=yo(r[0].shape,r[0].dtype),s=i.values;for(let o=0;o<r.length;o++){let e=a[o];for(let t=0;t<s.length;t++)s[t]+=e[t]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};var NR={kernelName:et,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;TE(a,"all");let o=_a.parseAxisParam(i,a.shape),l=o,u=em.getAxesPermutation(l,a.shape.length),d=a;null!=u&&(d=r$({inputs:{x:a},backend:n,attrs:{perm:u}}),l=em.getInnerMostAxes(l.length,a.shape.length)),em.assertAxesAreInnerMostDims("all",l,d.shape.length);let[c,p]=em.computeOutAndReduceShapes(d.shape,l),h=_a.sizeFromShape(p),f=_a.makeZerosTypedArray(_a.sizeFromShape(c),d.dtype),m=n.data.get(d.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(d);let g=n.makeTensorInfo(c,d.dtype,f);if(s){let e=mR({inputs:{x:g},backend:n,attrs:{shape:em.expandShapeToKeepDim(c,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var TR={kernelName:tt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;TE(a,"any");let o=_a.parseAxisParam(i,a.shape),l=o,u=em.getAxesPermutation(l,a.shape.length),d=a;null!=u&&(d=r$({inputs:{x:a},backend:n,attrs:{perm:u}}),l=em.getInnerMostAxes(l.length,a.shape.length)),em.assertAxesAreInnerMostDims("any",l,d.shape.length);let[c,p]=em.computeOutAndReduceShapes(d.shape,l),h=_a.sizeFromShape(p),f=_a.makeZerosTypedArray(_a.sizeFromShape(c),d.dtype),m=n.data.get(d.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(d);let g=n.makeTensorInfo(c,d.dtype,f);if(s){let e=mR({inputs:{x:g},backend:n,attrs:{shape:em.expandShapeToKeepDim(c,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var _R={kernelName:nt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r;TE(a,"argMax");let s=_a.parseAxisParam(i,a.shape),o=em.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=r$({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=em.getInnerMostAxes(s.length,l.shape.length)),s=[s[0]],em.assertAxesAreInnerMostDims("argMax",s,l.shape.length);let[d,c]=em.computeOutAndReduceShapes(l.shape,s),p=_a.sizeFromShape(d),h=_a.makeZerosTypedArray(p,"int32"),f=_a.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(d,"int32",h)}};var CR={kernelName:rt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r;TE(a,"argMin");let s=_a.parseAxisParam(i,a.shape),o=em.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=r$({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=em.getInnerMostAxes(s.length,l.shape.length)),s=[s[0]],em.assertAxesAreInnerMostDims("argMin",s,l.shape.length);let[d,c]=em.computeOutAndReduceShapes(l.shape,s),p=_a.sizeFromShape(d),h=_a.makeZerosTypedArray(p,"int32"),f=_a.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(d,"int32",h)}},ER=tA(at,(e=>Math.asin(e))),AR={kernelName:at,backendName:"cpu",kernelFunc:ER},$R=tA(it,(e=>Math.asinh(e))),RR={kernelName:it,backendName:"cpu",kernelFunc:$R},FR=tA(st,(e=>Math.atan(e))),DR={kernelName:st,backendName:"cpu",kernelFunc:FR},MR=RE(((e,t)=>Math.atan2(e,t))),OR=VE(lt,MR),PR={kernelName:lt,backendName:"cpu",kernelFunc:OR},LR=tA(ot,(e=>Math.atanh(e))),zR={kernelName:ot,backendName:"cpu",kernelFunc:LR};function BR(e,t,n,r,a,i){let s=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,c=a.effectiveFilterWidth,p=a.padInfo.top,h=a.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=yo(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){let t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){let x=y*s-p,w=Math.max(0,x),k=Math.min(a.inHeight,d+x),S=t+y*b;for(let t=0;t<a.outWidth;++t){let s=t*o-h,d=Math.max(0,s),p=Math.min(a.inWidth,c+s),y=f,b=0,x=0;for(let t=w;t<k;t+=l){let a=n+t*r[1];for(let t=d;t<p;t+=u){let n=e[a+t*r[2]+m];"max"===i&&n>y?y=n:"avg"===i&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===i?b/x:y}}}return m}function WR(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=yo(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m=yo(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*o-h,y=n;for(;y<0;)y+=u;let b=Math.min(r.inHeight,c+n);for(let o=0;o<r.outWidth;++o){let c=o*l-f,h=c;for(;h<0;)h+=d;let v=Math.min(r.inWidth,p+c),x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){let s=t-n;for(let n=h;n<v;n+=d){let o=n-c,l=m.get(g,t,n,e);l>x&&(x=l,w=a?i?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:s*p+o)}}s.set(w,g,t,o,e)}}return s}function UR(e,t,n,r,a,i){let s=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,d=a.dilationHeight,c=a.dilationWidth,p=a.effectiveFilterDepth,h=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=yo(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let N=0;N<a.batchSize;++N){let t=N*w,n=N*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){let N=w*s-m,T=N;for(;T<0;)T+=u;let _=Math.min(a.inDepth,p+N),C=t+w*k;for(let t=0;t<a.outHeight;++t){let s=t*o-g,p=s;for(;p<0;)p+=d;let m=Math.min(a.inHeight,h+s),w=C+t*S;for(let t=0;t<a.outWidth;++t){let s=t*l-y,o=s;for(;o<0;)o+=c;let h=Math.min(a.inWidth,f+s),g=w+t*I,k=b,S=0,N=0;for(let t=T;t<_;t+=u){let a=n+t*r[1];for(let t=p;t<m;t+=d){let n=a+t*r[2];for(let t=o;t<h;t+=c){let a=e[n+t*r[3]+v];if("max"===i&&a>k?k=a:"avg"===i&&(S+=a,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===i?S/Math.max(N,1):k}}}}return v}var VR={kernelName:ut,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;TE(a,"avgPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;_a.assert(em.eitherStridesOrDilationsAreOne(s,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`));let u,d=em.computePool2DInfo(a.shape,i,s,1,o,l);if(1===d.filterWidth&&1===d.filterHeight&&_a.arraysEqual(d.inShape,d.outShape))u=OE({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=_a.computeStrides(a.shape),r=BR(e,a.shape,a.dtype,t,d,"avg");u=n.makeTensorInfo(d.outShape,a.dtype,r.values)}return u}};var GR={kernelName:ct,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r;TE(a,"avgPool3d");let d=em.computePool3DInfo(a.shape,i,s,1,o,l,u),c=UR(n.data.get(a.dataId).values,a.shape,a.dtype,_a.computeStrides(a.shape),d,"avg");return n.makeTensorInfo(c.shape,"float32",c.values)}};var HR={kernelName:pt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r;TE([a,i],"avgPool3DGrad");let d=em.computePool3DInfo(i.shape,s,o,1,l,u),c=d.strideDepth,p=d.strideHeight,h=d.strideWidth,f=d.filterDepth,m=d.filterHeight,g=d.filterWidth,y=d.dilationDepth,b=d.dilationHeight,v=d.dilationWidth,x=d.effectiveFilterDepth,w=d.effectiveFilterHeight,k=d.effectiveFilterWidth,S=x-1-d.padInfo.front,I=k-1-d.padInfo.left,N=w-1-d.padInfo.top,T=yo(i.shape,"float32"),_=1/(f*m*g),C=n.bufferSync(a);for(let E=0;E<d.batchSize;++E)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inDepth;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){let a=t-S,i=n-N,s=r-I,o=0;for(let t=0;t<x;t+=y){let n=(a+t)/c;if(!(n<0||n>=d.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){let r=(i+t)/p;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){let a=(s+t)/h;a<0||a>=d.outWidth||Math.floor(a)!==a||(o+=C.get(E,n,r,a,e))}}}T.set(o*_,E,t,n,r,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};var jR={kernelName:dt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i;TE([a,i],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,d=em.computePool2DInfo(s.shape,o,l,1,u),c=d.strideHeight,p=d.strideWidth,h=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.effectiveFilterHeight,b=d.effectiveFilterWidth,v=b-1-d.padInfo.left,x=y-1-d.padInfo.top,w=yo(s.shape,"float32"),k=1/(h*f),S=n.data.get(a.dataId).values,I=yo(a.shape,"float32",S);for(let N=0;N<d.batchSize;++N)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){let r=t-x,a=n-v,i=0;for(let t=0;t<y;t+=m){let n=(r+t)/c;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){let r=(a+t)/p;r<0||r>=d.outWidth||Math.floor(r)!==r||(i+=I.get(N,n,r,e))}}w.set(i*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};var qR={kernelName:on,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:i,offset:s,mean:o,variance:l}=t;_a.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),_a.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),_a.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),TE([a,o,l,i,s],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let d=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,p=n.data.get(l.dataId).values,h=i?n.data.get(i.dataId).values:new Float32Array([1]),f=s?n.data.get(s.dataId).values:new Float32Array([0]),m=new Float32Array(d.length),g=f.length,y=h.length,b=p.length,v=c.length,x=0,w=0,k=0,S=0;for(let I=0;I<d.length;++I)m[I]=f[x++]+(d[I]-c[w++])*h[k++]/Math.sqrt(p[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};var KR={kernelName:ft,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:s}=r;TE([a],"batchToSpaceND");let o=i.reduce(((e,t)=>e*t)),l=em.getReshaped(a.shape,i,o),u=em.getPermuted(l.length,i.length),d=em.getReshapedPermuted(a.shape,i,o),c=em.getSliceBeginCoords(s,i.length),p=em.getSliceSize(d,s,i.length),h=mR({inputs:{x:a},backend:n,attrs:{shape:l}}),f=r$({inputs:{x:h},backend:n,attrs:{perm:u}}),m=mR({inputs:{x:f},backend:n,attrs:{shape:d}}),g=_$({inputs:{x:m},backend:n,attrs:{begin:c,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};var XR={kernelName:mt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s}=r,o=XE(n.data.get(a.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,o)}};var YR={kernelName:bt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,o=em.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},QR=tA(wt,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),JR={kernelName:wt,backendName:"cpu",kernelFunc:QR},ZR={kernelName:St,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(_a.sizeFromShape(t.shape)),a=n.data.get(t.dataId),i=a.complexTensorInfos.real,s=a.complexTensorInfos.imag,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values;for(let u=0;u<o.length;u++){let e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function eF(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}var tF={kernelName:fn,backendName:"cpu",kernelFunc:eF};function nF(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,i=_a.parseAxisParam(a,t[0].shape)[0],s=t.map((e=>e.shape));em.assertParamsConsistent(s,i);let o=em.computeOutShape(t.map((e=>e.shape)),i);if(0===_a.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>_a.sizeFromShape(e.shape)>0));if(1===l.length)return OE({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map((e=>LE({inputs:{input:e},backend:n}))),t=l.map((e=>eF({inputs:{input:e},backend:n}))),r=nF({inputs:e,backend:n,attrs:{axis:i}}),a=nF({inputs:t,backend:n,attrs:{axis:i}}),s=FE({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),s}let u=l.map((e=>{let t=[-1,_a.sizeFromShape(e.shape.slice(i))];return mR({inputs:{x:e},backend:n,attrs:{shape:t}})})),d=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=em.computeOutShape(u.map((e=>e.shape)),1);let c=1===u[0].shape[0],p=sA(d,o,t[0].dtype,c),h=em.computeOutShape(l.map((e=>e.shape)),i),f=n.makeTensorInfo(h,t[0].dtype,p);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var rF={kernelName:It,backendName:"cpu",kernelFunc:nF};function aF(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dataFormat:l,dilations:u,dimRoundingMode:d}=r;TE([a,i],"conv2d");let c=em.convertConv2DDataFormat(l),p=em.computeConv2DInfo(a.shape,i.shape,s,u,o,d,!1,c),h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.padInfo.left,b=p.padInfo.top,v="channelsLast"===p.dataFormat,x=new ii(p.outShape,a.dtype),w=_a.computeStrides(a.shape),k=_a.computeStrides(i.shape),S=w[0],I=v?w[1]:w[2],N=v?w[2]:1,T=v?1:w[1],_=x.strides[0],C=v?x.strides[1]:x.strides[2],E=v?x.strides[2]:1,A=v?1:x.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(i.dataId).values,F=x.values;for(let D=0;D<p.batchSize;++D){let e=D*S,t=D*_;for(let n=0;n<p.outHeight;++n){let r=t+n*C,a=n*p.strideHeight-b;for(let t=0;t<h;++t){let n=a+t*m;if(n<0||n>=p.inHeight)continue;let i=t*k[0],s=e+n*I;for(let e=0;e<p.outWidth;++e){let t=r+e*E,n=e*p.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=p.inWidth)continue;let a=s+r*N,o=i+e*k[1];for(let e=0;e<p.inChannels;++e){let n=$[a+e*T];for(let e=0;e<p.outChannels;++e)F[t+e*A]+=n*R[o+e];o+=p.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,F)}var iF={kernelName:Nt,backendName:"cpu",kernelFunc:aF};var sF={kernelName:Tt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:d}=r;TE([a,i],"conv2dBackpropFilter");let c=em.convertConv2DDataFormat(l),p=em.computeConv2DInfo(a.shape,d,s,1,o,u,!1,c),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=p,y="channelsLast"===p.dataFormat,b=new ii(p.filterShape,"float32"),v=p.padInfo.left,x=p.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(i.dataId).values,S=new ii(a.shape,a.dtype,w),I=new ii(i.shape,i.dtype,k);for(let N=0;N<m;++N){let e=Math.max(0,Math.ceil((x-N)/h)),t=Math.min(p.outHeight,(p.inHeight+x-N)/h);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(p.outWidth,(p.inWidth+v-n)/f);for(let i=0;i<p.inChannels;++i)for(let s=0;s<p.outChannels;++s){let o=0;for(let l=0;l<p.batchSize;++l)for(let u=e;u<t;++u){let e=N+u*h-x;for(let t=r;t<a;++t){let r=n+t*f-v;o+=y?S.get(l,e,r,i)*I.get(l,u,t,s):S.get(l,i,e,r)*I.get(l,s,u,t)}}b.set(o,N,n,i,s)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var oF={kernelName:_t,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{inputShape:s,strides:o,pad:l,dataFormat:u,dimRoundingMode:d}=r;TE([a,i],"conv2dBackpropInput");let c=_a.computeStrides(i.shape),p=_a.computeStrides(a.shape),h=em.convertConv2DDataFormat(u),f=em.computeConv2DInfo(s,i.shape,o,1,l,d,!1,h),m=new ii(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(i.dataId).values,[v,x,w]=c,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:T,inWidth:_,outChannels:C,outHeight:E,outWidth:A,strideHeight:$,strideWidth:R}=f;h=f.dataFormat;let F=S-1-f.padInfo.top,D=I-1-f.padInfo.left,M="channelsLast"===h,O=m.strides[0],P=M?m.strides[1]:m.strides[2],L=M?m.strides[2]:1,z=M?1:m.strides[1],B=p[0],W=M?p[1]:p[2],U=M?p[2]:1,V=M?1:p[1];for(let G=0;G<k;++G)for(let e=0;e<N;++e)for(let t=0;t<T;++t){let n=t-F,r=Math.max(0,Math.ceil(n/$)),a=Math.min(E,(S+n)/$);for(let i=0;i<_;++i){let s=i-D,o=Math.max(0,Math.ceil(s/R)),l=Math.min(A,(I+s)/R),u=0;for(let t=r;t<a;++t){let r=t*$-n;for(let n=o;n<l;++n){let a=B*G+W*t+U*n,i=v*(S-1-r)+x*(I-1-(n*R-s))+w*e;for(let e=0;e<C;++e){u+=y[a+V*e]*b[i+e]}}}g[O*G+P*t+L*i+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};var lF={kernelName:Ct,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r;TE([a,i],"conv3d");let u=em.computeConv3DInfo(a.shape,i.shape,s,l,o),{filterDepth:d,filterHeight:c,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new ii(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(i.dataId).values,S=x.values,I=_a.computeStrides(a.shape),N=_a.computeStrides(i.shape);for(let T=0;T<u.batchSize;++T){let e=T*I[0],t=T*x.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<d;++t){let n=a+t*h;if(n<0||n>=u.inDepth)continue;let i=t*N[0],s=e+n*I[1];for(let e=0;e<u.outHeight;++e){let t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<c;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=i+e*N[1],o=s+r*I[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<p;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let i=a+e*N[2],s=o+t*u.inChannels,l=i;for(let e=0;e<u.inChannels;++e){let t=w[s+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};var uF={kernelName:Et,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,filterShape:l}=r;TE([a,i],"conv3dBackpropFilterV2");let u=_a.computeStrides(a.shape),d=_a.computeStrides(i.shape),c=em.computeConv3DInfo(a.shape,l,s,1,o),p=c.strideDepth,h=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=new ii(c.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(i.dataId).values,[N,T,_,C]=d,E=n.data.get(a.dataId).values,[A,$,R,F]=u,D=c.padInfo.front,M=c.padInfo.left,O=c.padInfo.top;for(let P=0;P<m;++P){let e=Math.max(0,Math.ceil((D-P)/p)),t=Math.min(c.outDepth,(c.inDepth+D-P)/p),n=P*x;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/h)),i=Math.min(c.outHeight,(c.inHeight+O-r)/h),s=r*w+n;for(let n=0;n<y;++n){let o=Math.max(0,Math.ceil((M-n)/f)),l=Math.min(c.outWidth,(c.inWidth+M-n)/f),u=n*k+s;for(let s=0;s<c.inChannels;++s){let d=s*S+u;for(let u=0;u<c.outChannels;++u){let m=0;for(let d=0;d<c.batchSize;++d){let c=d*A,g=d*N;for(let d=e;d<t;++d){let e=(P+d*p-D)*$+c,t=d*T+g;for(let d=a;d<i;++d){let a=(r+d*h-O)*R+e,i=d*_+t;for(let e=o;e<l;++e){let t=e*C+i;m+=E[(n+e*f-M)*F+a+s]*I[t+u]}}}}v[d+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var dF={kernelName:At,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:s,strides:o,inputShape:l}=r;TE([a],"conv3dBackpropInputV2");let u=_a.computeStrides(a.shape),d=_a.computeStrides(i.shape),c=em.computeConv3DInfo(l,i.shape,o,1,s),p=new ii(c.inShape,"float32"),h=p.values,[f,m,g,y]=p.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(i.dataId).values,[I,N,T,_]=d,{batchSize:C,filterDepth:E,filterHeight:A,filterWidth:$,inChannels:R,inDepth:F,inHeight:D,inWidth:M,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:U}=c,V=E-1-c.padInfo.front,G=A-1-c.padInfo.top,H=$-1-c.padInfo.left;for(let j=0;j<C;++j)for(let e=0;e<R;++e)for(let t=0;t<F;++t){let n=t-V,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(E+n)/B);for(let i=0;i<D;++i){let s=i-G,o=Math.max(0,Math.ceil(s/W)),l=Math.min(L,(A+s)/W);for(let u=0;u<M;++u){let d=u-H,c=Math.max(0,Math.ceil(d/U)),p=Math.min(z,($+d)/U),C=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=o;n<l;++n){let a=n*W-s;for(let i=c;i<p;++i){let s=v*j+x*t+w*n+k*i,o=I*(E-1-r)+N*(A-1-a)+T*($-1-(i*U-d))+_*e;for(let e=0;e<O;++e){C+=b[s+e]*S[o+e]}}}}h[f*j+m*t+g*i+y*u+e]=C}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}},cF=tA($t,(e=>Math.cos(e))),pF={kernelName:$t,backendName:"cpu",kernelFunc:cF},hF=tA(Rt,(e=>Math.cosh(e))),fF={kernelName:Rt,backendName:"cpu",kernelFunc:hF};var mF={kernelName:Mt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:i,boxInd:s}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[d,c,p,h]=a.shape,f=i.shape[0],[m,g]=o,y=yo([f,m,g,h],"float32"),b=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,x=n.data.get(a.dataId).values,w=_a.computeStrides(a.shape),k=_a.computeStrides(y.shape);for(let S=0;S<f;S++){let e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],i=v[S];if(i>=d)continue;let s=m>1?(r-t)*(c-1)/(m-1):0,o=g>1?(a-n)*(p-1)/(g-1):0;for(let d=0;d<m;d++){let e=m>1?t*(c-1)+d*s:.5*(t+r)*(c-1);if(e<0||e>c-1)for(let t=0;t<g;t++)for(let e=0;e<h;e++){let n=e+t*k[2]+d*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),s=e-t;for(let e=0;e<g;e++){let l=g>1?n*(p-1)+e*o:.5*(n+a)*(p-1);if(l<0||l>p-1){for(let t=0;t<h;t++){let n=t+e*k[2]+d*k[1]+S*k[0];y.values[n]=u}continue}let c=Math.floor(l),f=Math.ceil(l),m=l-c;for(let n=0;n<h;n++){let a=n+c*w[2]+t*w[1]+i*w[0],o=x[a];a=n+f*w[2]+t*w[1]+i*w[0];let l=x[a];a=n+c*w[2]+r*w[1]+i*w[0];let u=x[a];a=n+f*w[2]+r*w[1]+i*w[0];let p=o+(l-o)*m,h=u+(x[a]-u)*m;a=n+e*k[2]+d*k[1]+S*k[0],y.values[a]=p+(h-p)*s}}}else for(let t=0;t<g;++t){let r=g>1?n*(p-1)+t*o:.5*(n+a)*(p-1);if(r<0||r>p-1){for(let e=0;e<h;e++){let n=e+t*k[2]+d*k[1]+S*k[0];y.values[n]=u}continue}let s=Math.round(r),l=Math.round(e);for(let e=0;e<h;e++){let n=e+s*w[2]+l*w[1]+i*w[0],r=e+t*k[2]+d*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var gF={kernelName:Ft,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;TE(a,"cumprod");let l=em.getAxesPermutation([i],a.shape.length),u=a;null!=l&&(u=r$({inputs:{x:a},backend:n,attrs:{perm:l}}));let d=em.getInnerMostAxes(1,a.shape.length)[0];if(d!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${d}`);let c=vi(u.dtype,"int32"),p=_a.makeOnesTypedArray(_a.sizeFromShape(u.shape),c),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)p[t]=s?1:h[t];else{let n=m(y,e-1);p[t]=s?h[n]*p[n]:h[t]*p[n]}}let g=n.makeTensorInfo(u.shape,c,p);if(null!=l){let e=r$({inputs:{x:g},backend:n,attrs:{perm:em.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var yF={kernelName:Dt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;TE(a,"cumsum");let l=em.getAxesPermutation([i],a.shape.length),u=a;null!=l&&(u=r$({inputs:{x:a},backend:n,attrs:{perm:l}}));let d=em.getInnerMostAxes(1,a.shape.length)[0];if(d!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${d}`);let c=vi(u.dtype,"int32"),p=_a.makeZerosTypedArray(_a.sizeFromShape(u.shape),c),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)p[t]=s?0:h[t];else{let n=m(y,e-1);p[t]=s?h[n]+p[n]:h[t]+p[n]}}let g=n.makeTensorInfo(u.shape,c,p);if(null!=l){let e=r$({inputs:{x:g},backend:n,attrs:{perm:em.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var bF={kernelName:Ot,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s,binaryOutput:o}=r;if(1===a.shape.length){let e=XE(n.data.get(a.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,e)}if(2===a.shape.length){let e=YE(n.bufferSync(a),n.bufferSync(i),s,o);return n.makeTensorInfo(e.shape,i.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};var vF={kernelName:Pt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:i,dataFormat:s}=r;_a.assert("NHWC"===s,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],d=a.shape[3],c=l*i,p=u*i,h=d/(i*i),f=n.data.get(a.dataId).values,m=new Float32Array(o*c*p*h),g=0;for(let y=0;y<o;++y)for(let e=0;e<c;++e){let t=Math.floor(e/i),n=e%i;for(let e=0;e<p;++e){let r=Math.floor(e/i),a=(n*i+e%i)*h;for(let e=0;e<h;++e){let n=e+a+d*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,c,p,h],a.dtype,m)}};function xF(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l,dimRoundingMode:u}=r;TE([a,i],"depthwiseConv2DNative");let d=_a.computeStrides(a.shape),c=_a.computeStrides(i.shape),p=l;null==p&&(p=[1,1]),_a.assert(em.eitherStridesOrDilationsAreOne(s,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`));let h=em.computeConv2DInfo(a.shape,i.shape,s,p,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=h,v=b.left,x=b.top,w=h.outChannels/h.inChannels,k=new ii(h.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(i.dataId).values,N=k.values;for(let T=0;T<h.batchSize;++T){let e=T*d[0],t=T*k.strides[0];for(let n=0;n<h.outHeight;++n){let r=t+n*k.strides[1],a=n*h.strideHeight-x;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=h.inHeight)continue;let i=t*c[0],s=e+n*d[1];for(let e=0;e<h.outWidth;++e){let t=r+e*k.strides[2],n=e*h.strideWidth-v;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=h.inWidth)continue;let a=i+e*c[1],o=s+r*h.inChannels,l=t,u=a;for(let e=0;e<h.inChannels;++e){let t=S[o+e];for(let e=0;e<w;++e)N[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var wF={kernelName:Lt,backendName:"cpu",kernelFunc:xF};var kF={kernelName:zt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,filterShape:d}=r;TE([a,i],"depthwiseConv2dNativeBackpropFilter");let c=em.computeConv2DInfo(a.shape,d,s,o,l,u,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:m}=c,g=new ii(c.filterShape,"float32"),y=c.padInfo.left,b=c.padInfo.top,v=c.outChannels/c.inChannels,x=n.data.get(a.dataId).values,w=new ii(a.shape,a.dtype,x),k=n.data.get(i.dataId).values,S=new ii(i.shape,i.dtype,k);for(let I=0;I<f;++I){let e=Math.max(0,Math.ceil((b-I)/p)),t=Math.min(c.outHeight,(c.inHeight+b-I)/p);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((y-n)/h)),a=Math.min(c.outWidth,(c.inWidth+y-n)/h);for(let i=0;i<c.outChannels;++i){let s=Math.trunc(i/v),o=i%v,l=0;for(let u=0;u<c.batchSize;++u)for(let o=e;o<t;++o){let e=I+o*p-b;for(let t=r;t<a;++t){let r=n+t*h-y;l+=w.get(u,e,r,s)*S.get(u,o,t,i)}}g.set(l,I,n,s,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var SF={kernelName:Bt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,inputShape:d}=r;TE([a,i],"depthwiseConv2DNativeBackpropInput");let c=_a.computeStrides(a.shape),p=_a.computeStrides(i.shape),h=em.computeConv2DInfo(d,i.shape,s,o,l,u,!0),f=new ii(h.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=c,S=n.data.get(i.dataId).values,[I,N,T]=p,{batchSize:_,filterHeight:C,filterWidth:E,inChannels:A,inHeight:$,inWidth:R,outChannels:F,outHeight:D,outWidth:M,strideHeight:O,strideWidth:P}=h,L=C-1-h.padInfo.top,z=E-1-h.padInfo.left,B=F/A;for(let W=0;W<_;++W)for(let e=0;e<A;++e)for(let t=0;t<$;++t){let n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(D,(C+n)/O);for(let i=0;i<R;++i){let s=i-z,o=Math.max(0,Math.ceil(s/P)),l=Math.min(M,(E+s)/P),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=o;n<l;++n){let a=x*W+w*t+k*n,i=I*(C-1-r)+N*(E-1-(n*P-s))+T*e;for(let t=0;t<B;++t){u+=v[a+(e*B+t)]*S[i+t]}}}m[g*W+y*t+b*i+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};var IF={kernelName:Wt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=_a.sizeFromShape(r.shape),i=n.data.get(r.dataId).values,s=yo([a,a],r.dtype),o=s.values;for(let u=0;u<i.length;u++)o[u*a+u]=i[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,s.dtype,s.values)}},NF={kernelName:Ut,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r,u=n,d=u.data.get(a.dataId).values,c=a.shape.length,p=u.data.get(i.dataId).values,h=i.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:_}=em.computeDilation2DInfo(a.shape,i.shape,s,o,"NHWC",l),C=_a.sizeFromShape(_),E=_.length,A=_a.getArrayFromDType(a.dtype,C);for(let $=0;$<f;++$)for(let e=0;e<b;++e){let t=e*w-x.top;for(let n=0;n<v;++n){let r=n*k-x.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){let n=t+e*N;if(n>=0&&n<m)for(let t=0;t<I;++t){let l=r+t*T;if(l>=0&&l<g){let r=_a.locToIndex([$,n,l,s],c,_a.computeStrides(a.shape)),u=_a.locToIndex([e,t,s],h,_a.computeStrides(i.shape)),f=d[r]+p[u];f>o&&(o=f)}}}A[_a.locToIndex([$,e,n,s],E,_a.computeStrides(_))]=o}}}return{dataId:u.write(_a.toTypedArray(A,a.dtype),_,a.dtype),shape:_,dtype:a.dtype}}},TF={kernelName:Gt,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:s}=t,{strides:o,pad:l,dilations:u}=r,d=n,c=_a.toNestedArray(a.shape,d.data.get(a.dataId).values),p=_a.toNestedArray(i.shape,d.data.get(i.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:T}=em.computeDilation2DInfo(a.shape,i.shape,o,l,"NHWC",u);_a.assert(s.rank===T.length,(()=>`Error in ${Gt}, dy must have the same rank as output ${T.length}, but got ${s.rank}`));let _=_a.toNestedArray(T,d.data.get(s.dataId).values),C=_a.makeZerosNestedTypedArray(i.shape,i.dtype);for(let E=0;E<h;++E)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let i=Number.MIN_SAFE_INTEGER,s=0,o=0;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*N;if(l>=0&&l<m){let r=c[E][n][l][a]+p[e][t][a];r>i&&(i=r,s=e,o=t)}}}C[s][o][a]+=_[E][e][n][a]}}}return{dataId:d.write(_a.toTypedArray(C,a.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},_F={kernelName:Vt,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:s}=t,{strides:o,pad:l,dilations:u}=r,d=n,c=_a.toNestedArray(a.shape,d.data.get(a.dataId).values),p=_a.toNestedArray(i.shape,d.data.get(i.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:T}=em.computeDilation2DInfo(a.shape,i.shape,o,l,"NHWC",u);_a.assert(s.rank===T.length,(()=>`Error in ${Vt}, dy must have the same rank as output ${T.length}, but got ${s.rank}`));let _=_a.toNestedArray(T,d.data.get(s.dataId).values),C=_a.makeZerosNestedTypedArray(a.shape,a.dtype);for(let E=0;E<h;++E)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let i=Number.MIN_SAFE_INTEGER,s=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*N;if(l>=0&&l<m){let r=c[E][n][l][a]+p[e][t][a];r>i&&(i=r,s=n,o=l)}}}C[E][s][o][a]+=_[E][e][n][a]}}}return{dataId:d.write(_a.toTypedArray(C,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var CF={kernelName:Ht,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:i,options:s}=r,{contextOptions:o,imageOptions:l}=s||{},u=(null==l?void 0:l.alpha)||1,d=(null==o?void 0:o.contextType)||"2d";if("2d"!==d)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let c=i.getContext(d,(null==o?void 0:o.contextAttributes)||{});if(null==c)throw new Error(`Could not get the context with ${d} type.`);let[p,h]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(h*p*4);for(let v=0;v<p*h;++v){let e=[0,0,0,255*u];for(let n=0;n<f;n++){let t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}let t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}i.width=h,i.height=p;let b=new ImageData(y,h,p);return c.putImageData(b,0,0),a}};function EF(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{axis:s,keepDims:o}=a;TE(i,"sum"),t="bool"===i.dtype?WE({inputs:{x:i},backend:r,attrs:{dtype:"int32"}}):OE({inputs:{x:i},backend:r});let l=t.shape.length,u=_a.parseAxisParam(s,t.shape),d=em.getAxesPermutation(u,l),c=u,p=t;null!=d&&(p=r$({inputs:{x:t},backend:r,attrs:{perm:d}}),c=em.getInnerMostAxes(c.length,l)),em.assertAxesAreInnerMostDims("sum",c,p.shape.length);let[h,f]=em.computeOutAndReduceShapes(p.shape,c),m=ME(r,h,em.upcastType(p.dtype,"int32")),g=_a.sizeFromShape(f),y=r.data.get(m.dataId).values,b=r.data.get(p.dataId).values;for(let v=0;v<y.length;++v){let e=v*g,t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(o){let e=m;m=mR({inputs:{x:m},backend:r,attrs:{shape:em.expandShapeToKeepDim(m.shape,u)}}),r.disposeIntermediateTensorInfo(e)}return r.disposeIntermediateTensorInfo(t),null!=d&&r.disposeIntermediateTensorInfo(p),m}var AF={kernelName:Dr,backendName:"cpu",kernelFunc:EF};var $F={kernelName:qt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,i=t,{allDims:s,summedDims:o,idDims:l}=em.decodeEinsumEquation(a,i.length);em.checkEinsumDimSizes(s.length,l,i);let{path:u,steps:d}=em.getEinsumComputePath(o,l),c=d.length,p=null,h=s.length,f=[];for(let m=0;m<c;++m){for(let e of d[m]){let t,{permutationIndices:r,expandDims:a}=em.getEinsumPermutation(h,l[e]);em.isIdentityPermutation(r)?t=i[e]:(t=r$({inputs:{x:i[e]},backend:n,attrs:{perm:r}}),f.push(t));let s=t.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);_a.arraysEqual(t.shape,s)||(t=mR({inputs:{x:t},backend:n,attrs:{shape:s}}),f.push(t)),null===p?p=t:(p=XA({inputs:{a:t,b:p},backend:n}),f.push(p))}m<c-1&&(u[m]>=0&&(p=EF({inputs:{x:p},backend:n,attrs:{axis:u[m]-(s.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}};var RF={kernelName:Xt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;TE([r,a],"eluGrad");let i=new Float32Array(_a.sizeFromShape(a.shape)),s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<s.length;++l){let e=s[l];i[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",i)}},FF=em.ERF_P,DF=em.ERF_A1,MF=em.ERF_A2,OF=em.ERF_A3,PF=em.ERF_A4,LF=em.ERF_A5,zF=tA(Yt,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+FF*n);return t*(1-((((LF*r+PF)*r+OF)*r+MF)*r+DF)*r*Math.exp(-n*n))})),BF={kernelName:Yt,backendName:"cpu",kernelFunc:zF};function WF(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:i}=r,s=a.shape.length,o=a.shape.slice(),l=i;return i<0&&(_a.assert(-(s+1)<=i,(()=>`Axis must be in the interval [${-(s+1)}, ${s}]`)),l=s+i+1),o.splice(l,0,1),mR({inputs:{x:a},backend:n,attrs:{shape:o}})}var UF={kernelName:Zt,backendName:"cpu",kernelFunc:WF},VF=RE(((e,t)=>e/t)),GF=VE(jt,VF),HF={kernelName:jt,backendName:"cpu",kernelFunc:GF};function jF(e,t,n){let r=e.shape,a=r[0],i=r[1],s=n.data.get(e.dataId),o=s.complexTensorInfos.real,l=s.complexTensorInfos.imag,u=[a,i],d=_a.sizeFromShape(u),c=_a.getTypedArrayFromDType("float32",d),p=_a.getTypedArrayFromDType("float32",d);for(let g=0;g<a;g++){let e=_$({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,i]}}),r=_$({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,i]}}),a=FE({inputs:{real:e,imag:r},backend:n}),{real:s,imag:u}=qF(a,t,n),d=em.mergeRealAndImagArrays(s,u);for(let t=0;t<i;t++){let e=em.getComplexWithIndex(d,t);c[g*i+t]=e.real,p[g*i+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let h=n.makeTensorInfo(u,"float32",c),f=n.makeTensorInfo(u,"float32",p),m=FE({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function qF(e,t,n){let r=_a.sizeFromShape(e.shape),a=n.data.get(e.dataId),i=n.data.get(a.complexTensorInfos.real.dataId).values,s=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function(e){return 0===(e&e-1)}(r)){let a=KF(i,s,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),i=n.makeTensorInfo([],"float32",_a.createScalarValue(r,"float32")),s=OE({inputs:{x:i},backend:n}),l=HF.kernelFunc({inputs:{a:e,b:i},backend:n}),u=HF.kernelFunc({inputs:{a:t,b:s},backend:n}),d=n.data.get(l.dataId).values,c=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:d,imag:c}}return a}{let e=function(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let i=0,s=0;for(let r=0;r<t;r++){let o=em.exponent(a*r,t,n),l=em.getComplexWithIndex(e,r);i+=l.real*o.real-l.imag*o.imag,s+=l.real*o.imag+l.imag*o.real}n&&(i/=t,s/=t),em.assignToTypedArray(r,i,s,a)}return r}(em.mergeRealAndImagArrays(i,s),r,t);return em.splitRealAndImagArrays(e)}}function KF(e,t,n,r,a){if(1===n)return{real:e,imag:t};let i=em.mergeRealAndImagArrays(e,t),s=n/2,o=em.complexWithEvenIndex(i),l=o.real,u=o.imag,d=[l.length],c=a.makeTensorInfo(d,"float32",l),p=a.makeTensorInfo(d,"float32",u),h=FE({inputs:{real:c,imag:p},backend:a}),f=em.complexWithOddIndex(i),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=FE({inputs:{real:b,imag:v},backend:a}),w=KF(l,u,s,r,a),k=w.real,S=w.imag,I=[k.length],N=a.makeTensorInfo(I,"float32",k),T=a.makeTensorInfo(I,"float32",S),_=FE({inputs:{real:N,imag:T},backend:a}),C=KF(m,g,s,r,a),E=C.real,A=C.imag,$=[E.length],R=a.makeTensorInfo($,"float32",E),F=a.makeTensorInfo($,"float32",A),D=FE({inputs:{real:R,imag:F},backend:a}),M=em.exponents(n,r),O=[M.real.length],P=a.makeTensorInfo(O,"float32",M.real),L=a.makeTensorInfo(O,"float32",M.imag),z=FE({inputs:{real:P,imag:L},backend:a}),B=XA({inputs:{a:z,b:D},backend:a}),W=qE({inputs:{a:_,b:B},backend:a}),U=X$({inputs:{a:_,b:B},backend:a}),V=LE({inputs:{input:W},backend:a}),G=LE({inputs:{input:U},backend:a}),H=eF({inputs:{input:W},backend:a}),j=eF({inputs:{input:U},backend:a}),q=nF({inputs:[V,G],backend:a,attrs:{axis:0}}),K=nF({inputs:[H,j],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}var XF={kernelName:tn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=_a.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],s=mR({inputs:{x:r},backend:n,attrs:{shape:[a/i,i]}}),o=jF(s,!1,n),l=mR({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),l}};function YF(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:i}=n,s=i||_a.inferDtype(a),o=_a.getArrayFromDType(s,_a.sizeFromShape(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,s,o)}var QF={kernelName:nn,backendName:"cpu",kernelFunc:YF};var JF={kernelName:rn,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,i=r,s=_a.getTypedArrayFromDType(a.dtype,_a.sizeFromShape(a.shape)),[o,l,u,d]=a.shape,c=i.data.get(a.dataId).values;for(let p=0;p<o;p++){let e=p*u*l*d;for(let t=0;t<l;t++){let n=t*(u*d);for(let t=0;t<u;t++){let r=t*d;for(let a=0;a<d;a++){let i=Math.round(u-t-1),o=e+n+r+a,l=c[o];if(i>=0&&i<u){l=c[e+n+i*d+a]}s[o]=l}}}}return{dataId:i.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var ZF={kernelName:pa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=aF({inputs:{x:a,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p}});if(s){let e=m;if("NCHW"===d&&1===s.shape.length&&1!==s.shape[0]){let e=mR({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=qE({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=qE({inputs:{a:m,b:s},backend:n});n.disposeIntermediateTensorInfo(e)}if(h){let e=m;if("NCHW"===d&&"prelu"===h&&1===o.shape.length&&1!==o.shape[0]){let e=mR({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=fR(n,m,h,e,f),n.disposeIntermediateTensorInfo(e)}else m=fR(n,m,h,o,f);n.disposeIntermediateTensorInfo(e)}return m}};var eD={kernelName:ha,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=xF({inputs:{x:a,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p}});if(s){let e=m;m=qE({inputs:{a:m,b:s},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){let e=m;m=fR(n,m,h,o,f),n.disposeIntermediateTensorInfo(e)}return m}};var tD={kernelName:un,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,i=_a.sizeFromShape(r.shape),s=a.shape,o=s[s.length-1],[l,u,d,c]=em.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let p=kA(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,d,c,r.shape,i);return n.makeTensorInfo(l,r.dtype,p.values)}};var nD={kernelName:ln,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:i}=t,{axis:s,batchDims:o}=r;TE([a,i],"gatherV2");let l=_a.parseAxisParam(s,a.shape)[0],u=n.data.get(i.dataId).values,d=a.shape[l];for(let v=0;v<u.length;++v){let e=u[v];_a.assert(e<=d-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${d-1}]`))}let c=o;null==o&&(c=0);let p=_a.sizeFromShape(i.shape),h=em.segment_util.collectGatherOpShapeInfo(a,i,l,c),f=mR({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=mR({inputs:{x:i},backend:n,attrs:{shape:[h.batchSize,p/h.batchSize]}}),g=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],y=n.bufferSync(m),b=SA(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,b.dtype,b.values)}};var rD={kernelName:hn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=_a.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],s=mR({inputs:{x:r},backend:n,attrs:{shape:[a/i,i]}}),o=jF(s,!0,n),l=mR({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),l}},aD=tA(mn,(e=>Number.isFinite(e)?1:0),"bool"),iD={kernelName:mn,backendName:"cpu",kernelFunc:aD},sD=tA(gn,(e=>Math.abs(e)===1/0?1:0),"bool"),oD={kernelName:gn,backendName:"cpu",kernelFunc:sD},lD=tA(yn,(e=>Number.isNaN(e)?1:0),"bool"),uD={kernelName:yn,backendName:"cpu",kernelFunc:lD};var dD={kernelName:wn,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:i}=n,s=OA(r,a,i);return t.makeTensorInfo([s.length],"float32",s)}},cD=tA(Sn,(e=>Math.log1p(e))),pD={kernelName:Sn,backendName:"cpu",kernelFunc:cD},hD=RE(((e,t)=>e&&t)),fD=VE(In,hD,null,"bool"),mD={kernelName:In,backendName:"cpu",kernelFunc:fD},gD=tA(Nn,(e=>e?0:1),"bool"),yD={kernelName:Nn,backendName:"cpu",kernelFunc:gD},bD=RE(((e,t)=>e||t)),vD=VE(Tn,bD,null,"bool"),xD={kernelName:Tn,backendName:"cpu",kernelFunc:vD};var wD={kernelName:An,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:s,alpha:o,beta:l}=r;TE(a,"LRN");let u=a.shape[3],d=u-1,c=n.data.get(a.dataId).values,p=_a.sizeFromShape(a.shape),h=new Float32Array(p);function f(e){let t=e%u,n=e-t+Math.max(0,t-i),r=e-t+Math.min(t+i,d),a=0;for(;n<=r;n++){let e=c[n];a+=e*e}return a}for(let m=0;m<p;m++){let e=f(m),t=c[m]*Math.pow(s+o*e,-l);h[m]=t}return n.makeTensorInfo(a.shape,a.dtype,h)}};var kD={kernelName:$n,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:s}=t,{depthRadius:o,bias:l,alpha:u,beta:d}=r;TE(s,"LRNGrad");let c=_a.sizeFromShape(s.shape),p=s.shape[3],h=n.data.get(s.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(i.dataId).values,g=new Float32Array(c),y=c;for(let b=0;b<y;b++){let e=b%p,t=b-e+Math.max(0,e-o),n=b-e+Math.min(p,e+o+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*d*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-d)),e*=h[b],g[a]+=e}}return n.makeTensorInfo(s.shape,a.dtype,g)}};function SD(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:i,keepDims:s}=r,o=n,l=a.shape,u=l.length,d=_a.parseAxisParam(i,l),c=d,p=em.getAxesPermutation(c,u),h=o.data.get(a.dataId).values;if(null!=p){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[p[t]];h=n$(h,l,a.dtype,p,e),c=em.getInnerMostAxes(c.length,u),l=e}TE(a,"max"),em.assertAxesAreInnerMostDims("max",c,u);let[f,m]=em.computeOutAndReduceShapes(l,c),g=BA(h,_a.sizeFromShape(m),f,a.dtype),y=o.write(g,f,a.dtype),b=f;return s&&(b=em.expandShapeToKeepDim(f,d)),{dataId:y,shape:b,dtype:a.dtype}}var ID={kernelName:Fn,backendName:"cpu",kernelFunc:SD};var ND={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;TE(a,"maxPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;_a.assert(em.eitherStridesOrDilationsAreOne(s,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`));let u,d=em.computePool2DInfo(a.shape,i,s,1,o,l);if(1===d.filterWidth&&1===d.filterHeight&&_a.arraysEqual(d.inShape,d.outShape))u=OE({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=_a.computeStrides(a.shape),r=BR(e,a.shape,a.dtype,t,d,"max");u=n.makeTensorInfo(d.outShape,a.dtype,r.values)}return u}};var TD={kernelName:Pn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r;TE(a,"maxPool3d");let d=em.computePool3DInfo(a.shape,i,s,1,o,l,u),c=UR(n.data.get(a.dataId).values,a.shape,a.dtype,_a.computeStrides(a.shape),d,"max");return n.makeTensorInfo(c.shape,"float32",c.values)}};var _D={kernelName:Ln,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r;TE([a,i],"maxPool3DGrad");let d=em.computePool3DInfo(i.shape,s,o,1,l,u),c=function(e,t){let n=yo(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,d=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-p,v=b;for(;v<0;)v+=s;let x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-h,p=u;for(;p<0;)p+=o;let w=Math.min(t.inHeight,d+u);for(let a=0;a<t.outWidth;++a){let h=a*i-f,k=h;for(;k<0;)k+=l;let S=Math.min(t.inWidth,c+h),I=Number.NEGATIVE_INFINITY,N=-1;for(let t=v;t<x;t+=s){let n=t-b;for(let r=p;r<w;r+=o){let a=r-u;for(let i=k;i<S;i+=l){let s=i-h,o=e.get(m,t,r,i,g);o>=I&&(I=o,N=n*d*c+a*d+s)}}}n.set(N,m,y,r,a,g)}}}return n}(n.bufferSync(i),d),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.dilationDepth,g=d.dilationHeight,y=d.dilationWidth,b=d.effectiveFilterDepth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=b-1-d.padInfo.front,k=x-1-d.padInfo.left,S=v-1-d.padInfo.top,I=yo(i.shape,"float32"),N=n.bufferSync(a);for(let T=0;T<d.batchSize;++T)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inDepth;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){let a=t-w,i=n-S,s=r-k,o=0;for(let t=0;t<b;t+=m){let n=(a+t)/p;if(!(n<0||n>=d.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){let a=(i+r)/h;if(!(a<0||a>=d.outHeight||Math.floor(a)!==a))for(let i=0;i<x;i+=y){let l=(s+i)/f;if(l<0||l>=d.outWidth||Math.floor(l)!==l)continue;let u=b*v*x-1-c.get(T,n,a,l,e)===t*v*x+r*x+i?1:0;0!==u&&(o+=N.get(T,n,a,l,e)*u)}}}I.set(o,T,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var CD={kernelName:On,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i,output:s}=t,o=i;TE([i,s],"maxPoolGrad");let{filterSize:l,strides:u,pad:d,dimRoundingMode:c}=r,p=em.computePool2DInfo(o.shape,l,u,1,d,c),h=n.data.get(o.dataId).values,f=yo(p.outShape,o.dtype,WR(h,o.shape,o.dtype,p).values),m=p.strideHeight,g=p.strideWidth,y=p.dilationHeight,b=p.dilationWidth,v=p.effectiveFilterHeight,x=p.effectiveFilterWidth,w=x-1-p.padInfo.left,k=v-1-p.padInfo.top,S=yo(o.shape,"float32"),I=n.data.get(a.dataId).values,N=yo(a.shape,"float32",I);for(let T=0;T<p.batchSize;++T)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){let r=t-k,a=n-w,i=0;for(let t=0;t<v;t+=y){let n=(r+t)/m;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){let s=(a+r)/g;if(s<0||s>=p.outWidth||Math.floor(s)!==s)continue;let o=v*x-1-f.get(T,n,s,e)===t*x+r?1:0;0!==o&&(i+=N.get(T,n,s,e)*o)}}S.set(i,T,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};var ED={kernelName:zn,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:l}=n,u=r;TE(a,"MaxPoolWithArgmax");let d=u.data.get(a.dataId).values,c=em.computePool2DInfo(a.shape,i,s,[1,1],o),[p,h]=function(e,t,n,r,a){let i=BR(e,0,n,_a.computeStrides(t),a,"max"),s=WR(e,t,n,a,!0,r);return[i.values,s.values]}(d,a.shape,a.dtype,l,c),f=u.write(p,c.outShape,a.dtype),m=u.write(h,c.outShape,a.dtype);return[{dataId:f,shape:c.outShape,dtype:a.dtype},{dataId:m,shape:c.outShape,dtype:"int32"}]}};var AD={kernelName:Bn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=_a.parseAxisParam(i,a.shape),l=em.computeOutAndReduceShapes(a.shape,o)[1],u=_a.sizeFromShape(l),d=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));d.push(c);let p=WE({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});d.push(p);let h=GF({inputs:{a:p,b:c},backend:n});d.push(h);let f=EF({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:s}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};var $D={kernelName:Wn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;TE(a,"min");let o=_a.parseAxisParam(i,a.shape),l=o,u=em.getAxesPermutation(l,a.shape.length),d=a;null!=u&&(d=r$({inputs:{x:a},backend:n,attrs:{perm:u}}),l=em.getInnerMostAxes(l.length,a.shape.length)),em.assertAxesAreInnerMostDims("min",l,d.shape.length);let[c,p]=em.computeOutAndReduceShapes(d.shape,l),h=_a.sizeFromShape(p),f=_a.makeZerosTypedArray(_a.sizeFromShape(c),d.dtype),m=n.data.get(d.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(d);let g=n.makeTensorInfo(c,d.dtype,f);if(s){let e=mR({inputs:{x:g},backend:n,attrs:{shape:em.expandShapeToKeepDim(c,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var RD={kernelName:Vn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,mode:s}=r;TE(a,"mirrorPad");let o=i.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=i.map((e=>e[0])),u=i.map(((e,t)=>e[0]+a.shape[t])),d="reflect"===s?0:1,c=n.data.get(a.dataId).values,p=a.shape.length,h=_a.computeStrides(a.shape),f=_a.sizeFromShape(o),m=o.length,g=_a.computeStrides(o),y=_a.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=_a.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-d:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+d);e=e.map(((e,t)=>e-l[t]));let t=_a.locToIndex(e,p,h);y[b]=c[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},FD=RE(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),DD=VE(Gn,FD),MD={kernelName:Gn,backendName:"cpu",kernelFunc:DD},OD=k(D());function PD(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:i}=r,s=a.shape.length,o=i;if(-1===o&&(o=s-1),o!==s-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s} and dim was ${o}`);let l=_a.parseAxisParam([o],a.shape),u=SD({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),d=em.expandShapeToKeepDim(u.shape,l),c=mR({inputs:{x:u},backend:n,attrs:{shape:d}}),p=X$({inputs:{a:a,b:c},backend:n}),h=cA({inputs:{x:p},backend:n}),f=EF({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),m=mR({inputs:{x:f},backend:n,attrs:{shape:d}}),g=GF({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var LD={kernelName:Pr,backendName:"cpu",kernelFunc:PD};var zD={kernelName:Hn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:s,normalized:o}=r;TE(a,"multinomial");let l=o?a:PD({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],d=l.shape[1],c=n.data.get(l.dataId).values,p=[u,i],h=_a.makeZerosTypedArray(_a.sizeFromShape(p),"int32");for(let f=0;f<u;++f){let e=f*d,t=new Float32Array(d-1);t[0]=c[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+c[e+a];let n=OD.alea(s.toString()),r=f*i;for(let a=0;a<i;++a){let e=n();h[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){h[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",h)}},BD=sg.nonMaxSuppressionV3Impl;var WD={kernelName:Xn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l}=r;TE(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,{selectedIndices:c}=BD(u,d,s,o,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}},UD=sg.nonMaxSuppressionV4Impl;var VD={kernelName:Yn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;TE(a,"NonMaxSuppressionPadded");let d=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:p,validOutputs:h}=UD(d,c,s,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},GD=sg.nonMaxSuppressionV5Impl;var HD={kernelName:Qn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;TE(a,"NonMaxSuppressionWithScore");let d=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,p=s,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=GD(d,c,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};var jD={kernelName:Zn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:s,onValue:o,offValue:l}=r;TE(a,"oneHot");let u=_a.sizeFromShape(a.shape),d=new Float32Array(u*s);d.fill(l);let c=n.data.get(a.dataId).values;for(let p=0;p<u;++p)c[p]>=0&&c[p]<s&&(d[p*s+c[p]]=o);return n.makeTensorInfo([...a.shape,s],i,d)}};function qD(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=LE({inputs:{input:r},backend:n}),t=qD({inputs:{x:e},backend:n}),a=eF({inputs:{input:r},backend:n}),i=qD({inputs:{x:a},backend:n}),s=FE({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),s}return YF({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var KD={kernelName:oa,backendName:"cpu",kernelFunc:qD};var XD={kernelName:Jn,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){let t=LE({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),i=eF({inputs:{input:a},backend:r}),s=qD({inputs:{x:i},backend:r}),o=FE({inputs:{real:n,imag:s},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(s),o}return YF({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function YD(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return WF({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,s=t[0].dtype;t.forEach((e=>{_a.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),_a.assert(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=nF({inputs:t.map((e=>{let t=WF({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}var QD={kernelName:er,backendName:"cpu",kernelFunc:YD};var JD={kernelName:tr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,constantValue:s}=r;TE(a,"pad");let o=i.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=i.map((e=>e[0])),u=n.data.get(a.dataId).values,d=_a.sizeFromShape(a.shape),c=a.shape.length,p=_a.computeStrides(a.shape),h=_a.sizeFromShape(o),f=o.length,m=_a.computeStrides(o),g=_a.getTypedArrayFromDType(a.dtype,h);0!==s&&g.fill(s);for(let y=0;y<d;y++){let e=_a.indexToLoc(y,c,p).map(((e,t)=>e+l[t]));g[_a.locToIndex(e,f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},ZD=RE(((e,t)=>Math.pow(e,t))),eM=VE(rr,ZD),tM={kernelName:rr,backendName:"cpu",kernelFunc:eM};var nM={kernelName:sr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:i,indices:s}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),d=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,[p,h,f]=d$(l,u,d,i.shape,i.dtype,c,s.shape),m=p.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,i.dtype,h);return m.concat([g])}};var rM={kernelName:or,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:i}=t,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,d]=p$(s,r.shape,r.dtype,o,a.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([d.length],r.dtype,d)]}};var aM={kernelName:lr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:i,defaultValue:s,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,p=o.map((e=>n.data.get(e.dataId).values)),h=o.map((e=>e.shape)),[f,m]=y$(u,a.shape,d,i.shape,i.dtype,c,s.shape,p,h,l);return n.makeTensorInfo(f,i.dtype,m)}};var iM={kernelName:ur,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:i,step:s}=n,o=b$(r,a,s,i);return t.makeTensorInfo([o.length],i,o)}},sM=tA(cr,(e=>1/e)),oM={kernelName:cr,backendName:"cpu",kernelFunc:sM};var lM={kernelName:gr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r;TE(a,"resizeBilinear");let l=_a.computeStrides(a.shape),[u,d]=o,[c,p,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(_a.sizeFromShape([c,u,d,f])),y=[i&&u>1?p-1:p,i&&d>1?h-1:h],b=[i&&u>1?u-1:u,i&&d>1?d-1:d],v=0,x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<c;k++)for(let e=0;e<u;e++){let t;t=s?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(p-1,Math.ceil(t)),i=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<d;e++){let t;t=s?w*(e+.5)-.5:w*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(h-1,Math.ceil(t)),d=i+n*l[2],c=o+n*l[2],p=i+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){let t=m[d+e],n=m[c+e],i=t+(m[p+e]-t)*a,s=i+(n+(m[y+e]-n)*a-i)*r;g[v++]=s}}}return n.makeTensorInfo([c,u,d,f],"float32",g)}};var uM={kernelName:yr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r;TE([i,a],"resizeBilinearGrad");let o=_a.computeStrides(a.shape),[l,u,d,c]=a.shape,[,p,h]=i.shape,f=new Float32Array(l*u*d*c),m=[s&&p>1?u-1:u,s&&h>1?d-1:d],g=[s&&p>1?p-1:p,s&&h>1?h-1:h],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(i.dataId).values,x=0;for(let w=0;w<l;w++){let e=w*o[0];for(let t=0;t<p;t++){let n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),i=e+r*o[1],s=e+a*o[1],l=n-r,p=1-l;for(let e=0;e<h;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),d-1),a=t-n,u=1-a,h=i+n*o[2],m=i+r*o[2],g=s+n*o[2],y=s+r*o[2],w=p*u,k=p*a,S=l*u,I=l*a;for(let e=0;e<c;e++){let t=v[x++];f[h+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,d,u,c],"float32",f)}};var dM={kernelName:fr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r;TE(a,"resizeNearestNeighbor");let l=_a.computeStrides(a.shape),[u,d]=o,[c,p,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(c*u*d*f),y=[i&&u>1?p-1:p,i&&d>1?h-1:h],b=[i&&u>1?u-1:u,i&&d>1?d-1:d],v=y[0]/b[0],x=y[1]/b[1],w=0;for(let k=0;k<c;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=s?v*(t+.5):v*t,r=Math.min(p-1,i?Math.round(n):Math.floor(n));s&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<d;e++){let t=s?x*(e+.5):x*e,n=Math.min(h-1,i?Math.round(t):Math.floor(t));s&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([c,u,d,f],a.dtype,g)}};var cM={kernelName:mr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r;TE([i,a],"resizeNearestNeighborGrad");let o=_a.computeStrides(a.shape),l=_a.computeStrides(i.shape),[u,d,c,p]=a.shape,[,h,f]=i.shape,m=new Float32Array(u*d*c*p),g=n.data.get(i.dataId).values,y=[s&&h>1?d-1:d,s&&f>1?c-1:c],b=[s&&h>1?h-1:h,s&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let N=0;N<u;N++){let e=N*o[0];for(let t=0;t<d;t++){let n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let i=0;i<c;i++){let r=n+i*o[2],u=Math.floor(i*k),y=Math.floor(u-I/2);for(let n=0;n<p;n++){let o=0;for(let r=0;r<S;r++){let u=r+a;if(u<0||u>=h)continue;let p=e+u*l[1],m=u*v;if(t===Math.min(d-1,s?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){let t=e+y;if(t<0||t>=f)continue;let r=p+t*l[2],a=t*x;i===Math.min(c-1,s?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};var pM={kernelName:vr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r;TE(a,"reverse");let s=a.shape.length,o=_a.parseAxisParam(i,a.shape);if(0===s)return OE({inputs:{x:a},backend:n});let l=new ii(a.shape,a.dtype),u=n.bufferSync(a);for(let d=0;d<l.size;d++){let e=l.indexToLoc(d),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},hM={kernelName:da,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:i,fillValue:s,center:o}=n,l=r,u=_a.getTypedArrayFromDType(a.dtype,_a.sizeFromShape(a.shape)),[d,c,p,h]=a.shape,[f,m]=em.getImageCenter(o,c,p),g=Math.sin(i),y=Math.cos(i),b=l.data.get(a.dataId).values;for(let v=0;v<d;v++){let e=v*p*c*h;for(let t=0;t<c;t++){let n=t*(p*h);for(let r=0;r<p;r++){let a=r*h;for(let i=0;i<h;i++){let o=[d,t,r,i],l=o[2],v=o[1],x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=s;if("number"!=typeof s&&(k=3===i?255:s[i]),x>=0&&x<p&&w>=0&&w<c){k=b[e+w*(p*h)+x*h+i]}u[e+n+a+i]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},fM=tA(xr,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),mM={kernelName:xr,backendName:"cpu",kernelFunc:fM};var gM={kernelName:kr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:i}=t,{shape:s}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:d,outputSize:c}=em.calculateShapes(i,a,s),p=k$(n.bufferSync(a),n.bufferSync(i),s,c,u,l,o,d,0,!0);return n.makeTensorInfo(s,p.dtype,p.values)}};function yM(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function bM(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var vM={kernelName:Ir,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:s}=r,o=function(e,t,n,r,a,i){let s=_a.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)s[l+e]="left"===i?yM(n,t[e+l]):bM(n,t[e+l])}return s}(n.data.get(a.dataId).values,n.data.get(i.dataId).values,a.shape[0],a.shape[1],i.shape[1],s);return n.makeTensorInfo(i.shape,"int32",o)}};var xM={kernelName:Nr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t;TE([r,a,i],"select");let s=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values,d=vi(a.dtype,i.dtype),c=_a.makeZerosTypedArray(_a.sizeFromShape(a.shape),d),p=0,h=0===s||s>1||1===a.shape.length?1:_a.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<h;e++)1===o[f]?c[p++]=l[f]:c[p++]=u[f];return n.makeTensorInfo(a.shape,d,c)}},wM=em.SELU_SCALEALPHA,kM=em.SELU_SCALE,SM=tA(Tr,(e=>e>=0?kM*e:wM*(Math.exp(e)-1))),IM={kernelName:Tr,backendName:"cpu",kernelFunc:SM},NM=tA(Ar,(e=>e<0?-1:e>0?1:0)),TM={kernelName:Ar,backendName:"cpu",kernelFunc:NM},_M=tA(Cr,(e=>Math.sin(e))),CM={kernelName:Cr,backendName:"cpu",kernelFunc:_M},EM=tA(Er,(e=>Math.sinh(e))),AM={kernelName:Er,backendName:"cpu",kernelFunc:EM},$M=Math.log(1.1920928955078125e-7)+2,RM=tA(Rr,(e=>{let t,n=e>-$M,r=e<$M,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),FM={kernelName:Rr,backendName:"cpu",kernelFunc:RM};var DM={kernelName:Mr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:s}=r;TE([a],"spaceToBatchND");let o=_a.sizeFromShape(i),l=[[0,0]];l.push(...s);for(let g=1+i.length;g<a.shape.length;++g)l.push([0,0]);let u=JD.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=em.getReshaped(u.shape,i,o,!1),c=em.getPermuted(d.length,i.length,!1),p=em.getReshapedPermuted(u.shape,i,o,!1),h=mR({inputs:{x:u},backend:n,attrs:{shape:d}}),f=r$({inputs:{x:h},backend:n,attrs:{perm:c}}),m=mR({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}};var MM={kernelName:Lr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:i,defaultValue:s}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values,d=n.data.get(s.dataId).values[0],[c,p,h,f,m]=E$(o,r.shape,r.dtype,l,a.dtype,u,d);return[n.makeTensorInfo(p,r.dtype,c),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var OM={kernelName:zr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,d,c]=A$(o,r.shape,r.dtype,s,l);return[n.makeTensorInfo(d,r.dtype,u),n.makeTensorInfo([c.length],i.dtype,new Int32Array(c))]}};var PM={kernelName:Br,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,d]=$$(s,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(d,r.dtype,u)}};var LM={kernelName:Wr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,d]=$$(s,r.shape,r.dtype,o,l);return n.makeTensorInfo(d,r.dtype,u)}};var zM={kernelName:Ur,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:i,sparseValues:s,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:h}=em.calculateShapes(s,i,l),f=!1,m=r.bufferSync(i);switch(s.dtype){case"bool":t=k$(m,r.bufferSync(s),l,h,c,d,u,p,!!r.data.get(o.dataId).values[0],f);break;case"float32":case"int32":t=k$(m,r.bufferSync(s),l,h,c,d,u,p,r.data.get(o.dataId).values[0],f);break;case"string":t=k$(m,r.bufferSync(s),l,h,c,d,u,p,_a.decodeString(r.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}};var BM={kernelName:Or,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:s}=r,o=_a.parseAxisParam(s,a.shape)[0],l=em.prepareSplitSize(a,i,o),u=new Array(a.shape.length).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[o]=e;let r=_$({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},WM={kernelName:Gr,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e,{x:r}=t,a=n;TE(r,"square");let i=a.data.get(r.dataId).values,s=new Float32Array(i.length);for(let o=0;o<i.length;++o){let e=i[o];s[o]=e*e}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},UM=tA(la,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),VM={kernelName:la,backendName:"cpu",kernelFunc:UM};var GM={kernelName:jr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,end:s,strides:o,beginMask:l,endMask:u,ellipsisMask:d,newAxisMask:c,shrinkAxisMask:p}=r;TE(a,"stridedSlice");let h,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=Cf.sliceInfo(a.shape,i,s,o,l,u,d,c,p);if(g)h=mR({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){_a.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=Cf.computeOutShape(v,x,w),t=_$({inputs:{x:a},backend:n,attrs:{begin:v,size:e}});h=mR({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=W$(f,n.bufferSync(a),w,v);h=n.makeTensorInfo(m,e.dtype,e.values)}return h}};var HM={kernelName:qr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:i,leftPad:s,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:d,dataSplits:c}=t,p=n.data.get(d.dataId).values,h=n.data.get(c.dataId).values,[f,m]=V$(p,h,a,i,s,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}};var jM={kernelName:Kr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:i,delimiter:s}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);let o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values[0],[u,d,c]=H$(o,l,a),p=d.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",d),n.makeTensorInfo([2],"int32",new Int32Array(c))]}};var qM={kernelName:Xr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let s=j$(n.data.get(i.dataId).values,a);return n.makeTensorInfo(i.shape,"int32",s)}},KM=tA(Qr,(e=>Math.tan(e))),XM={kernelName:Qr,backendName:"cpu",kernelFunc:KM},YM=tA(Jr,(e=>Math.tanh(e)));var QM={kernelName:Sr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:i}=t,{sliceRank:s,numUpdates:o,sliceSize:l,strides:u,outputSize:d}=em.calculateShapes(i,a,r.shape),c=n.bufferSync(a),p=n.bufferSync(i),h=n.bufferSync(r),f=k$(c,p,r.shape,d,l,o,s,u,h,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};var JM={kernelName:Zr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:i}=r;TE(a,"tile");let s=Q$(n.bufferSync(a),i);return n.makeTensorInfo(s.shape,s.dtype,s.values)}};var ZM={kernelName:ea,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:s}=r;TE(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=eR(o,a.shape,a.dtype,i,s);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};var eO={kernelName:ta,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:i}=t,{interpolation:s,fillMode:o,fillValue:l,outputShape:u}=n,[d,c,p,h]=a.shape,[f,m]=null!=u?u:[c,p],g=[d,f,m,h],y=_a.computeStrides(a.shape),b=y[0],v=y[1],x=y[2],w=_a.computeStrides(g),k=w[0],S=w[1],I=w[2],N=_a.getTypedArrayFromDType(a.dtype,_a.sizeFromShape(g));N.fill(l);let T=r.data.get(a.dataId).values,_=r.data.get(i.dataId).values;for(let C=0;C<d;++C){let e=1===i.shape[0]?_:_.subarray(8*C,8*C+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<h;++r){let a,i=e[6]*n+e[7]*t+1;if(0===i)continue;let u=(e[0]*n+e[1]*t+e[2])/i,d=(e[3]*n+e[4]*t+e[5])/i,h=tO(u,p,o),f=tO(d,c,o);switch(s){case"nearest":a=rO(T,c,p,b,v,x,C,f,h,r,l);break;case"bilinear":a=aO(T,c,p,b,v,x,C,f,h,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${s}`)}N[C*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,N)}return{dataId:r.write(N,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function tO(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return _a.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return _a.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return _a.clamp(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function nO(e,t,n,r,a,i,s,o,l,u,d){return 0<=o&&o<t&&0<=l&&l<n?e[s*r+o*a+l*i+u]:d}function rO(e,t,n,r,a,i,s,o,l,u,d){return nO(e,t,n,r,a,i,s,Math.round(o),Math.round(l),u,d)}function aO(e,t,n,r,a,i,s,o,l,u,d){let c=Math.floor(o),p=Math.floor(l),h=c+1,f=p+1;return(h-o)*((f-l)*nO(e,t,n,r,a,i,s,c,p,u,d)+(l-p)*nO(e,t,n,r,a,i,s,c,f,u,d))+(o-c)*((f-l)*nO(e,t,n,r,a,i,s,h,p,u,d)+(l-p)*nO(e,t,n,r,a,i,s,h,f,u,d))}var iO={kernelName:ra,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t;TE(i,"unique");let s=r.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:u}=tR(s,a,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var sO={kernelName:aa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let s=a.shape.length,o=a.shape[i],l=new Array(s-1),u=0;for(let h=0;h<s;h++)h!==i&&(l[u++]=a.shape[h]);let d=new Array(s).fill(0),c=a.shape.slice();c[i]=1;let p=new Array(o);for(let h=0;h<p.length;h++){d[i]=h;let e=_$({inputs:{x:a},backend:n,attrs:{begin:d,size:c}});p[h]=mR({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return p}};var oO={kernelName:ia,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:i}=t,{numSegments:s}=r;TE(a,"unsortedSegmentSum");let o=[],l=[],u=a.shape.length-i.shape.length,d=i;for(let p=0;p<u;++p){let e=WF({inputs:{input:d},backend:n,attrs:{dim:p+1}});d=e,l.push(e)}for(let p=0;p<s;++p){let e=_a.createScalarValue(p,"int32"),t=n.makeTensorInfo([],"int32",e),r=lA({inputs:{a:t,b:d},backend:n}),i=WE({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),s=XA({inputs:{a:i,b:a},backend:n}),u=EF({inputs:{x:s},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(i),l.push(s),l.push(u)}let c=YD({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},lO=[vR,$E,wR,SR,KE,IR,NR,TR,_R,CR,AR,RR,DR,PR,zR,VR,GR,HR,jR,bR,qR,KR,XR,ZE,YR,UE,iA,JR,DE,ZR,rF,iF,sF,oF,lF,uF,dF,pF,fF,mF,gF,yF,bF,vF,wF,kF,SF,IF,NF,TF,_F,CF,$F,aR,RF,uA,BF,pA,UF,mA,XF,QF,JF,bA,wA,ZF,eD,tD,nD,TA,EA,PE,rD,tF,iD,oD,uD,sR,RA,MA,dD,zA,pD,mD,yD,xD,wD,kD,ID,VA,ND,TD,_D,CD,ED,AD,$D,jA,RD,MD,zD,YA,JA,WD,VD,HD,t$,jD,XD,QD,JD,tM,uR,s$,nM,rM,aM,iM,zE,HF,oM,cR,hR,gR,lM,uM,dM,cM,pM,hM,mM,w$,gM,vM,xM,IM,N$,TM,CM,AM,C$,LD,FM,DM,MM,OM,PM,LM,zM,BM,D$,WM,P$,B$,VM,GM,HM,jM,qM,Y$,AF,XM,{kernelName:Jr,backendName:"cpu",kernelFunc:YM},QM,JM,ZM,eO,a$,iO,sO,oO,KD];for(let n of lO)wa(n);var uO={};w(uO,{assertNotComplex:()=>bP,bindCanvasToFramebuffer:()=>KO,bindColorTextureToFramebuffer:()=>XO,bindTextureToProgramUniformSampler:()=>qO,bindTextureUnit:()=>VO,bindVertexBufferToProgramAttribute:()=>UO,callAndCheck:()=>wO,canBeRepresented:()=>IO,createFragmentShader:()=>CO,createFramebuffer:()=>WO,createProgram:()=>FO,createStaticIndexBuffer:()=>PO,createStaticVertexBuffer:()=>OO,createTexture:()=>zO,createVertexShader:()=>_O,getBatchDim:()=>tP,getExtensionOrThrow:()=>TO,getFramebufferErrorMessage:()=>JO,getMaxTexturesInShader:()=>dP,getNumChannels:()=>LO,getProgramUniformLocation:()=>jO,getProgramUniformLocationOrThrow:()=>HO,getRowsCols:()=>nP,getShapeAs3D:()=>rP,getTextureShapeFromLogicalShape:()=>aP,getWebGLDisjointQueryTimerVersion:()=>cP,getWebGLErrorMessage:()=>NO,getWebGLMaxTextureSize:()=>oP,hasExtension:()=>pP,isCapableOfRenderingToFloatTexture:()=>fP,isDownloadFloatTextureEnabled:()=>mP,isReshapeFree:()=>sP,isWebGLFenceEnabled:()=>yP,isWebGLVersionEnabled:()=>hP,linkProgram:()=>DO,logShaderSourceAndInfoLog:()=>RO,resetMaxTextureSize:()=>lP,resetMaxTexturesInShader:()=>uP,unbindColorTextureFromFramebuffer:()=>YO,unbindTextureUnit:()=>GO,validateFramebuffer:()=>QO,validateProgram:()=>MO,validateTextureSize:()=>BO});var dO,cO,pO,hO={},fO={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function mO(e,t){hO[e]=t}function gO(e,t){if(!(e in hO)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!Ge().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete hO[e]}),!1),Ge().getBool("SOFTWARE_WEBGL_ENABLED")&&(fO.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",fO)||n.getContext("experimental-webgl",fO):n.getContext("webgl2",fO)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;hO[e]=n}let n=hO[e];return null==n||n.isContextLost()?(delete hO[e],gO(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),hO[e])}function yO(e,t){return[t,e]}function bO(e){let t=_a.sizeFromShape(e),n=Math.ceil(t/4);return _a.sizeToSquarishShape(n)}function vO(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function xO(e,t){let n,r,a,i,s,o,l,u,d,c,p=e;return 2===Ge().getNumber("WEBGL_VERSION")?(n=p.R32F,r=p.R16F,a=p.RGBA16F,i=p.RGBA32F,s=p.RED,l=4,u=1,d=p.HALF_FLOAT,c=p.FLOAT,o=p.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,i=p.RGBA,s=e.RGBA,l=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,c=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:s,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:c}}function wO(e,t){let n=t();return Ge().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+NO(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(dO||(dO={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(cO||(cO={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(pO||(pO={}));var kO=5.96e-8,SO=65504;function IO(e){return!!(Ge().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||kO<Math.abs(e)&&Math.abs(e)<SO)}function NO(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function TO(e,t){return ZO(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function _O(e,t){let n=ZO(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(wO(e,(()=>e.shaderSource(n,t))),wO(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function CO(e,t){let n=ZO(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(wO(e,(()=>e.shaderSource(n,t))),wO(e,(()=>e.compileShader(n))),Ge().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw RO(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var EO,AO,$O=/ERROR: [0-9]+:([0-9]+):/g;function RO(e,t){let n=$O.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),i=a.length.toString().length+2,s=a.map(((e,t)=>_a.rightPad((t+1).toString(),i)+e)),o=0;for(let c=0;c<s.length;c++)o=Math.max(s[c].length,o);let l=s.slice(0,r-1),u=s.slice(r-1,r),d=s.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${_a.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function FO(e){return ZO(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function DO(e,t){if(wO(e,(()=>e.linkProgram(t))),!Ge().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function MO(e,t){if(wO(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function OO(e,t){let n=ZO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),wO(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function PO(e,t){let n=ZO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),wO(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function LO(){return 2===Ge().getNumber("WEBGL_VERSION")?1:4}function zO(e){return ZO(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function BO(e,t){let n=Ge().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function WO(e){return ZO(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function UO(e,t,n,r,a,i,s){let o=e.getAttribLocation(t,n);return-1!==o&&(wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),wO(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,i,s))),wO(e,(()=>e.enableVertexAttribArray(o))),!0)}function VO(e,t,n){eP(e,n),wO(e,(()=>e.activeTexture(e.TEXTURE0+n))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function GO(e,t){eP(e,t),wO(e,(()=>e.activeTexture(e.TEXTURE0+t))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function HO(e,t,n){return ZO(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function jO(e,t,n){return e.getUniformLocation(t,n)}function qO(e,t,n,r){wO(e,(()=>VO(e,t,r))),wO(e,(()=>e.uniform1i(n,r)))}function KO(e){wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wO(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),wO(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function XO(e,t,n){wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),wO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function YO(e,t){wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),wO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function QO(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+JO(e,t))}function JO(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ZO(e,t,n){let r=wO(e,(()=>t()));if(null==r)throw new Error(n);return r}function eP(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function tP(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return _a.sizeFromShape(e.slice(0,e.length-t))}function nP(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function rP(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[tP(e),...nP(e)]),t}function aP(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Ge().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ge().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ge().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?_a.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length&&(e=_a.squeezeShape(e).newShape);let a=_a.sizeFromShape(e),i=null;e.length<=1&&a<=n?i=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?i=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);let s=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||s)if(t){let t=tP(e),n=2,r=2;e.length&&([n,r]=nP(e)),a=t*(n/2)*(r/2),i=_a.sizeToSquarishShape(a).map((e=>2*e))}else i=_a.sizeToSquarishShape(a);return i}function iP(e){return e%2===0}function sP(e,t){if(e=e.slice(-2),t=t.slice(-2),_a.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||iP(n)&&iP(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&iP(e[0])&&iP(t[0])}function oP(e){if(null==EO){let t=gO(e);EO=t.getParameter(t.MAX_TEXTURE_SIZE)}return EO}function lP(){EO=null}function uP(){AO=null}function dP(e){if(null==AO){let t=gO(e);AO=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,AO)}function cP(e){if(0===e)return 0;let t,n=gO(e);return t=pP(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:pP(n,"EXT_disjoint_timer_query")?1:0,t}function pP(e,t){return null!=e.getExtension(t)}function hP(e){try{if(null!=gO(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function fP(e){if(0===e)return!1;let t=gO(e);if(1===e){if(!pP(t,"OES_texture_float"))return!1}else if(!pP(t,"EXT_color_buffer_float"))return!1;return gP(t)}function mP(e){if(0===e)return!1;let t=gO(e);if(1!==e){if(pP(t,"EXT_color_buffer_float"))return gP(t);let e="EXT_color_buffer_half_float";if(pP(t,e)){let n=t.getExtension(e);return function(e,t){let n=xO(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),i}(t,n)}return!1}return!(!pP(t,"OES_texture_float")||!pP(t,"WEBGL_color_buffer_float"))&&gP(t)}function gP(e){let t=xO(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function yP(e){return 2===e&&null!=gO(e).fenceSync}function bP(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&_a.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var vP=Ge();function xP(){let e,t,n,r,a,i,s,o,l,u;return 2===Ge().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",i="outputColor",s="out vec4 outputColor;",o=Ge().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",i="gl_FragColor",s="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:i,defineOutput:s,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function wP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=_a.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function kP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=_a.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function SP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=function(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let i=n-3;i>=0;--i)a[i]=`(${a[i+1]} * ${r[i+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function IP(e){let t=_a.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}vP.registerFlag("HAS_WEBGL",(()=>vP.getNumber("WEBGL_VERSION")>0)),vP.registerFlag("WEBGL_VERSION",(()=>hP(2)?2:hP(1)?1:0)),vP.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),vP.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===vP.get("WEBGL_VERSION"))),vP.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),vP.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),vP.registerFlag("WEBGL_PACK",(()=>vP.getBool("HAS_WEBGL"))),vP.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_CLIP",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_REDUCE",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_LAZILY_UNPACK",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_CONV_IM2COL",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>vP.getBool("WEBGL_PACK"))),vP.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>oP(vP.getNumber("WEBGL_VERSION")))),vP.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>dP(vP.getNumber("WEBGL_VERSION")))),vP.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=vP.getNumber("WEBGL_VERSION");return 0===e?0:cP(e)})),vP.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>vP.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Mi.isMobile())),vP.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>fP(vP.getNumber("WEBGL_VERSION")))),vP.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!vP.getBool("WEBGL_FORCE_F16_TEXTURES")&&vP.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),vP.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>mP(vP.getNumber("WEBGL_VERSION")))),vP.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>yP(vP.getNumber("WEBGL_VERSION")))),vP.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>vP.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),vP.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),vP.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Mi.isMobile()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),vP.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),vP.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),vP.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),vP.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),vP.registerFlag("WEBGL_EXP_CONV",(()=>!1)),vP.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>vP.getBool("IS_TEST"))),vP.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),vP.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),vP.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),vP.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var NP="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:TP}=em;function _P(e,t,n){let r=[];if(e.forEach((e=>{let t=_a.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=LP(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,i,s=r.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?EP(e,r):CP(e,r);let i=e.shapeInfo.logicalShape,s=t.logicalShape;return i.length<=s.length&&(a+=n?function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),i="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=TP(e.shapeInfo.logicalShape,t.logicalShape),u=PP(o),d=o-s,c=["x","y","z","w","u","v"];n=0===s?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${c[e+d]} = 0;`)).join("\n");let p="";p=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${c[t+d]}`)).join(", ");let h="return outputValue;",f=1===_a.sizeFromShape(e.shapeInfo.logicalShape),m=1===_a.sizeFromShape(t.logicalShape);if(1!==s||f||m){if(f&&!m)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=s-2,t=s-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?h="return vec4(outputValue.x);":l.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${p});\n      ${h}\n    }\n  `}(e,t):function(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",i=t.texShape,s=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&_a.arraysEqual(s,i))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,d=PP(l),c=TP(e.shapeInfo.logicalShape,t.logicalShape),p=l-o,h=["x","y","z","w","u","v"];u=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${h[e+p]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+p]}`)).join(", "),`\n    float ${a}() {\n      ${d} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=xP(),d=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u),c=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${AP}\n    ${$P}\n    ${RP}\n  `}(u);return t.isPacked?(a=function(e,t,n){switch(e.length){case 0:return DP();case 1:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(_a.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),i=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),i=a*Math.ceil(e[e.length-2]/2),s=i,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)s*=e[e.length-u-1],o=`\n      int b${u} = index / ${s};\n      index -= b${u} * ${s};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,l,n.enableShapeUniforms),i=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(a=function(e,t,n){switch(e.length){case 0:return DP();case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return _a.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${kP(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=wP(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${kP(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=wP(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){let n=wP(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){let n=wP(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,n.enableShapeUniforms),i=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),n.packedInputs&&(c+=FP),[c,d,i,s,a,o,n.userCode].join("\n")}function CP(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,i]=e.shapeInfo.texShape;if(1===a&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let s=MP(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${OP(e)}\n      }\n    `;let a=e.shapeInfo.texShape,i=a[0],s=a[1];if(1===s&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=MP(n);return 1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${s}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape;if(null!=i&&_a.arraysEqual(n,i)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=i[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:s,keptDims:o}=_a.squeezeShape(n),l=s;if(l.length<n.length){let n=["row","col"];return`\n      ${CP(zP(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${BP(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${OP(e)}\n      }\n    `;let u=i[0],d=i[1],c=MP(r);return 1===d?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${c};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${u}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],s=n[2],{newShape:o,keptDims:l}=_a.squeezeShape(n),u=o;if(u.length<n.length){let n=["row","col","depth"];return`\n        ${CP(zP(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${BP(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${s}, 1)));\n        ${OP(e)}\n      }\n    `;let d=e.shapeInfo.texShape,c=d[0],p=d[1],h=e.shapeInfo.flatOffset;if(p===i&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${c}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(p===s&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=MP(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${s} + depth + ${f};\n        vec2 uv = uvFromFlat(${c}, ${p}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],s=n[2]*i,o=n[1]*s,{newShape:l,keptDims:u}=_a.squeezeShape(n);if(l.length<n.length){let n=["row","col","depth","depth2"];return`\n      ${CP(zP(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${BP(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${s}, ${i}, 1)));\n        ${OP(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,p=c[0],h=c[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(h===i&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=MP(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${s} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${h}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],i=t[3]*a,s=t[2]*i,o=t[1]*s,{newShape:l,keptDims:u}=_a.squeezeShape(t);if(l.length<t.length){let t=["row","col","depth","depth2","depth3"];return`\n      ${CP(zP(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${BP(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${s}, ${i}, ${a})) +\n          depth3;\n        ${OP(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,p=c[0],h=c[1];if(h===o&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===a&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=MP(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${s} + depth * ${i} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${p}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:i}=_a.squeezeShape(t);if(a.length<t.length){let t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${CP(zP(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${BP(t,i)});\n      }\n    `}let s=t[5],o=t[4]*s,l=t[3]*o,u=t[2]*l,d=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${OP(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===d&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===s&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=MP(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${s} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function EP(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=xP();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,i=xP();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `;let s=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,s=i[0],o=i[1],l=xP();if(null!=i&&_a.arraysEqual(n,i))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${s}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${d}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){let r=[1,2],i=["b","row","col"];return`\n        ${EP(zP(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${BP(i,r)});\n        }\n      `}let o=xP();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=s[0],u=s[1],d=Math.ceil(n[2]/2),c=d*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c}, ${d}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=xP();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let i=e.shapeInfo.logicalShape,s=i.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],d=l[1],c=Math.ceil(i[s-1]/2),p=c*Math.ceil(i[s-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${c} + (col / 2)`;for(let m=2;m<s-1;m++)h=`int b${m}, `+h,p*=i[s-m-1],f=`b${m} * ${p} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var AP="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$P="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",RP="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",FP="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function DP(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function MP(e){return`offset${e}`}function OP(e){let t=e.name,n=_a.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function PP(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function LP(e,t,n){let{newShape:r,keptDims:a}=_a.squeezeShape(t),i=t.length,s=e&&3===i&&1===t[0],o=s?t.slice(1):r,l=!e&&i>1&&!_a.arraysEqual(t,n)&&r.length<i||s;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function zP(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function BP(e,t){return t.map((t=>e[t])).join(", ")}function WP(e,t,n){let r,a,i,s=[],o=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===Ge().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let d=!1;for(let c of t.variableNames){let r={name:c,uniform:e.getUniformLocation(n,c,d),offset:e.getUniformLocation(n,`offset${c}`,d)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,`${c}Shape`,d),r.texShape=e.getUniformLocation(n,`${c}TexShape`,d)),s.push(r)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",d),i=e.getUniformLocation(n,"outShapeStrides",d),a=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms)for(let c of t.customUniforms)o.push(e.getUniformLocation(n,c.name,d));return{variablesLocations:s,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:i,outTexShapeLocation:a}}function UP(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],i=a.shape;if(!_a.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(e.isUniform&&a.isUniform)return;let s=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!_a.arraysEqual(s,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${s} and ${o} must match`)}))}function VP(e){return Ge().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var GP=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=dO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xP();this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?kP(["r","c","d"],e):wP(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},HP=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=dO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xP();this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?kP(["r","c","d"],e):wP(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},jP=class{constructor(e){this.variableNames=["A"],this.outTexUsage=cO.DOWNLOAD;let t=xP();this.outputShape=e,this.userCode=`\n      ${NP}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},qP=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=cO.DOWNLOAD;let t=xP();this.outputShape=e,this.userCode=`\n      ${NP}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},KP={R:0,G:1,B:2,A:3},XP=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=xP();this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let i="";for(let s=0;s<n.length;s++){let e=n[s];i+=`\n          if(offset == ${s}) {\n            result = values[${KP[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IP(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${i}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},YP=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=xP();this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let t=0;t<=1;t++){let a=2*i+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IP(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},QP={};function JP(e){let t=xP();return _O(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function ZP(e){return OO(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function eL(e){return PO(e,new Uint16Array([0,1,2,2,1,3]))}function tL(e,t,n,r,a,i){BO(t,n);let s=zO(e),o=e.TEXTURE_2D;return wO(e,(()=>e.bindTexture(o,s))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Ge().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texImage2D(o,0,r,t,n,0,a,i,null))):wO(e,(()=>e.texStorage2D(o,1,r,t,n))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:s,texShape:[n,t]}}function nL(e){return e.internalFormatFloat}function rL(e,t,n,r){let[a,i]=yO(t,n);return tL(e,a,i,nL(r),r.textureFormatFloat,e.FLOAT)}function aL(e){return e.internalFormatHalfFloat}function iL(e,t,n,r){let[a,i]=yO(t,n);return tL(e,a,i,aL(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function sL(e){return e.downloadTextureFormat}function oL(e,t,n,r){let[a,i]=yO(t,n);return tL(e,a,i,sL(r),e.RGBA,e.UNSIGNED_BYTE)}function lL(e){return e.internalFormatPackedFloat}function uL(e,t,n,r){let[a,i]=vO(t,n);return tL(e,a,i,lL(r),e.RGBA,e.FLOAT)}function dL(e){return e.internalFormatPackedHalfFloat}function cL(e,t,n,r){let[a,i]=vO(t,n);return tL(e,a,i,dL(r),e.RGBA,r.textureTypeHalfFloat)}function pL(e,t,n){return wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),UO(e,t,"clipSpacePos",n,3,20,0)&&UO(e,t,"uv",n,2,20,12)}function hL(e,t,n,r,a,i){let s,o,l;wO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(s=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(s=new Float32Array(n*r*4),o=e.FLOAT,l=i.internalFormatPackedFloat),s.set(a),2===Ge().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,s))):wO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,s))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function fL(e,t,n){wO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Ge().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):wO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Ge().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):wO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function mL(e,t,n,r){let a=e.createBuffer();wO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let i=16*t*n;return wO(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ))),wO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),wO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function gL(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function yL(e,t,n,r){let[a,i]=yO(t,n),s=new Uint8Array(function(e,t){return e*t}(t*n,4));return wO(e,(()=>e.readPixels(0,0,a,i,r.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}function bL(e,t,n,r,a,i,s,o){let l=e,u=new Float32Array(function(e,t){let[n,r]=vO(e,t);return n*r*4}(i,s));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function vL(e,t,n){let r=new Float32Array(t*n*4);return wO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}w(QP,{bindVertexProgramAttributeStreams:()=>pL,createBufferFromOutputTexture:()=>mL,createFloat16MatrixTexture:()=>iL,createFloat16PackedMatrixTexture:()=>cL,createFloat32MatrixTexture:()=>rL,createIndexBuffer:()=>eL,createPackedMatrixTexture:()=>uL,createUnsignedBytesMatrixTexture:()=>oL,createVertexBuffer:()=>ZP,createVertexShader:()=>JP,downloadByteEncodedFloatMatrixFromOutputTexture:()=>yL,downloadFloat32MatrixFromBuffer:()=>gL,downloadMatrixFromPackedOutputTexture:()=>vL,downloadPackedMatrixFromBuffer:()=>bL,getInternalFormatForFloat16MatrixTexture:()=>aL,getInternalFormatForFloat16PackedMatrixTexture:()=>dL,getInternalFormatForFloat32MatrixTexture:()=>nL,getInternalFormatForPackedMatrixTexture:()=>lL,getInternalFormatForUnsignedBytesMatrixTexture:()=>sL,uploadDenseMatrixToTexture:()=>hL,uploadPixelDataToTexture:()=>fL});var xL=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=Ge().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,mO(t,e)):this.gl=gO(t),e=this.gl,2===Ge().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>wO(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>wO(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>wO(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>wO(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>wO(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>wO(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>wO(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>wO(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Ge().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=TO(this.gl,e),pP(this.gl,t))this.textureHalfFloatExtension=TO(this.gl,t);else if(Ge().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),pP(this.gl,r))this.colorBufferHalfFloatExtension=TO(this.gl,r);else if(Ge().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",pP(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!pP(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=ZP(this.gl),this.indexBuffer=eL(this.gl),this.framebuffer=WO(this.gl),this.textureConfig=xO(this.gl,this.textureHalfFloatExtension)}get debug(){return Ge().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;wO(e,(()=>e.finish())),wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wO(e,(()=>e.deleteFramebuffer(this.framebuffer))),wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),wO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),wO(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),rL(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),iL(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),oL(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),fL(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),hL(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),cL(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),uL(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(YO(this.gl,this.framebuffer),this.outputTexture=null),wO(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>yL(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,i){return bL(this.gl,e,0,0,0,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return gL(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=mL(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Ge().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>vL(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=JP(t));let n=FO(t);wO(t,(()=>t.attachShader(n,this.vertexShader))),wO(t,(()=>t.attachShader(n,e))),DO(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&MO(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;wO(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),pL(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(wO(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&MO(this.gl,this.program),wO(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?HO(this.gl,e,t):jO(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),wO(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),qO(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=vO(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&MO(this.gl,this.program),QO(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}wO(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),wO(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=TO(this.gl,2===Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await _a.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ge().platform&&(n=Ge().platform.setTimeoutCustom.bind(Ge().platform)),_a.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),XO(this.gl,e,this.framebuffer),this.debug&&QO(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(XO(this.gl,this.outputTexture,this.framebuffer),this.debug&&QO(this.gl)):YO(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;XO(r,e,this.framebuffer),this.debug&&QO(r),this.outputTexture=e,wO(r,(()=>r.viewport(0,0,t,n))),wO(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),wO(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};var{addImpl:wL,bincountImpl:kL,bincountReduceImpl:SL,bitwiseAndImpl:IL,castImpl:NL,ceilImpl:TL,concatImpl:_L,equalImpl:CL,expImpl:EL,expm1Impl:AL,floorImpl:$L,gatherNdImpl:RL,gatherV2Impl:FL,greaterImpl:DL,greaterEqualImpl:ML,lessImpl:OL,lessEqualImpl:PL,linSpaceImpl:LL,logImpl:zL,maxImpl:BL,maximumImpl:WL,minimumImpl:UL,multiplyImpl:VL,negImpl:GL,notEqualImpl:HL,prodImpl:jL,raggedGatherImpl:qL,raggedRangeImpl:KL,raggedTensorToTensorImpl:XL,rangeImpl:YL,rsqrtImpl:QL,scatterImpl:JL,sigmoidImpl:ZL,simpleAbsImpl:ez,sliceImpl:tz,sparseFillEmptyRowsImpl:nz,sparseReshapeImpl:rz,sparseSegmentReductionImpl:az,sqrtImpl:iz,staticRegexReplaceImpl:sz,stridedSliceImpl:oz,stringNGramsImpl:lz,stringSplitImpl:uz,stringToHashBucketFastImpl:dz,subImpl:cz,tileImpl:pz,topKImpl:hz,transposeImpl:fz,uniqueImpl:mz}=EE;function gz(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function yz(e,t){return 1===t?[e]:gz(e,t)}var bz=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=VP(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=yz("rc",this.rank),t=PP(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},vz=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?SP(["r","c","d"],"inputShape"):wP(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IP(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};var xz=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=kz(t,n),a=Sz(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let i,s=wz(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}return r===pO.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===pO.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===pO.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===pO.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===pO.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=kz(n,r),i=Sz(t,a,r);i in this.freeTextures||(this.freeTextures[i]=[]);let s=wz(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Ge().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;let l=this.usedTextures[i],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function wz(e,t,n,r,a){let i,s=function(e,t){switch(e){case pO.PACKED_2X2_FLOAT32:return lL(t);case pO.PACKED_2X2_FLOAT16:return dL(t);case pO.UNPACKED_FLOAT32:return nL(t);case pO.UNPACKED_FLOAT16:return aL(t);case pO.PACKED_4X1_UNSIGNED_BYTE:return sL(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[t,n]=vO(e[0],e[1]);i=t*n}else{let[t,n]=yO(e[0],e[1]);i=t*n}let o=function(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return i*o}function kz(e,t){if(e===cO.UPLOAD)return pO.PACKED_2X2_FLOAT32;if(e===cO.RENDER||null==e)return function(e){return Ge().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?pO.PACKED_2X2_FLOAT32:pO.UNPACKED_FLOAT32:e?pO.PACKED_2X2_FLOAT16:pO.UNPACKED_FLOAT16}(t);if(e===cO.DOWNLOAD||e===cO.PIXELS)return pO.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Sz(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Iz=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Nz="if (isnan(x)) return x;",Tz="return abs(x);",_z=Nz+"\n  return (x < 0.0) ? 0.0 : x;\n",Cz=Nz+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Ez="return x;",Az=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},$z=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length);let t=e.length,n=yz("rc",t),r=PP(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),i=n.slice(-2),s=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${s}));\n      }\n    `}},Rz=sg.whereImpl,Fz={};var Dz=Ge().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");var Mz=class e extends H{nextDataId(){return e.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ge().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof xL)t=e;else{let n=gO(Ge().getNumber("WEBGL_VERSION"),e);t=new xL(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=gO(Ge().getNumber("WEBGL_VERSION"));t=new xL(e),this.binaryCache=function(e){return e in Fz||(Fz[e]={}),Fz[e]}(Ge().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new xz(this.gpgpu),this.numMBBeforeWarning=null==Ge().global.screen?1024:Ge().global.screen.height*Ge().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new G(this,rs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,i){let s=this.makeTensorInfo(t,n),o=this.texData.get(s.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=rP(t),u=new XP(l,!1,i),d=this.runWebGLProgram(u,[s],n,[[r,a]]);return d.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(s),d.dataId}write(e,t,n){if((Ge().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ge().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:cO.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(Ge().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:cO.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:i,shape:s,isPacked:o}=t;if(null!=i){let t;t=o?new Az(s,Ez):new Iz(s,Ez);let n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,d=null!=this.activeTimers;if(d&&(l=_a.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=em.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=_a.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:i,complexTensorInfos:s,isPacked:o}=t;if(null!=a){let t;t=o?new Az(r,Ez):new Iz(r,Ez);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:i}],i),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(Ge().getBool("DEBUG")&&!Ge().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ge().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,d=null;if("complex64"!==i&&Ge().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(t.texture.texture,...bO(r))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){let e=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]),t=e[0],n=e[1];u=em.mergeRealAndImagArrays(t,n)}else if(null==d)u=this.getValuesFromTexture(e);else{let e=_a.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=d){let e=this.gpgpu.gl;wO(e,(()=>e.deleteBuffer(d)))}let c=this.convertAndCacheOnCPU(e,u),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(c))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&rs().removeDataId(e,this),this.pendingDeletes--),c}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.texData.get(e),{values:r,shape:a,slice:i,dtype:s,isPacked:o,texture:l}=n;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=o?new Az(a,Ez):new Iz(a,Ez);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:s}],s),i=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),i}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),d=rs().makeTensorFromTensorInfo(u),c=this.texData.get(u.dataId);return Object.assign({tensorRef:d},c.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>_a.decodeString(e)));return yo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return yo(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!IO(n))throw Ge().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=_a.sizeFromShape(t);if(Ge().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...bO(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),i}let i=Ge().getBool("WEBGL_PACK")&&!0===r,s=i?rP(t):t,o=i?new qP(s):new jP(s),l=this.runWebGLProgram(o,[{shape:s,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=_a.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=_a.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);s.kernelMs=_a.sum(e),s.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:_a.now(),endMs:null}}endTimer(e){return Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=_a.now(),e)}async getQueryTime(e){if(Ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:i,slice:s}=this.texData.get(e),o=s&&s.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,i)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Dz;return Ge().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&_a.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){em.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return Rz(e.shape,t)}packedUnaryOp(e,t,n){let r=new Az(e.shape,t),a=this.compileAndRun(r,[e],n);return rs().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=ez(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Ge().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Tz,e.dtype);let t=new Iz(e.shape,Tz),n=this.compileAndRun(t,[e]);return rs().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&_a.isString(n[0])){let a=n.map((e=>_a.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return rs().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new $z(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new bz(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[tP(e.shape),...nP(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[tP(t),...nP(t)],i=new vz(a,n),s=[n],o=this.runWebGLProgram(i,[r],e.dtype,s,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:i}=n;if(null!=t){let e=_a.sizeFromShape(a),n=t[0]*t[1]*4;_a.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let s,o=rP(a);s=r?new HP(o):new GP(o);let l=[null!=t?t:bO(o)];return{dtype:i,shape:a,dataId:this.runWebGLProgram(s,[{shape:o,dtype:i,dataId:e}],i,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5?arguments[5]:void 0,s=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(s.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===dO.DENSE){let t=null!=i?i:bO(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===_a.sizeFromShape(s.shape))return o.values=_a.getTypedArrayFromDType(s.dtype,0),s;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&_a.sizeFromShape(t.shape)<=Ge().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!sP(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);let d,c={shape:s.shape,texData:o,isUniform:!1},p=function(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let i=t.texData.texShape,{useSqueezeShape:s,uniformShape:o,keptDims:l}=LP(e.packedInputs,t.shape,i),u="",d="",c="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=_a.computeStrides(o);c=`${e[0]===i[1]}_${e[e.length-1]===i[1]}`}}else d=`${o[0]>1}_${o[1]>1}`;let p=t.shape.length,h=2===o.length&&_a.arraysEqual(t.shape,i),f=1===_a.sizeFromShape(t.shape),m=em.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&p===n.shape.length&&_a.arraysEqual(i,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${i[0]>1}_${i[1]>1}`;r+=`${p}_${g}_${s?l:""}_${o.length}_${f}_${m}_${h}_${u}_${d}_${c}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,i=e.constructor.name;return i+="_"+r+"_"+a+`${Ge().getNumber("WEBGL_VERSION")}`,i}(e,u,c),h=this.getAndSaveBinary(p,(()=>function(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),i=a.map((e=>e.shapeInfo)),s={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=_P(a,s,t),l=CO(e.gl,o),u=e.createProgram(l);return Ge().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:s},WP(e,t,u)))}(this.gpgpu,e,u,c))),f=null!=this.activeTimers;f&&(d=this.startTimer()),Ge().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(UP(t.inShapeInfos,n),UP([t.outShapeInfo],[r]));let i=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,s[0],s[1]):e.setOutputMatrixTexture(i.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Ge().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let r=n[l],{uniform:a,offset:i,shape:s,texShape:o}=t.variablesLocations[l];if(s){let{uniformShape:n}=LP(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a){if(r.isUniform){if(_a.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}continue}null!=r.texData.slice&&null!=i&&e.gl.uniform1i(i,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let n=_a.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let n=t.program.customUniforms[l],r=t.customUniformLocations[l],i=a[l];if("float"===n.type)e.gl.uniform1fv(r,i);else if("vec2"===n.type)e.gl.uniform2fv(r,i);else if("vec3"===n.type)e.gl.uniform3fv(r,i);else if("vec4"===n.type)e.gl.uniform4fv(r,i);else if("int"===n.type)e.gl.uniform1iv(r,i);else if("ivec2"===n.type)e.gl.uniform2iv(r,i);else if("ivec3"===n.type)e.gl.uniform3iv(r,i);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,i)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(d=this.endTimer(d),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(d)}));let m=Ge().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=_a.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Ge().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ge().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=ss((()=>{if(!Ge().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=Ge().getBool("DEBUG");Ge().set("DEBUG",!1);let t=this.abs(cu(1e-8)).dataSync()[0];if(Ge().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:i,usage:s,isPacked:o}=t;if(null!=i)return;let l,u=null!=this.activeTimers;u&&(l=_a.now());let d=t.texShape;if(null==d&&(d=aP(n,o),t.texShape=d),null!=a){let e,i=rP(n),s=d[1],c=d[0],p=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!p)&&([s,c]=vO(d[0],d[1])),e=o?new YP(i,p):new XP(i,p);let h=p?[c,s]:d,f=this.makeTensorInfo(h,r),m=this.texData.get(f.dataId);m.usage=p?cO.PIXELS:cO.UPLOAD,m.texShape=h,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),s,c,a);let g=[[c,s]],y=this.runWebGLProgram(e,[f],r,g,!0),b=this.texData.get(y.dataId);t.texShape=b.texShape,t.isPacked=b.isPacked,t.usage=b.usage,Ge().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=b.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=_a.now()-l)}else{let e=this.acquireTexture(d,s,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*_a.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Jf(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(RO(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:s,outTexShapeLocation:o}=WP(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=i,e.outShapeStridesLocation=s,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:i,channels:s}=e,o=rs().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,i,s);return rs().makeTensorFromDataId(l,t,n,o)}};Mz.nextDataId=0;var Oz="4.21.0";function Pz(){Ge().set("WEBGL_FORCE_F16_TEXTURES",!0)}Mi.isBrowser()&&gs("webgl",(()=>new Mz),2);var Lz={forceHalfFloat:Pz},zz="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",Bz=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=em.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=VP(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},Wz="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",Uz=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=em.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=VP(a);let i="";if(r)if(0===a||1===_a.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${PP(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=yz("coords",a);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}};function Vz(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Gz={kernelName:pn,backendName:"webgl",kernelFunc:Vz};function Hz(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,i=n.makeTensorInfo(r.shape,"complex64"),s=n.texData.get(i.dataId),o=Vz({inputs:{x:r},backend:n}),l=Vz({inputs:{x:a},backend:n});return s.complexTensorInfos={real:o,imag:l},i}var jz={kernelName:kt,backendName:"webgl",kernelFunc:Hz},qz="return (a < 0.) ? b * a : a;",Kz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var Xz={kernelName:bn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:i}=r,s=n.makeTensorInfo([],"float32",_a.createScalarValue(i,"float32")),o=Ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Uz(Kz,a.shape,s.shape):new Bz(qz,a.shape,s.shape),l=n.runWebGLProgram(o,[a,s],"float32");return n.disposeIntermediateTensorInfo(s),l}},Yz="return (a < 0.) ? b * a : a;",Qz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var Jz={kernelName:ar,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,i=Ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Uz(Qz,r.shape,a.shape):new Bz(Yz,r.shape,a.shape);return n.runWebGLProgram(i,[r,a],"float32")}},Zz="if (isnan(x)) return x;";function eB(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let i,{inputs:s,backend:o}=e,{x:l}=s,u=o,d=a||l.dtype;if(u.shouldExecuteOnCPU([l])&&null!=r){let e=u.texData.get(l.dataId),t=r(e.values,d);return u.makeTensorInfo(l.shape,d,t)}return i=Ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Az(l.shape,n):new Iz(l.shape,t),u.runWebGLProgram(i,[l],d)}}function tB(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:i,dtype:s}=e;return e=>{let{inputs:o,backend:l}=e,{a:u,b:d}=o,c=l;if(a&&"complex64"===u.dtype){let e=c.texData.get(u.dataId),n=c.texData.get(d.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{let[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},i={dataId:r.dataId,dtype:r.dtype,shape:d.shape},s=new Bz(t,u.shape,d.shape);return c.runWebGLProgram(s,[a,i],vi(n.dtype,r.dtype))})),i=Hz({inputs:{real:r,imag:a},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(a),i}let p,h=s||vi(u.dtype,d.dtype);if(("string"===u.dtype||"string"===d.dtype||c.shouldExecuteOnCPU([u,d]))&&null!=i){let e=c.texData.get(u.dataId).values,t=c.texData.get(d.dataId).values,n="string"===u.dtype?em.fromUint8ToStringArray(e):e,r="string"===u.dtype?em.fromUint8ToStringArray(t):t,[a,s]=i(u.shape,d.shape,n,r,h),o=c.makeTensorInfo(s,h);return c.texData.get(o.dataId).values=a,o}return p=Ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Uz(n,u.shape,d.shape,r):new Bz(t,u.shape,d.shape),c.runWebGLProgram(p,[u,d],h)}}function nB(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":_z;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":Cz;if("prelu"===e)return t?Qz:Yz;if("leakyrelu"===e)return t?Kz:qz;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var rB=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=VP(this.outputShape.length);let u=r?e[1]:e[2],d=Math.ceil(u/2),c=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";s&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,g="result = activation(result);");let y=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},aB="return areal * breal - aimag * bimag;",iB="return areal * bimag + aimag * breal;",sB=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=em.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},oB="return a * b;";function lB(e){let t,{inputs:n,backend:r}=e,{a:a,b:i}=n,s=em.upcastType(a.dtype,i.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(i.dataId),n=new sB(aB,a.shape,i.shape),s=new sB(iB,a.shape,i.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(s,o,"float32"),d=Hz({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),d}if(r.shouldExecuteOnCPU([a,i])){let e=r.texData.get(a.dataId),t=r.texData.get(i.dataId),[n,o]=VL(a.shape,i.shape,e.values,t.values,s),l=r.makeTensorInfo(o,s);return r.texData.get(l.dataId).values=n,l}return t=Ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Uz(oB,a.shape,i.shape):new Bz(oB,a.shape,i.shape),r.runWebGLProgram(t,[a,i],s)}var uB={kernelName:jn,backendName:"webgl",kernelFunc:lB};function dB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:i}=r,s=n,o=_a.sizeFromShape(a.shape),l=_a.inferFromImplicitShape(i,o),u=_a.sizeFromShape(l);_a.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let d=s.texData.get(a.dataId);return!d.isPacked||sP(a.shape,l)||null!==d.texture&&sP(d.shape,l)?(s.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){let r=[tP(e.shape),...nP(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},i=[tP(t),...nP(t)],s=new vz(i,r),o=[r],l=n.runWebGLProgram(s,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,s)}var cB={kernelName:hr,backendName:"webgl",kernelFunc:dB},pB=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let s=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${_a.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},hB=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let s="0.0",o="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",o="min"):"max"===t&&(s="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),d=n%4,c=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===t?(s="1.0",c="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(s="0.0",c="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${s});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${2===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${3===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${c}\n        }\n        setOutput(${l});\n      }\n    `}};function fB(e,t,n,r){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=em.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),i=e;for(let s=0;s<a.length;s++){let o,l,{inSize:u,windowSize:d,outSize:c}=a[s];o="mean"===n?0===s?new pB({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c},u):new pB({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c}):new hB({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c},n),l=i,i=r.runWebGLProgram(o,[i],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return i}var mB=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;let r=PP(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};var gB=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=PP(this.rank),a=gz("rc",this.rank),i=new Array(this.rank);for(let u=0;u<t.length;u++)i[t[u]]=a[u];let s=`vec2(${i.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function yB(e,t,n){let r=Ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gB(e.shape,t):new mB(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function bB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;return function(e,t,n,r){let a=t,i=e.shape.length,s=_a.parseAxisParam(a,e.shape),o=s,l=em.getAxesPermutation(o,i),u=null!=l,d=e;u&&(d=yB(e,l,r),o=em.getInnerMostAxes(o.length,i)),em.assertAxesAreInnerMostDims("sum",o,i);let[c,p]=em.computeOutAndReduceShapes(d.shape,o),h=c;n&&(h=em.expandShapeToKeepDim(c,s));let f=_a.sizeFromShape(p),m=dB({inputs:{x:d},attrs:{shape:[_a.sizeFromShape(e.shape)/f,f]},backend:r}),g=fB(m,xi(e.dtype),"sum",r),y=dB({inputs:{x:g},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(d),y}(a,i,s,n)}var vB={kernelName:Dr,backendName:"webgl",kernelFunc:bB};function xB(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{perm:s}=a,o=r,l=i.shape.length,u=new Array(l);for(let d=0;d<u.length;d++)u[d]=i.shape[s[d]];if(o.shouldExecuteOnCPU([i])){let e=o.texData.get(i.dataId).values,n=fz(e,i.shape,i.dtype,s,u);t=o.makeTensorInfo(u,i.dtype),o.texData.get(t.dataId).values=n}else t=yB(i,s,o);return t}var wB={kernelName:na,backendName:"webgl",kernelFunc:xB};function kB(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,d=t.shape.length,c=n.shape.length,p=r?t.shape[d-2]:t.shape[d-1],h=a?n.shape[c-1]:n.shape[c-2],f=r?t.shape[d-1]:t.shape[d-2],m=a?n.shape[c-2]:n.shape[c-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=_a.sizeFromShape(g),v=_a.sizeFromShape(y),x=Wl.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);_a.assert(p===h,(()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));let w,k=r?[b,p,f]:[b,f,p],S=a?[v,m,h]:[v,h,m],I=dB({inputs:{x:t},backend:i,attrs:{shape:k}}),N=dB({inputs:{x:n},backend:i,attrs:{shape:S}}),T=[I,N],_=Math.max(b,v),C=r?I.shape[1]:I.shape[2],E=null!=s,A=null!=o,$="leakyrelu"===u,R=null!=u?nB(u,!0):null;if((1===f||1===m)&&C>1e3&&!1===(E||A||$||null!=R)){let e=I,t=N;r&&(e=xB({inputs:{x:I},backend:i,attrs:{perm:[0,2,1]}}),T.push(e)),a&&(t=xB({inputs:{x:N},backend:i,attrs:{perm:[0,2,1]}}),T.push(t));let n=1===m,s=e;1!==m&&(s=dB({inputs:{x:e},backend:i,attrs:{shape:[_,C,1]}}),T.push(s));let o=1===m?2:1,l=t;n&&(l=dB({inputs:{x:t},backend:i,attrs:{shape:[_,1,C]}}),T.push(l));let u=lB({inputs:{a:s,b:l},backend:i});w=bB({inputs:{x:u},backend:i,attrs:{axis:o,keepDims:!0}}),T.push(u)}else{let e=vi(t.dtype,n.dtype),u=new rB(k,S,[_,f,m],r,a,E,R,A,$),d=[I,N];if(null!=s&&d.push(s),A&&d.push(o),$){let e=i.makeTensorInfo([],"float32",_a.createScalarValue(l,"float32"));d.push(e),T.push(e)}w=i.runWebGLProgram(u,d,e)}let F=dB({inputs:{x:w},backend:i,attrs:{shape:x}});T.push(w);for(let D of T)i.disposeIntermediateTensorInfo(D);return F}var SB={kernelName:ca,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i,bias:s,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:d,leakyreluAlpha:c}=r;return kB({a:a,b:i,transposeA:l,transposeB:u,backend:n,bias:s,preluActivationWeights:o,leakyreluAlpha:c,activation:d})}},IB="return abs(x);";var NB={kernelName:Xe,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=ez(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=Ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Az(a.shape,IB):new Iz(a.shape,IB),r.runWebGLProgram(t,[a],a.dtype)}},TB=eB({opSnippet:Nz+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),_B={kernelName:Ye,backendName:"webgl",kernelFunc:TB},CB=eB({opSnippet:Nz+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),EB={kernelName:Qe,backendName:"webgl",kernelFunc:CB},AB="return a + b;",$B=tB({opSnippet:AB,packedOpSnippet:AB,supportsComplex:!0,cpuKernelImpl:wL}),RB={kernelName:Je,backendName:"webgl",kernelFunc:$B},FB=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},DB=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};var MB={kernelName:Ze,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,a=n;if(1===a.length)return Vz({inputs:{x:a[0]},backend:r});if(a.length>Ge().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),i=e({inputs:a.slice(t),backend:r});return e({inputs:[n,i],backend:r})}let i=a.map((e=>e.dtype)).reduce(((e,t)=>vi(e,t))),s=a.map((e=>e.shape)),o=Ge().getBool("WEBGL_PACK")?new DB(a[0].shape,s):new FB(a[0].shape,s);return r.runWebGLProgram(o,a,i)}};var OB={kernelName:et,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=a.shape.length,l=_a.parseAxisParam(i,a.shape),u=l,d=em.getAxesPermutation(u,o),c=a;null!=d&&(c=xB({inputs:{x:a},backend:n,attrs:{perm:d}}),u=em.getInnerMostAxes(u.length,o)),em.assertAxesAreInnerMostDims("all",u,o);let p,[h,f]=em.computeOutAndReduceShapes(c.shape,u),m=dB({inputs:{x:c},backend:n,attrs:{shape:[-1,_a.sizeFromShape(f)]}}),g=fB(m,m.dtype,"all",n);if(s){p=dB({inputs:{x:g},backend:n,attrs:{shape:em.expandShapeToKeepDim(h,l)}})}else p=dB({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(c),p}};var PB={kernelName:tt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=a.shape.length,l=_a.parseAxisParam(i,a.shape),u=l,d=em.getAxesPermutation(u,o),c=a;null!=d&&(c=xB({inputs:{x:a},backend:n,attrs:{perm:d}}),u=em.getInnerMostAxes(u.length,o)),em.assertAxesAreInnerMostDims("any",u,o);let p,[h,f]=em.computeOutAndReduceShapes(c.shape,u),m=dB({inputs:{x:c},backend:n,attrs:{shape:[-1,_a.sizeFromShape(f)]}}),g=fB(m,m.dtype,"any",n);if(s){p=dB({inputs:{x:g},backend:n,attrs:{shape:em.expandShapeToKeepDim(h,l)}})}else p=dB({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(c),p}},LB=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];let s="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${s} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},zB=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,_a.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],i=Math.ceil(a/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");let s,o,l=this.outputShape,u=l.length,d=PP(u),c=yz("coords",u);if(1===i){o=u+1;let e=PP(o);s=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else o=u,s=`\n        ${d} sourceLocR = coords;\n        ++${c[u-1]};\n        ${d} sourceLocG = coords;\n        ++${c[u-2]};\n        ${d} sourceLocA = coords;\n        --${c[u-1]};\n        ${d} sourceLocB = coords;\n        --${c[u-2]};`;let p=["x","y","z","w","u","v"].slice(0,o),h="."+p[o-1],f=p.map((e=>"int "+e)),m=yz("sourceLocR",o-1).concat("inIdx.r"),g=yz("sourceLocG",o-1).concat("inIdx.g"),y=yz("sourceLocB",o-1).concat("inIdx.b"),b=yz("sourceLocA",o-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${d} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${l[u-2]-1};\n        ${s}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function BB(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],i=t.shape[1];null!=r&&(a=r.shape[0],i=r.shape[1]);let s=em.computeOptimalWindowSize(i),o={windowSize:s,inSize:i,batchSize:a,outSize:Math.ceil(i/s)},l=new LB(o,n,null==r),u=[t];null!=r&&u.push(r);let d=e.runWebGLProgram(l,u,"int32");if(1===d.shape[1])return d;let c=BB(e,t,n,d);return e.disposeIntermediateTensorInfo(d),c}function WB(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=null!=r?r.shape:t.shape,i=a[a.length-1],s=em.computeOptimalWindowSize(i),o=new zB(a,s,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=WB(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function UB(e,t,n,r){let a=[n];if(em.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!Ge().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],i=e.texData.get(t.dataId),s=t;null!==i&&i.isPacked&&(s=e.unpackTensor(t),n.push(s));let[o,l]=em.computeOutAndReduceShapes(s.shape,a),u=_a.sizeFromShape(l),d=dB({inputs:{x:s},backend:e,attrs:{shape:[-1,u]}});n.push(d);let c=BB(e,d,r);n.push(c);let p=dB({inputs:{x:c},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),p}return WB(e,t,r)}var VB={kernelName:nt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r,s=_a.parseAxisParam(i,a.shape),o=em.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=xB({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=em.getInnerMostAxes(s.length,l.shape.length)),em.assertAxesAreInnerMostDims("argMax",[s[0]],l.shape.length);let d=UB(n,l,s[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};var GB={kernelName:rt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r,s=_a.parseAxisParam(i,a.shape),o=em.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=xB({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=em.getInnerMostAxes(s.length,l.shape.length)),em.assertAxesAreInnerMostDims("argMin",[s[0]],l.shape.length);let d=UB(n,l,s[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},HB=eB({opSnippet:Nz+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),jB={kernelName:at,backendName:"webgl",kernelFunc:HB},qB=eB({opSnippet:Nz+"return log(x + sqrt(x * x + 1.0));"}),KB={kernelName:it,backendName:"webgl",kernelFunc:qB},XB=eB({opSnippet:Nz+"\n  return atan(x);\n"}),YB={kernelName:st,backendName:"webgl",kernelFunc:XB},QB=tB({opSnippet:zz+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Wz+"\n  return result;\n"}),JB={kernelName:lt,backendName:"webgl",kernelFunc:QB},ZB=eB({opSnippet:Nz+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),eW={kernelName:ot,backendName:"webgl",kernelFunc:ZB},tW=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,s=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${s}, ${o});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${c} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");let v=4*Math.floor(i/4),x=i%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}},nW=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,s=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,v="0.0";if(b||(v="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${s}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${c}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let w=4*Math.floor(i/4),k=i%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${s}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${c};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${c}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}};var rW={kernelName:ut,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;bP(a,"avgPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;_a.assert(em.eitherStridesOrDilationsAreOne(s,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`));let u=em.computePool2DInfo(a.shape,i,s,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&_a.arraysEqual(u.inShape,u.outShape))return Vz({inputs:{x:a},backend:n});let d=new tW(u,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};var aW={kernelName:ct,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r,d=em.computePool3DInfo(a.shape,i,s,[1,1,1],o,l,u),c=new nW(d,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}},iW=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,s=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,d=l-1-e.padInfo.left,c=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${d});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${s}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},sW=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=d-1-e.padInfo.front,f=c-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var oW={kernelName:pt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=r,c=em.computePool3DInfo(s.shape,o,l,[1,1,1],u,d),p=new sW(c);return n.runWebGLProgram(p,[a],s.dtype)}};var lW={kernelName:dt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i;bP([a,i],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,d=em.computePool2DInfo(s.shape,o,l,1,u),c=new iW(d);return n.runWebGLProgram(c,[a],s.dtype)}};var uW={kernelName:ht,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i}=t,{transposeA:s,transposeB:o}=r;return kB({a:a,b:i,transposeA:s,transposeB:o,backend:n})}},dW=class{constructor(e,t,n,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],em.assertAndGetBroadcastShape(e,t),em.assertAndGetBroadcastShape(e,n);let s="0.0";null!=r&&(em.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let o="1.0";null!=a&&(em.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${s};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},cW=class{constructor(e,t,n,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],em.assertAndGetBroadcastShape(e,t),em.assertAndGetBroadcastShape(e,n);let s="vec4(0.0)";null!=r&&(em.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(em.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${s};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},pW={kernelName:on,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,mean:i,variance:s,offset:o,scale:l}=t;_a.assert(i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),_a.assert(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),_a.assert(null==l||i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);let d=[a,i,s],c=null;null!=o&&(c=o.shape,d.push(o));let p=null;null!=l&&(p=l.shape,d.push(l));let h=Ge().getBool("WEBGL_PACK_NORMALIZATION")?new cW(a.shape,i.shape,s.shape,c,p,u):new dW(a.shape,i.shape,s.shape,c,p,u);return n.runWebGLProgram(h,d,d[0].dtype)}},hW=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=PP(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return fW.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${fW[t]} = start[${t}] + coords.${fW[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},fW=["x","y","z","w","u","v"];var mW=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=PP(this.rank),n=yz("coords",this.rank),r=yz("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${a})`,s=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${s}\n        ${o}\n        setOutput(result);\n      }\n    `}};function gW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,size:s}=r,[o,l]=Cf.parseSliceParams(a,i,s);if(Cf.assertParamsValid(a,o,l),0===_a.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=tz(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),d=Cf.isSliceContinous(a.shape,o,l);if(u||!d){let e=Ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mW(l):new hW(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){let a=r.texData.get(e.dataId),i=r.makeTensorInfo(n,e.dtype),s=r.texData.get(i.dataId);Object.assign(s,a),s.refCount=1,s.shape=n,s.dtype=e.dtype;let o=Cf.computeFlatOffset(t,_a.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),s.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(s.slice.origDataId)||1;return r.dataRefCount.set(s.slice.origDataId,l+1),i}(a,o,l,n)}var yW={kernelName:_r,backendName:"webgl",kernelFunc:gW},bW={kernelName:ft,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:s}=r;_a.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=i.reduce(((e,t)=>e*t)),l=em.getReshaped(a.shape,i,o),u=em.getPermuted(l.length,i.length),d=em.getReshapedPermuted(a.shape,i,o),c=em.getSliceBeginCoords(s,i.length),p=em.getSliceSize(d,s,i.length),h=[],f=dB({inputs:{x:a},backend:n,attrs:{shape:l}}),m=xB({inputs:{x:f},backend:n,attrs:{perm:u}}),g=dB({inputs:{x:m},backend:n,attrs:{shape:d}}),y=gW({inputs:{x:g},backend:n,attrs:{begin:c,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};var vW={kernelName:mt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s}=r,o=n.readSync(a.dataId),l=n.readSync(i.dataId),u=kL(o,l,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,u)}};var xW={kernelName:gt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{a:a,b:i}=n,s=Ge().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ge().getNumber("WEBGL_VERSION");if(r.shouldExecuteOnCPU([a,i])||1===o){let e=r.texData.get(a.dataId).values,t=r.texData.get(i.dataId).values,[n,s]=IL(a.shape,i.shape,e,t,a.dtype),o=r.makeTensorInfo(s,a.dtype);return r.texData.get(o.dataId).values=n,o}return t=s?new Uz("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,i.shape,!1):new Bz("\n  return float(int(a.r) & int(b.r));\n",a.shape,i.shape),r.runWebGLProgram(t,[a,i],a.dtype)}};var wW={kernelName:bt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.readSync(r.dataId),s=n.readSync(a.dataId),o=em.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},kW=tB({opSnippet:"return float(a != b);",cpuKernelImpl:HL,dtype:"bool"}),SW={kernelName:Kn,backendName:"webgl",kernelFunc:kW};function IW(e){let{inputs:t,backend:n}=e,{input:r}=t;return Vz({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var NW={kernelName:dr,backendName:"webgl",kernelFunc:IW};var TW={kernelName:vt,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r,attrs:a}=t,{x:i}=n,{dtype:s}=a;if("complex64"===s){if("complex64"===i.dtype)return Vz({inputs:{x:i},backend:r});let t=ud(i.shape),n=e({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),a=Hz({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===i.dtype){let t=IW({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:s}});return r.disposeIntermediateTensorInfo(t),n}if(!_a.hasEncodingLoss(i.dtype,s)){let e=Vz({inputs:{x:i},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(r.shouldExecuteOnCPU([i])){let e=r.texData.get(i.dataId).values,[t,n,a]=NL(e,i.shape,i.dtype,s);return r.makeTensorInfo(t,n,a)}if("int32"===s)return function(e,t){let n=new Iz(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,r);if("bool"===s){let e=r.makeTensorInfo([],"bool",_a.getTypedArrayFromDType("bool",1)),t=kW({inputs:{a:i,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}},_W="return ceil(x);",CW=eB({opSnippet:_W,packedOpSnippet:_W,cpuKernelImpl:TL}),EW={kernelName:xt,backendName:"webgl",kernelFunc:CW},AW=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},$W=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};var RW={kernelName:wt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{clipValueMin:s,clipValueMax:o}=a;t=Ge().getBool("WEBGL_PACK_CLIP")?new $W(i.shape):new AW(i.shape);let l=[[s],[o]];return r.runWebGLProgram(t,[i],i.dtype,l)}},FW=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function DW(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var MW={kernelName:St,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),i=new FW(r.shape),s=[DW(r,a.complexTensorInfos.real),DW(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(i,s,s[0].dtype)}},OW=class{constructor(e){this.outputShape=[],this.outputShape=em.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let e=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},PW=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=em.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=PP(r),i=yz("coords",r),s=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=s[t],u=s.slice(-2),d=s.join(),c=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let e=o[f-1];c+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${LW(s,l,e)}),\n            vec2(${LW(u,l,e)}));\n        }`}let p=o.length,h=o[o.length-1];c+=`\n        return getChannel(\n          getT${p}(${LW(s,l,h)}),\n          vec2(${LW(u,l,h)}));`,this.userCode=`\n      float getValue(${s.map((e=>"int "+e))}) {\n        ${c}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}};function LW(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function zW(e){let{inputs:t,backend:n}=e,{input:r}=t;return Vz({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var BW={kernelName:fn,backendName:"webgl",kernelFunc:zW};function WW(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>IW({inputs:{input:e},backend:n}))),a=e.map((e=>zW({inputs:{input:e},backend:n}))),i=WW(r,t,n),s=WW(a,t,n),o=Hz({inputs:{real:i,imag:s},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=[-1,_a.sizeFromShape(e.shape.slice(t))];return dB({inputs:{x:e},backend:n,attrs:{shape:r}})})),i=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),s=em.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=_L(i,s,r,o),u=em.computeOutShape(e.map((e=>e.shape)),t),d=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}let i=e.filter((e=>_a.sizeFromShape(e.shape)>0)),s=Ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){let t=s?new Iz(e[0].shape,Ez):new Az(e[0].shape,Ez);return n.runWebGLProgram(t,e,r)}let o=Ge().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){let e=[];for(let a=0;a<i.length;a+=o){let r=i.slice(a,a+o);e.push(WW(r,t,n))}let r=WW(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(s){let e=new PW(i.map((e=>e.shape)),t);return n.runWebGLProgram(e,i,r)}let{tensors2D:l,outShape:u}=function(e,t,n){let r=em.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>dB({inputs:{x:e},attrs:{shape:[-1,_a.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(i,t,n),d=new OW(l.map((e=>e.shape))),c=n.runWebGLProgram(d,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));let p=dB({inputs:{x:c},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(c),p}function UW(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,i=_a.parseAxisParam(a,t[0].shape)[0],s=t.map((e=>e.shape));em.assertParamsConsistent(s,i);let o=em.computeOutShape(t.map((e=>e.shape)),i);if(0===_a.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>_a.sizeFromShape(e.shape)>0));return 1===l.length?Vz({inputs:{x:l[0]},backend:n}):WW(l,i,n)}var VW={kernelName:It,backendName:"webgl",kernelFunc:UW},GW=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,s=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,c=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${i}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}},HW=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterDepth,c=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${i}, ${s});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${c}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},jW=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VP(this.outputShape.length);let i=e.padInfo.left,s=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u,c="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)c+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;c+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)c+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;c+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(d+1)/2;m++){let t=2*m;if(c+=`\n           xC = xCCorner + ${t*o};\n           `,1===s){if(t<u&&(i%2===1?(c+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,c+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):c+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){let e=i%2===0?_a.nearestLargerEven(o):o;o%2===0&&i%2===1||o%2!==0&&i%2!==1?(c+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,c+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):c+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(i%2===1?(c+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(c+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(c+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(c+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(c+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(c+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}c+="\n     }\n   ",c+="\n     }\n   ",c+="\n     }\n   ";let p="",h="";n&&(p=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,h="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${c}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${h}\n         setOutput(result);\n       }\n     `}},qW=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=VP(this.outputShape.length);let{dataFormat:n}=t,r=xP(),a="channelsLast"===n,i=a?1:2,s=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${s}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function KW(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function XW(e){let t,{x:n,filter:r,convInfo:a,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,d=n.shape,c=i.texData.get(n.dataId),p=a.inChannels,h=d[0]*d[1]*d[2],f=a.outChannels,m="channelsLast"===a.dataFormat,g=!1,y=[];if(null!=o){let e=KW(o.shape,m);null!=e&&(o=dB({inputs:{x:o},backend:i,attrs:{shape:e}}),y.push(o))}if(null!=s){let e=KW(s.shape,m);null!=e&&(s=dB({inputs:{x:s},backend:i,attrs:{shape:e}}),y.push(s))}if((1!==h&&1!==f||!(p>1e3))&&c.isPacked&&m&&null!=c.texture&&d[2]%2!==0&&_a.arraysEqual(c.shape.slice(-3),d.slice(-3))){let e=d[0]*d[1]*(d[2]+1),p={dataId:n.dataId,shape:[1,e,a.inChannels],dtype:n.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,_a.assert(sP(c.shape,p.shape),(()=>`packed reshape ${c.shape} to ${p.shape} isn't free`));let f=dB({inputs:{x:r},backend:i,attrs:{shape:[1,a.inChannels,a.outChannels]}});y.push(f);let m=kB({a:p,b:f,backend:i,transposeA:false,transposeB:g,bias:s,activation:u,preluActivationWeights:o,leakyreluAlpha:l}),b=i.texData.get(m.dataId);_a.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,b.shape=a.outShape,t=Vz({inputs:{x:m},backend:i}),t.shape=a.outShape,y.push(m)}else{let e=a.outHeight*a.outWidth,d=dB({inputs:{x:n},backend:i,attrs:{shape:m?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),c=dB({inputs:{x:r},backend:i,attrs:{shape:[1,a.inChannels,a.outChannels]}}),p=kB({a:m?d:c,b:m?c:d,transposeA:!m,transposeB:g,backend:i,bias:s,activation:u,preluActivationWeights:o,leakyreluAlpha:l});t=dB({inputs:{x:p},backend:i,attrs:{shape:a.outShape}}),y.push(d),y.push(c),y.push(p)}for(let b of y)i.disposeIntermediateTensorInfo(b);return t}function YW(e){let{x:t,filter:n,convInfo:r,backend:a,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:l=null}=e,{filterWidth:u,filterHeight:d,inChannels:c,outWidth:p,outHeight:h,dataFormat:f}=r,m="channelsLast"===f,g=u*d*c,y=h*p,b=[r.batchSize,g,y],v=[];if(null!=s){let e=KW(s.shape,m);null!=e&&(s=dB({inputs:{x:s},backend:a,attrs:{shape:e}}),v.push(s))}if(null!=i){let e=KW(i.shape,m);null!=e&&(i=dB({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}let x=dB({inputs:{x:n},backend:a,attrs:{shape:[1,g,_a.sizeFromShape(n.shape)/g]}});v.push(x);let w=new qW(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=dB({inputs:{x:S},backend:a,attrs:{shape:b}});v.push(S),v.push(I);let N=null!=i,T=null!=s,_="leakyrelu"===l,C=l?nB(l,!0):null,E=new rB(m?I.shape:x.shape,m?x.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,N,C,T,_),A=m?[I,x]:[x,I];if(i&&A.push(i),T&&A.push(s),_){let e=a.makeTensorInfo([],"float32",_a.createScalarValue(o,"float32"));A.push(e),v.push(e)}let $=a.runWebGLProgram(E,A,"float32"),R=dB({inputs:{x:$},backend:a,attrs:{shape:r.outShape}});v.push($);for(let F of v)a.disposeIntermediateTensorInfo(F);return R}var QW={kernelName:Nt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i,filter:s}=n,{strides:o,pad:l,dataFormat:u,dilations:d,dimRoundingMode:c}=a,p=em.convertConv2DDataFormat(u),h=em.computeConv2DInfo(i.shape,s.shape,o,d,l,c,!1,p);if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===p&&Ge().getBool("WEBGL_EXP_CONV")){let e=new jW(h),n=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];t=r.runWebGLProgram(e,[i,s],"float32",n)}else if(Ge().getBool("WEBGL_CONV_IM2COL"))t=YW({x:i,filter:s,convInfo:h,backend:r});else{let e=new GW(h);t=r.runWebGLProgram(e,[i,s],"float32")}else t=XW({x:i,filter:s,convInfo:h,backend:r});let f=dB({inputs:{x:t},backend:r,attrs:{shape:h.outShape}});return r.disposeIntermediateTensorInfo(t),f}},JW=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${i?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},ZW=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=i?1:2,u=i?2:3,d=i?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${d}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},eU=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,i=e.padInfo.top,s=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${i};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${s};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},tU=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var nU={kernelName:Tt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:d}=r,c=em.convertConv2DDataFormat(l),p=em.computeConv2DInfo(a.shape,d,s,1,o,u,!1,c),h=new JW(p);return n.runWebGLProgram(h,[a,i],"float32")}},rU=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=VP(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};var aU={kernelName:_t,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{inputShape:s,strides:o,pad:l,dataFormat:u,dimRoundingMode:d}=r,c=em.convertConv2DDataFormat(u),p=em.computeConv2DInfo(s,i.shape,o,1,l,d,!1,c);if(Ge().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===c){let e=[[p.strideHeight,p.strideWidth]],t=new rU(p);return n.runWebGLProgram(t,[a,i],"float32",e)}{let e=new ZW(p);return n.runWebGLProgram(e,[a,i],"float32")}}};var iU={kernelName:Ct,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r,u=em.computeConv3DInfo(a.shape,i.shape,s,l,o),d=new HW(u);return n.runWebGLProgram(d,[a,i],"float32")}};var sU={kernelName:Et,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,filterShape:l}=r,u=em.computeConv3DInfo(a.shape,l,s,1,o),d=new eU(u);return n.runWebGLProgram(d,[a,i],"float32")}};var oU,lU={kernelName:At,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:s,strides:o,inputShape:l}=r,u=em.computeConv3DInfo(l,i.shape,o,1,s),d=new tU(u);return n.runWebGLProgram(d,[a,i],"float32")}},uU=eB({opSnippet:Zz+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Wz}\n  return result;\n`}),dU={kernelName:$t,backendName:"webgl",kernelFunc:uU},cU=eB({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),pU={kernelName:Rt,backendName:"webgl",kernelFunc:cU},hU=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,s,o,l]=e,[u]=t,[d,c]=n;this.outputShape=[u,d,c,l];let p="bilinear"===r?1:0,[h,f]=[s-1+".0",o-1+".0"],[m,g,y]=d>1?[""+(s-1)/(d-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,v,x]=c>1?[""+(o-1)/(c-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},fU={kernelName:Mt,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:i,boxInd:s}=t,{cropSize:o,method:l,extrapolationValue:u}=r,d=new hU(a.shape,i.shape,o,l,u);return n.runWebGLProgram(d,[a,i,s],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(oU||(oU={}));var mU=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,i=this.op===oU.Prod?"1.0":"0.0",s=n?i:`getX(${gU(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${PP(a)} coords = getOutputCoords();\n        int end = ${yU(a,"coords",this.op)};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${yU(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${gU(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function gU(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function yU(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function bU(e,t,n,r,a,i){let s=t.shape.length,o=em.getAxesPermutation([r],s),l=t;null!=o&&(l=xB({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=em.getInnerMostAxes(1,s)[0];if(u!==s-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let d=l.shape[u],c=Vz({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){let t=new mU(e,l.shape,!1,i),r=[[p]],a=c;c=n.runWebGLProgram(t,[c],c.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new mU(e,l.shape,a,i),r=c;c=n.runWebGLProgram(t,[c],c.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=xB({inputs:{x:c},backend:n,attrs:{perm:em.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),e}return c}var vU={kernelName:Ft,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;return bU(oU.Prod,a,n,i,s,o)}};var xU={kernelName:Dt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;return bU(oU.Sum,a,n,i,s,o)}};var wU={kernelName:Ot,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(i.dataId),r=kL(e,t,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(i),r=SL(e,t,s,o);return n.makeTensorInfo(r.shape,i.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},kU=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};var SU={kernelName:Pt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:i,dataFormat:s}=r,o=a.shape[0],l=("NHWC"===s?a.shape[1]:a.shape[2])*i,u=("NHWC"===s?a.shape[2]:a.shape[3])*i,d=("NHWC"===s?a.shape[3]:a.shape[1])/(i*i),c=new kU("NHWC"===s?[o,l,u,d]:[o,d,l,u],i,s);return n.runWebGLProgram(c,[a],a.dtype)}},IU=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VP(this.outputShape.length);let i=e.filterHeight,s=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `}},NU=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VP(this.outputShape.length);let i=e.outChannels/e.inChannels,s=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,c=d,p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<d;g++)p+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;p+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<d;g++)p+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(c+1)/2;g++){let e=2*g;if(p+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<d&&(s%2===1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,p+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<d)){let t=s%2===0?_a.nearestLargerEven(l):l;l%2===0&&s%2===1||l%2!==0&&s%2!==1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,p+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):p+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<d&&(s%2===1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<d&&(p+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<d&&(p+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<d&&(p+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let h="",f="";n&&(h=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};var TU={kernelName:Lt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l,dimRoundingMode:u}=r,d=l;null==d&&(d=[1,1]),_a.assert(em.eitherStridesOrDilationsAreOne(s,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`));let c,p=em.computeConv2DInfo(a.shape,i.shape,s,d,o,u,!0);c=Ge().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?new NU(p):new IU(p);let h=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(c,[a,i],"float32",h)}},_U=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},CU=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=t-1-e.padInfo.top,s=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var EU={kernelName:zt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,filterShape:d}=r,c=em.computeConv2DInfo(a.shape,d,s,o,l,u,!0),p=new _U(c);return n.runWebGLProgram(p,[a,i],"float32")}};var AU={kernelName:Bt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,inputShape:d}=r,c=em.computeConv2DInfo(d,i.shape,s,o,l,u,!0),p=new CU(c);return n.runWebGLProgram(p,[a,i],"float32")}},$U=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};var RU={kernelName:Wt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],i=_a.sizeFromShape(r.shape),s=dB({inputs:{x:r},backend:n,attrs:{shape:[i]}}),o=new $U(i),l=n.runWebGLProgram(o,[s],s.dtype),u=dB({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(l),u}},FU=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:i,filterHeight:s,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:d,left:c}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${d}, ${c});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${s}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};var DU={kernelName:Ut,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i,filter:s}=n,{strides:o,pad:l,dilations:u}=a,d=em.computeDilation2DInfo(i.shape,s.shape,o,l,"NHWC",u),c=new FU(d);t=r.runWebGLProgram(c,[i,s],"float32");let p=dB({inputs:{x:t},backend:r,attrs:{shape:d.outShape}});return r.disposeIntermediateTensorInfo(t),p}};var MU={kernelName:qt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,i=t,{allDims:s,summedDims:o,idDims:l}=em.decodeEinsumEquation(a,i.length);em.checkEinsumDimSizes(s.length,l,i);let{path:u,steps:d}=em.getEinsumComputePath(o,l),c=d.length,p=null,h=s.length,f=[];for(let m=0;m<c;++m){for(let e of d[m]){let t,{permutationIndices:r,expandDims:a}=em.getEinsumPermutation(h,l[e]);em.isIdentityPermutation(r)?t=i[e]:(t=xB({inputs:{x:i[e]},backend:n,attrs:{perm:r}}),f.push(t));let s=t.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);_a.arraysEqual(t.shape,s)||(t=dB({inputs:{x:t},backend:n,attrs:{shape:s}}),f.push(t)),null===p?p=t:(p=lB({inputs:{a:t,b:p},backend:n}),f.push(p))}m<c-1&&(u[m]>=0&&(p=bB({inputs:{x:p},backend:n,attrs:{axis:u[m]-(s.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}},OU=eB({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),PU={kernelName:Kt,backendName:"webgl",kernelFunc:OU},LU={kernelName:Xt,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,i=Ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Uz("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new Bz("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(i,[r,a],r.dtype)}},zU=tB({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:CL}),BU={kernelName:Qt,backendName:"webgl",kernelFunc:zU},WU=eB({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${em.ERF_P};\n  float a1 = ${em.ERF_A1};\n  float a2 = ${em.ERF_A2};\n  float a3 = ${em.ERF_A3};\n  float a4 = ${em.ERF_A4};\n  float a5 = ${em.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),UU={kernelName:Yt,backendName:"webgl",kernelFunc:WU},VU=eB({opSnippet:Zz+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:EL,dtype:"float32"}),GU={kernelName:Jt,backendName:"webgl",kernelFunc:VU};function HU(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:i}=t,s=i.shape.length,o=i.shape.slice(),l=a;return a<0&&(_a.assert(-(s+1)<=a,(()=>`Axis must be in the interval [${-(s+1)}, ${s}]`)),l=s+a+1),o.splice(l,0,1),dB({inputs:{x:i},backend:r,attrs:{shape:o}})}var jU={kernelName:Zt,backendName:"webgl",kernelFunc:HU},qU="return exp(x) - 1.0;",KU=eB({opSnippet:qU,packedOpSnippet:qU,cpuKernelImpl:AL}),XU={kernelName:en,backendName:"webgl",kernelFunc:KU},YU=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function QU(e,t,n){let r=n.texData.get(e.dataId),a=_a.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],s=dB({inputs:{x:e},backend:n,attrs:{shape:[a/i,i]}}),o=s.shape,l=new YU("real",o,t),u=new YU("imag",o,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],c=n.runWebGLProgram(l,d,"float32"),p=n.runWebGLProgram(u,d,"float32"),h=Hz({inputs:{real:c,imag:p},backend:n});n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p);let f=dB({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(h),f}var JU={kernelName:tn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return QU(r,!1,n)}},ZU=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function eV(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:i}=n;if(i=i||_a.inferDtype(a),"string"===i){let e=_a.getArrayFromDType(i,_a.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,i,e)}{let e=new ZU(r,a),n=[[a]];return t.runWebGLProgram(e,[],i,n)}}var tV,nV={kernelName:nn,backendName:"webgl",kernelFunc:eV},rV=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},aV={kernelName:rn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{image:r}=t,a=n,i=new rV(r.shape);return a.runWebGLProgram(i,[r],r.dtype)}},iV="return floor(x);",sV=eB({opSnippet:iV,packedOpSnippet:iV,cpuKernelImpl:$L}),oV={kernelName:an,backendName:"webgl",kernelFunc:sV},lV=tB({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),uV={kernelName:sn,backendName:"webgl",kernelFunc:lV},dV=class{constructor(e){this.variableNames=["A"];let t=xP(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},cV=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=xP(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},pV={kernelName:ua,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:i}=r,s="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=s?[a.videoWidth,a.videoHeight]:[a.width,a.height],d=[u,l],c=[u,l,i];if(o||s){let e=Ge().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==tV||e!==hV)&&(hV=e,tV=document.createElement("canvas").getContext("2d",{willReadFrequently:hV})),tV.canvas.width=l,tV.canvas.height=u,tV.drawImage(a,0,0,l,u),a=tV.canvas}let p=n.makeTensorInfo(d,"int32");n.texData.get(p.dataId).usage=cO.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),a);let h=Ge().getBool("WEBGL_PACK")?new cV(c):new dV(c),f=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),f}},hV=Ge().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var fV={kernelName:pa,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i,filter:s,bias:o,preluActivationWeights:l}=n,{strides:u,pad:d,dataFormat:c,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=a,g=em.convertConv2DDataFormat(c),y=em.computeConv2DInfo(i.shape,s.shape,u,p,d,h,!1,g),b=[],v=null!=o,x=null!=l,w="leakyrelu"===f,k=()=>{let e=[i,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=dB({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(o,c)),x&&e.push(t(l,c)),w){let t=r.makeTensorInfo([],"float32",_a.createScalarValue(m,"float32"));e.push(t),b.push(t)}return e};if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===g&&Ge().getBool("WEBGL_EXP_CONV")){let e=f?nB(f,!0):null,n=new jW(y,v,e,x,w),a=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],i=k();t=r.runWebGLProgram(n,i,"float32",a)}else if(Ge().getBool("WEBGL_CONV_IM2COL"))t=YW({x:i,filter:s,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=f?nB(f,!1):null,n=new GW(y,v,e,x,w),a=k();t=r.runWebGLProgram(n,a,"float32")}else t=XW({x:i,filter:s,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let S=dB({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),S}};var mV={kernelName:ha,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:d,dimRoundingMode:c,activation:p,leakyreluAlpha:h}=r,f=[],m=d;null==m&&(m=[1,1]),_a.assert(em.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=em.computeConv2DInfo(a.shape,i.shape,l,m,u,c,!0),b=Ge().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=p?nB(p,b):null,x=[a,i],w=null!=s,k=null!=o,S="leakyrelu"===p;if(w&&x.push(s),k&&x.push(o),S){let e=n.makeTensorInfo([],"float32",_a.createScalarValue(h,"float32"));x.push(e),f.push(e)}g=b?new NU(y,w,v,k,S):new IU(y,w,v,k,S);let I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],N=n.runWebGLProgram(g,x,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}},gV=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=PP(n.length),i="\n    int index;";for(let s=0;s<this.sliceDim;s++)i+=`\n          index = round(getIndices(coords[0], ${s}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[s]};\n          flattenIndex += index * ${this.strides[s]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};var yV={kernelName:un,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,i=a.shape,s=i[i.length-1],o=_a.sizeFromShape(r.shape),[l,u,d,c]=em.prepareAndValidate(r,a),p=dB({inputs:{x:a},backend:n,attrs:{shape:[u,s]}}),h=dB({inputs:{x:r},backend:n,attrs:{shape:[_a.sizeFromShape(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),i=RL(e,t,r.dtype,u,s,d,c,r.shape,o);return n.makeTensorInfo(l,r.dtype,i.values)}let f=new gV(s,c,[u,d],r.shape),m=n.runWebGLProgram(f,[h,p],h.dtype),g=dB({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}},bV=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=PP(this.rank),r=function(e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function vV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:i}=t,{axis:s,batchDims:o}=r,l=_a.parseAxisParam(s,a.shape)[0];if(Ge().get("DEBUG")){let e=n.readSync(i.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];_a.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=em.segment_util.collectGatherOpShapeInfo(a,i,l,o),d=_a.sizeFromShape(i.shape),c=[],p=dB({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=dB({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,d/u.batchSize]}});c.push(p),c.push(h);let f=[u.batchSize,u.outerSize,d/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,i])||"string"===a.dtype){let e=n.bufferSync(h),t=n.bufferSync(p),r=FL(t,e,f);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new bV(p.shape,f),g=n.runWebGLProgram(m,[p,h],p.dtype);c.push(g);let y=dB({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var xV={kernelName:ln,backendName:"webgl",kernelFunc:vV},wV=tB({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:DL,dtype:"bool"}),kV={kernelName:dn,backendName:"webgl",kernelFunc:wV},SV=tB({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:ML}),IV={kernelName:cn,backendName:"webgl",kernelFunc:SV};var NV={kernelName:hn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return QU(r,!0,n)}},TV=eB({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),_V={kernelName:mn,backendName:"webgl",kernelFunc:TV},CV=eB({opSnippet:"return float(isinf(x));",dtype:"bool"}),EV={kernelName:gn,backendName:"webgl",kernelFunc:CV},AV=eB({opSnippet:"return float(isnan(x));",dtype:"bool"}),$V={kernelName:yn,backendName:"webgl",kernelFunc:AV},RV=tB({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:OL,dtype:"bool"}),FV={kernelName:vn,backendName:"webgl",kernelFunc:RV},DV=tB({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:PL,dtype:"bool"}),MV={kernelName:xn,backendName:"webgl",kernelFunc:DV};var OV={kernelName:wn,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:i}=n,s=LL(r,a,i);return t.makeTensorInfo([s.length],"float32",s)}},PV=eB({opSnippet:Zz+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:zL}),LV={kernelName:kn,backendName:"webgl",kernelFunc:PV},zV=eB({opSnippet:Zz+"\n  return log(1.0 + x);\n"}),BV={kernelName:Sn,backendName:"webgl",kernelFunc:zV},WV=tB({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),UV={kernelName:In,backendName:"webgl",kernelFunc:WV},VV=eB({opSnippet:"return float(!(x >= 1.0));"}),GV={kernelName:Nn,backendName:"webgl",kernelFunc:VV},HV=tB({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),jV={kernelName:Tn,backendName:"webgl",kernelFunc:HV},qV=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let i=t,s=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${s}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},KV=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,s=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},XV={kernelName:An,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:s,alpha:o,beta:l}=r,u=Ge().getBool("WEBGL_PACK_NORMALIZATION")?new KV(a.shape,i,s,o,l):new qV(a.shape,i,s,o,l);return n.runWebGLProgram(u,[a],a.dtype)}},YV=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},QV={kernelName:$n,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:s}=t,{depthRadius:o,bias:l,alpha:u,beta:d}=r,c=new YV(a.shape,o,l,u,d);return n.runWebGLProgram(c,[a,i,s],a.dtype)}};function JV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:i,keepDims:s}=r,o=a.shape.length,l=_a.parseAxisParam(i,a.shape),u=l,d=em.getAxesPermutation(u,o),c=null!=d,p=n.shouldExecuteOnCPU([a]),h=a;if(c){if(p){let e=n.texData.get(h.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[d[n]];let r=fz(e,a.shape,a.dtype,d,t);h=n.makeTensorInfo(t,a.dtype),n.texData.get(h.dataId).values=r}else h=yB(a,d,n);u=em.getInnerMostAxes(u.length,o)}em.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=em.computeOutAndReduceShapes(h.shape,u),y=m;if(s&&(y=em.expandShapeToKeepDim(m,l)),p){let e=n.texData.get(h.dataId).values,t=BL(e,_a.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype),n.texData.get(f.dataId).values=t}else f=function(e,t,n,r){let a=_a.sizeFromShape(t),i=dB({inputs:{x:e},attrs:{shape:[_a.sizeFromShape(e.shape)/a,a]},backend:r}),s=fB(i,e.dtype,"max",r),o=dB({inputs:{x:s},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(s),o}(h,g,y,n);return c&&n.disposeIntermediateTensorInfo(h),f}var ZV={kernelName:Fn,backendName:"webgl",kernelFunc:JV},eG=tB({opSnippet:zz+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Wz+"\n  return result;\n",cpuKernelImpl:WL}),tG={kernelName:Dn,backendName:"webgl",kernelFunc:eG};var nG={kernelName:Mn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;bP(a,"maxPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;_a.assert(em.eitherStridesOrDilationsAreOne(s,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`));let u=em.computePool2DInfo(a.shape,i,s,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&_a.arraysEqual(u.inShape,u.outShape))return Vz({inputs:{x:a},backend:n});let d=new tW(u,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};var rG={kernelName:Pn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dataFormat:l,dimRoundingMode:u}=r,d=em.computePool3DInfo(a.shape,i,s,[1,1,1],o,u,l),c=new nW(d,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}},aG=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,i=e.effectiveFilterWidth,s=a-1-e.padInfo.top,o=i-1-e.padInfo.left,l=a*i-1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},iG=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,s=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=o-1-e.padInfo.front,c=l-1-e.padInfo.top,p=u-1-e.padInfo.left,h=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${c}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${i}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${s}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var sG={kernelName:Ln,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=r,c=em.computePool3DInfo(s.shape,o,l,[1,1,1],u,d),p=new nW(c,"max",!0),h=n.runWebGLProgram(p,[s],s.dtype),f=new iG(c),m=n.runWebGLProgram(f,[a,h],s.dtype);return n.disposeIntermediateTensorInfo(h),m}};var oG={kernelName:On,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i,output:s}=t,o=i;bP([i,s],"maxPoolGrad");let{filterSize:l,strides:u,pad:d,dimRoundingMode:c}=r,p=em.computePool2DInfo(o.shape,l,u,1,d,c),h=new tW(p,"max",!0),f=n.runWebGLProgram(h,[o],o.dtype),m=new aG(p),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};var lG={kernelName:zn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:l}=n,u=r;_a.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let d=[1,1];_a.assert(em.eitherStridesOrDilationsAreOne(s,d),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`));let c=em.computePool2DInfo(a.shape,i,s,d,o),[p,h]=function(e,t,n,r){let a=new tW(n,"max",!1),i=r.runWebGLProgram(a,[e],"float32");return a=new tW(n,"max",!0,!0,t),[i,r.runWebGLProgram(a,[e],"float32")]}(a,l,c,u);return[p,h]}};var uG={kernelName:Bn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{keepDims:i,axis:s}=n,o=r,l=a.shape.length,u=_a.parseAxisParam(s,a.shape),d=u,c=em.getAxesPermutation(d,l),p=null!=c,h=o.shouldExecuteOnCPU([a]),f=[],m=a;if(p){if(h){let e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[c[r]];let n=fz(e,a.shape,a.dtype,c,t);m=o.makeTensorInfo(t,a.dtype),o.texData.get(m.dataId).values=n}else m=yB(a,c,o);f.push(m),d=em.getInnerMostAxes(d.length,l)}em.assertAxesAreInnerMostDims("sum",d,l);let[g,y]=em.computeOutAndReduceShapes(m.shape,d),b=g;i&&(b=em.expandShapeToKeepDim(g,u));let v=function(e,t,n,r){let a=_a.sizeFromShape(t),i=dB({inputs:{x:e},attrs:{shape:[_a.sizeFromShape(e.shape)/a,a]},backend:r}),s=fB(i,"float32","mean",r),o=dB({inputs:{x:s},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(s),o}(m,y,b,o);for(let x of f)o.disposeIntermediateTensorInfo(x);return v}};var dG={kernelName:Wn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=a.shape.length,l=_a.parseAxisParam(i,a.shape),u=l,d=em.getAxesPermutation(u,o),c=a;null!=d&&(c=xB({inputs:{x:a},backend:n,attrs:{perm:d}}),u=em.getInnerMostAxes(u.length,a.shape.length)),em.assertAxesAreInnerMostDims("min",u,o);let p,[h,f]=em.computeOutAndReduceShapes(c.shape,u),m=dB({inputs:{x:c},backend:n,attrs:{shape:[-1,_a.sizeFromShape(f)]}}),g=fB(m,m.dtype,"min",n);if(s){p=dB({inputs:{x:g},backend:n,attrs:{shape:em.expandShapeToKeepDim(h,l)}})}else p=dB({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(c),p}},cG=tB({opSnippet:zz+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Wz+"\n  return result;\n",cpuKernelImpl:UL}),pG={kernelName:Un,backendName:"webgl",kernelFunc:cG},hG=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=PP(r),i=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},fG=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=PP(r),i=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=yz("rc",r),l=yz("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${l.slice(-2).join()})`,c="reflect"===n?0:1,p="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${c};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${c};\n        }\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${d});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${d});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${c}) +\n                gte * ((end - 1) * 2 - source + ${c});\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${d});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${d});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}},mG={kernelName:Vn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,mode:s}=r,o=Ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fG(a.shape,i,s):new hG(a.shape,i,s);return n.runWebGLProgram(o,[a],a.dtype)}},gG=tB({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Wz+"\n  return result;\n"}),yG={kernelName:Gn,backendName:"webgl",kernelFunc:gG},bG=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},vG=tB({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),xG={kernelName:jt,backendName:"webgl",kernelFunc:vG},wG="return a - b;",kG=tB({opSnippet:wG,packedOpSnippet:wG,supportsComplex:!0,cpuKernelImpl:cz}),SG={kernelName:Yr,backendName:"webgl",kernelFunc:kG};function IG(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:i}=r,s=_a.parseAxisParam([i],a.shape),o=JV({inputs:{x:a},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),l=em.expandShapeToKeepDim(o.shape,s),u=dB({inputs:{x:o},backend:n,attrs:{shape:l}}),d=kG({inputs:{a:a,b:u},backend:n}),c=VU({inputs:{x:d},backend:n}),p=bB({inputs:{x:c},backend:n,attrs:{axis:s,keepDims:!1}}),h=dB({inputs:{x:p},backend:n,attrs:{shape:l}}),f=vG({inputs:{a:c,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}var NG={kernelName:Pr,backendName:"webgl",kernelFunc:IG};var TG={kernelName:Hn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:s,normalized:o}=r,l=o?a:IG({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],d=l.shape[1],c=new bG(u,d,i),p=[[s]],h=n.runWebGLProgram(c,[l],"int32",p);return o||n.disposeIntermediateTensorInfo(l),h}},_G=Nz+"\n  return -x;\n";var CG={kernelName:qn,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=GL(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=Ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Az(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Iz(a.shape,_G),r.runWebGLProgram(t,[a],a.dtype)}},EG=sg.nonMaxSuppressionV3Impl;var AG={kernelName:Xn,backendName:"webgl",kernelFunc:function(e){em.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),d=n.readSync(i.dataId),{selectedIndices:c}=EG(u,d,s,o,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}},$G=sg.nonMaxSuppressionV4Impl;var RG={kernelName:Yn,backendName:"webgl",kernelFunc:function(e){em.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,d=n.readSync(a.dataId),c=n.readSync(i.dataId),{selectedIndices:p,validOutputs:h}=$G(d,c,s,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},FG=sg.nonMaxSuppressionV5Impl;var DG={kernelName:Qn,backendName:"webgl",kernelFunc:function(e){em.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,d=n.readSync(a.dataId),c=n.readSync(i.dataId),p=s,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=FG(d,c,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},MG=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},OG={kernelName:Zn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:s,onValue:o,offValue:l}=r,u=_a.sizeFromShape(a.shape),d=new MG(u,s,o,l),c=dB({inputs:{x:a},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(d,[c],i);n.disposeIntermediateTensorInfo(c);let h=dB({inputs:{x:p},backend:n,attrs:{shape:[...a.shape,s]}});return n.disposeIntermediateTensorInfo(p),h}};function PG(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=IW({inputs:{input:r},backend:n}),t=PG({inputs:{x:e},backend:n}),a=zW({inputs:{input:r},backend:n}),i=PG({inputs:{x:a},backend:n}),s=Hz({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),s}return eV({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var LG={kernelName:oa,backendName:"webgl",kernelFunc:PG};var zG={kernelName:Jn,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){let t=IW({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),i=zW({inputs:{input:a},backend:r}),s=PG({inputs:{x:i},backend:r}),o=Hz({inputs:{real:n,imag:s},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(s),o}return eV({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};var BG={kernelName:er,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return HU({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,s=t[0].dtype;t.forEach((e=>{_a.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),_a.assert(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=UW({inputs:t.map((e=>{let t=HU({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}},WG=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=PP(r),i=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},UG=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=PP(r),i=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),o=yz("rc",r),l=yz("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${l.slice(-2).join()})`,c=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,m=1===r?2:4;f<m;f++)h+=`\n        ${c[f]}\n        if (${p}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${d});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},VG=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,constantValue:s}=r;if(0===_a.sizeFromShape(a.shape)){return eV({backend:n,attrs:{shape:i.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:s,dtype:a.dtype}})}let o=Ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UG(a.shape,i,s):new WG(a.shape,i,s),l=[[s]];return n.runWebGLProgram(o,[a],a.dtype,l)},GG={kernelName:tr,backendName:"webgl",kernelFunc:VG},HG=tB({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Wz+"\n  return result;\n"}),jG={kernelName:rr,backendName:"webgl",kernelFunc:HG};var qG={kernelName:ir,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{axis:s,keepDims:o}=a,l=i.shape.length,u=[],d=_a.parseAxisParam(s,i.shape),c=d,p=em.getAxesPermutation(c,l),h=i;if(null!=p&&(h=xB({inputs:{x:i},backend:r,attrs:{perm:p}}),c=em.getInnerMostAxes(c.length,l),u.push(h)),em.assertAxesAreInnerMostDims("prod",c,l),r.shouldExecuteOnCPU([h])){let e=r.texData.get(h.dataId).values,{outVals:n,outShape:a,outDtype:i}=jL(h.shape,h.dtype,e,c);t=r.makeTensorInfo(a,i,n)}else{let[e,n]=em.computeOutAndReduceShapes(h.shape,c),a=_a.sizeFromShape(n),s=dB({inputs:{x:h},backend:r,attrs:{shape:[-1,a]}}),o=fB(s,xi(i.dtype),"prod",r);t=dB({inputs:{x:o},backend:r,attrs:{shape:e}}),u.push(s),u.push(o)}if(o){u.push(t);let e=em.expandShapeToKeepDim(t.shape,d);t=dB({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}};var KG={kernelName:sr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:i,indices:s}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),d=n.readSync(i.dataId),c=n.readSync(s.dataId),[p,h,f]=qL(l,u,d,i.shape,i.dtype,c,s.shape,o),m=p.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,i.dtype,h);return m.concat([g])}};var XG={kernelName:or,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:i}=t,s=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,d]=KL(s,r.shape,r.dtype,o,a.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([d.length],r.dtype,d)]}};var YG={kernelName:lr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:i,defaultValue:s,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),d=n.readSync(i.dataId),c=n.readSync(s.dataId),p=o.map((e=>n.readSync(e.dataId))),h=o.map((e=>e.shape)),[f,m]=XL(u,a.shape,d,i.shape,i.dtype,c,s.shape,p,h,l);return n.makeTensorInfo(f,i.dtype,m)}},QG=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:i,dtype:s}=n,o=YL(r,a,i,s);return t.makeTensorInfo([o.length],s,o)},JG={kernelName:ur,backendName:"webgl",kernelFunc:QG},ZG=eB({opSnippet:"return 1.0 / x;"}),eH={kernelName:cr,backendName:"webgl",kernelFunc:ZG},tH=eB({opSnippet:Nz+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),nH={kernelName:pr,backendName:"webgl",kernelFunc:tH},rH=eB({opSnippet:Nz+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),aH={kernelName:br,backendName:"webgl",kernelFunc:rH},iH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},sH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]},\n          ${d[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};var oH={kernelName:gr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r,[l,u]=o,d=Ge().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sH(a.shape,l,u,i,s):new iH(a.shape,l,u,i,s);return n.runWebGLProgram(d,[a],"float32")}},lH=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,i,s]=e,o=[n&&i>1?r-1:r,n&&s>1?a-1:a],l=[n&&i>1?i-1:i,n&&s>1?s-1:s],u=o[0]/l[0],d=o[1]/l[1],c=1/u,p=1/d,h=2*Math.ceil(c)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var uH={kernelName:yr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r,o=new lH(i.shape,a.shape,s);return n.runWebGLProgram(o,[i],i.dtype)}},dH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},cH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]},\n          ${d[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};var pH={kernelName:fr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r,[l,u]=o,d=Ge().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new cH(a.shape,l,u,i,s):new dH(a.shape,l,u,i,s);return n.runWebGLProgram(d,[a],a.dtype)}},hH=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,i,s]=e,o=[n&&i>1?r-1:r,n&&s>1?a-1:a],l=[n&&i>1?i-1:i,n&&s>1?s-1:s],u=o[0]/l[0],d=o[1]/l[1],c=1/u,p=1/d,h=2*Math.ceil(c)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var fH={kernelName:mr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r,o=new hH(i.shape,a.shape,s);return n.runWebGLProgram(o,[i],i.dtype)}},mH=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=PP(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}},gH=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=yz("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,s=PP(n);var o;function l(n){let r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${s} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o=r.slice(),l(o)};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};var yH={kernelName:vr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r,s=a.shape.length,o=_a.parseAxisParam(i,a.shape);if(0===s)return Vz({inputs:{x:a},backend:n});let l=Ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gH(a.shape,o):new mH(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}},bH=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},vH={kernelName:da,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:i,fillValue:s,center:o}=n,l=r,u=new bH(a.shape,s),[d,c]=em.getImageCenter(o,a.shape[1],a.shape[2]),p=[[d,c,Math.sin(i),Math.cos(i)]];return l.runWebGLProgram(u,[a],a.dtype,p)}},xH=eB({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),wH={kernelName:xr,backendName:"webgl",kernelFunc:xH},kH=eB({opSnippet:"return inversesqrt(x);",cpuKernelImpl:QL}),SH={kernelName:wr,backendName:"webgl",kernelFunc:kH},IH=class{constructor(e,t,n,r,a,i){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let o=PP(a.length),l=PP(i.length),u="";1===n?u="i":2===n&&(u="i, j");let d=`getIndices(${u})`,c="";1===r?c="i":2===r&&(c="i, coords[1]");let p=`getUpdates(${c})`,h="";s&&(h="coords[0], coords[1]");let f=`getDefaultValue(${h})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}},NH=class{constructor(e,t,n,r,a,i){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let o=PP(a.length),l=PP(i.length),u="";1===n?u="i":2===n&&(u="i, j");let d=`getIndices(${u})`,c="";1===r?c="i":2===r&&(c="i, coords[1]");let p=`getUpdates(${c})`,h="";s&&(h="coords[0], coords[1]");let f=`getDefaultValue(${h})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}};var TH={kernelName:kr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:i}=t,{shape:s}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:d,outputSize:c}=em.calculateShapes(i,a,s),p=[c/u,u];if(0===c)return n.makeTensorInfo(s,a.dtype);let h,f=dB({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=dB({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));h=Ge().getBool("WEBGL_PACK")?new NH(l,o,f.shape.length,m.shape.length,d,p):new IH(l,o,f.shape.length,m.shape.length,d,p);let y=n.runWebGLProgram(h,[m,f,g],m.dtype),b=dB({inputs:{x:y},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),b}},_H=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===Ge().getNumber("WEBGL_VERSION")?"while (left < right) {":a,s="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${s} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};var CH={kernelName:Ir,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:s}=r,o=new _H(a.shape[0],a.shape[1],i.shape[1],s),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,i],"int32",l)}},EH=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[];for(let r=0;r<t.length;r++)s.push(`${n[r]}`),r<e&&i.push(`${n[r]}`);r=i.join(),a=s.join()}let i=PP(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};var AH={kernelName:Nr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t,s=new EH(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(s,[r,a,i],vi(a.dtype,i.dtype))}},$H=eB({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${em.SELU_SCALEALPHA};\n  float scale = ${em.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),RH={kernelName:Tr,backendName:"webgl",kernelFunc:$H},FH=eB({opSnippet:Zz+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:ZL}),DH={kernelName:$r,backendName:"webgl",kernelFunc:FH},MH=eB({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),OH={kernelName:Ar,backendName:"webgl",kernelFunc:MH},PH=eB({opSnippet:Zz+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Wz}\n  return result;\n`}),LH={kernelName:Cr,backendName:"webgl",kernelFunc:PH},zH=eB({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),BH={kernelName:Er,backendName:"webgl",kernelFunc:zH},WH=eB({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),UH={kernelName:Rr,backendName:"webgl",kernelFunc:WH},VH={kernelName:Mr,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:s}=r;_a.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=i.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...s);for(let y=1+i.length;y<a.shape.length;++y)l.push([0,0]);let u=[],d=VG({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=em.getReshaped(d.shape,i,o,!1),p=em.getPermuted(c.length,i.length,!1),h=em.getReshapedPermuted(d.shape,i,o,!1),f=dB({inputs:{x:d},backend:n,attrs:{shape:c}}),m=xB({inputs:{x:f},backend:n,attrs:{perm:p}}),g=dB({inputs:{x:m},backend:n,attrs:{shape:h}});return u.push(d),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};var GH={kernelName:Lr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:i,defaultValue:s}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(i.dataId),d=n.readSync(s.dataId)[0],[c,p,h,f,m]=nz(o,r.shape,r.dtype,l,a.dtype,u,d);return[n.makeTensorInfo(p,r.dtype,c),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var HH={kernelName:zr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(i.dataId)),[u,d,c]=rz(o,r.shape,r.dtype,s,l);return[n.makeTensorInfo(d,r.dtype,u),n.makeTensorInfo([c.length],i.dtype,new Int32Array(c))]}};var jH={kernelName:Br,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);let s=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,d]=az(s,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(d,r.dtype,u)}};var qH={kernelName:Wr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);let s=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,d]=az(s,r.shape,r.dtype,o,l);return n.makeTensorInfo(d,r.dtype,u)}};var KH={kernelName:Ur,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:i,defaultValue:s}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=em.calculateShapes(i,a,o),h=!1;if("string"===i.dtype){let e=n.bufferSync(a),t=n.bufferSync(i),r=_a.decodeString(n.readSync(s.dataId)[0]),f=JL(e,t,o,p,d,u,l,c,r,h);return n.makeTensorInfo(o,f.dtype,f.values)}let f=new IH(u,l,a.shape.length,i.shape.length,c,[p,1],h),m=n.runWebGLProgram(f,[i,a,s],i.dtype),g=dB({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};var XH={kernelName:Or,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:s}=r,o=_a.parseAxisParam(s,a.shape)[0],l=em.prepareSplitSize(a,i,o),u=a.shape.length,d=new Array(u).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let r=gW({inputs:{x:a},backend:n,attrs:{begin:d,size:t}});return d[o]+=e,r}))}},YH="return sqrt(x);",QH=eB({opSnippet:YH,packedOpSnippet:YH,cpuKernelImpl:iz}),JH={kernelName:Fr,backendName:"webgl",kernelFunc:QH},ZH=eB({opSnippet:"return x * x;"}),ej={kernelName:Gr,backendName:"webgl",kernelFunc:ZH},tj="return (a - b) * (a - b);",nj=tB({opSnippet:tj,packedOpSnippet:tj}),rj={kernelName:Vr,backendName:"webgl",kernelFunc:nj};var aj={kernelName:Hr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let i=n.readSync(a.dataId),s=em.fromUint8ToStringArray(i),o=sz(s,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};var ij={kernelName:la,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,i=Nz+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,s=new Iz(a.shape,i);return r.runWebGLProgram(s,[a],a.dtype)}},sj=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=PP(n.length),i=PP(n.length),s="";if(1===r)s="coords * strides + begin";else{let e=0;s=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}};var oj={kernelName:jr,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{begin:s,end:o,strides:l,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=Cf.sliceInfo(i.shape,s,o,l,u,d,c,p,h);if(g)t=dB({inputs:{x:i},backend:r,attrs:{shape:m}});else if(y||b){_a.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));let e=Cf.computeOutShape(v,x,w),n=gW({inputs:{x:i},backend:r,attrs:{begin:v,size:e}});t=dB({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([i])){let e=r.readSync(i.dataId),n=yo(i.shape,i.dtype,e),a=oz(f,n,w,v);t=r.makeTensorInfo(m,i.dtype,a.values)}else{let e=new sj(v,w,f);t=r.runWebGLProgram(e,[i],i.dtype)}let k=dB({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}};var lj={kernelName:qr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:i,leftPad:s,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:d,dataSplits:c}=t,p=n.readSync(d.dataId),h=n.readSync(c.dataId),[f,m]=lz(p,h,a,i,s,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}};var uj={kernelName:Kr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:i,delimiter:s}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);let o=n.readSync(i.dataId),l=n.readSync(s.dataId)[0],[u,d,c]=uz(o,l,a),p=d.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",d),n.makeTensorInfo([2],"int32",new Int32Array(c))]}};var dj={kernelName:Xr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let s=n.readSync(i.dataId),o=dz(s,a);return n.makeTensorInfo(i.shape,"int32",o)}},cj=eB({opSnippet:"return tan(x);"}),pj={kernelName:Qr,backendName:"webgl",kernelFunc:cj},hj=eB({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),fj={kernelName:Jr,backendName:"webgl",kernelFunc:hj};var mj={kernelName:Sr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:i,updates:s}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:d,outputSize:c}=em.calculateShapes(s,i,a.shape),p=[c/u,u];if(0===c)return n.makeTensorInfo(a.shape,i.dtype);let h=dB({inputs:{x:i},backend:n,attrs:{shape:[l,o]}}),f=dB({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=dB({inputs:{x:a},backend:n,attrs:{shape:p}}),g=new IH(l,o,h.shape.length,f.shape.length,d,p,!1,!0),y=n.runWebGLProgram(g,[f,h,m],m.dtype),b=dB({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}},gj=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;let r=PP(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function yj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:i}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>_a.decodeString(e))):e,r=yo(a.shape,a.dtype,t),s=pz(r,i);return n.makeTensorInfo(s.shape,s.dtype,s.values)}let s=new gj(a.shape,i);return n.runWebGLProgram(s,[a],a.dtype)}var bj={kernelName:Zr,backendName:"webgl",kernelFunc:yj},vj=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},xj=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function wj(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function kj(e){let t=1;for(;t<e;)t*=2;return t}var Sj={kernelName:ea,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:s}=r,o=Ge().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ge().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,d=u[u.length-1];if(n.shouldExecuteOnCPU([a])||d<o||i>l){let e=n.readSync(a.dataId),[t,r]=hz(e,u,a.dtype,i,s);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===i)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===d)return[a,eV({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let c=n.texData.get(a.dataId),p=null!==c&&c.isPacked,h=p?n.unpackTensor(a):a,f=_a.sizeFromShape(u)/d,m=dB({inputs:{x:h},attrs:{shape:[f,d]},backend:n});p&&wj(n,h);let g=kj(i),y=kj(d),b=null,v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{let a=v(),i=new vj(r),s=[[d],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(i,a,"int32",s),wj(n,o)};for(let N=1;N<g;N*=2){let e=2*N;for(let t=N;t>=1;t/=2)x(e,t,[f,y])}for(let N=y;N>g;N/=2){let e=v(),t=new xj([f,N/2]),r=[[d],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),wj(n,a);let i=g/2,s=2*i;for(let n=i;n>=1;n/=2)x(s,n,b.shape)}let w=b;b=gW({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,i]}}),wj(n,w);let k=vV({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});wj(n,m);let S=u.slice(0,-1);S.push(i),w=b,b=dB({inputs:{x:b},attrs:{shape:S},backend:n}),wj(n,w);let I=k;return k=dB({inputs:{x:k},attrs:{shape:S},backend:n}),wj(n,I),[k,b]}},Ij=class{constructor(e,t,n,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let s,o="nearest"===n?1:2;switch(r){case"constant":default:s=1;break;case"reflect":s=2;break;case"wrap":s=3;break;case"nearest":s=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${s} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};var Nj={kernelName:ta,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:i}=t,{interpolation:s,fillMode:o,fillValue:l,outputShape:u}=r,[d,c,p,h]=a.shape,[f,m]=null!=u?u:[c,p],g=new Ij(c,p,s,o,l,[d,f,m,h]);return n.runWebGLProgram(g,[a,i],"float32")}};var Tj={kernelName:ra,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t;bP(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let s=r.readSync(i.dataId),{outputValues:o,outputShape:l,indices:u}=mz(s,a,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var _j={kernelName:aa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let s=a,o=s.shape.length,l=a.shape[i],u=new Array(o-1),d=0;for(let m=0;m<o;m++)m!==i&&(u[d++]=s.shape[m]);let c=[],p=new Array(o).fill(0),h=s.shape.slice();h[i]=1;let f=new Array(l);for(let m=0;m<f.length;m++){p[i]=m;let e=gW({inputs:{x:s},backend:n,attrs:{begin:p,size:h}}),t=dB({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,c.push(e)}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},Cj=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,i=e.numSegments,s=i*Math.ceil(a/n);this.outputShape=[r,s];let o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ",d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${c}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}};var Ej,Aj,$j,Rj={kernelName:ia,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:i}=t,{numSegments:s}=r,o=a.shape.length,l=[],u=0,d=em.getAxesPermutation([u],o),c=a;null!=d&&(c=xB({inputs:{x:a},backend:n,attrs:{perm:d}}),l.push(c),u=em.getInnerMostAxes(1,o)[0]);let p=em.segment_util.computeOutShape(c.shape,u,s),h=_a.sizeFromShape([c.shape[u]]),f=dB({inputs:{x:c},backend:n,attrs:{shape:[-1,h]}});l.push(f);let m=xi(a.dtype),g=(e,t,r,a,i)=>{let s=e.shape[0],o=e.shape[1],u=em.segment_util.segOpComputeOptimalWindowSize(o,i),d=new Cj({windowSize:u,inSize:o,batchSize:s,numSegments:i},t),c=n.compileAndRun(d,[e,r],a);if(l.push(c),c.shape[1]===i)return c;let p=QG({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),h=yj({inputs:{x:p},backend:n,attrs:{reps:[o/u]}});return l.push(p),l.push(h),g(c,t,h,a,i)},y=dB({inputs:{x:g(f,"unsortedSegmentSum",i,m,s)},backend:n,attrs:{shape:p}}),b=y;if(null!=d){l.push(y);let e=em.getUndoAxesPermutation(d);b=xB({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Fj=[SB,NB,_B,EB,RB,MB,OB,PB,VB,GB,jB,KB,YB,JB,eW,rW,aW,oW,lW,uW,pW,bW,vW,xW,wW,TW,EW,RW,jz,MW,VW,QW,nU,aU,iU,sU,lU,dU,pU,fU,vU,xU,wU,SU,TU,EU,AU,RU,DU,MU,PU,LU,BU,UU,GU,jU,XU,JU,nV,aV,oV,uV,pV,fV,mV,yV,xV,kV,IV,Gz,NV,BW,_V,EV,$V,Xz,FV,MV,OV,LV,BV,UV,GV,jV,XV,QV,ZV,tG,nG,rG,sG,oG,lG,uG,dG,pG,mG,yG,TG,uB,CG,AG,RG,DG,SW,OG,zG,BG,GG,jG,Jz,qG,KG,XG,YG,JG,NW,xG,eH,nH,aH,cB,oH,uH,pH,fH,yH,vH,wH,SH,TH,CH,AH,RH,DH,OH,LH,BH,yW,NG,UH,VH,GH,HH,jH,qH,KH,XH,JH,ej,rj,aj,ij,oj,lj,uj,dj,SG,vB,pj,fj,mj,bj,Sj,Nj,wB,Tj,_j,Rj,LG];for(let n of Fj)wa(n);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(Ej||(Ej={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(Aj||(Aj={}));var Dj={kernelName:ca,backendName:"wasm",setupFunc:function(e){$j=e.wasm.cwrap(ca,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i,bias:s,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:d,leakyreluAlpha:c}=r,p=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=0;if(null!=s){let e=n.dataIdMap.get(s.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=Aj[d];if(null==g)throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?i.shape[1]:i.shape[2],v=Wl.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)),x=n.makeOutput([...v,y,b],a.dtype),w=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),S=new Uint8Array(new Int32Array(i.shape).buffer);return $j(p,k,a.shape.length,h,S,i.shape.length,l,u,g,f,m,c||0,w),x}};function Mj(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){let{backend:r,inputs:{x:a}}=e,i=r.dataIdMap.get(a.dataId).id,s=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(s.dataId).id;return 0===_a.sizeFromShape(s.shape)||n(i,Ej[a.dtype],o),s}}}var Oj=Mj(Xe),Pj=Mj(Ye),Lj=Mj(Qe);function zj(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:a}=e,{a:i,b:s}=a,o=t.dataIdMap.get(i.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=null!=n?n:i.dtype,d=em.assertAndGetBroadcastShape(i.shape,s.shape),c=t.makeOutput(d,u);if(0===_a.sizeFromShape(d))return c;let p=new Uint8Array(new Int32Array(i.shape).buffer),h=new Uint8Array(new Int32Array(s.shape).buffer),f=t.dataIdMap.get(c.dataId).id;return r(o,p,i.shape.length,l,h,s.shape.length,Ej[i.dtype],f),c}}}var Bj,Wj=zj(Je);var Uj={kernelName:Ze,backendName:"wasm",setupFunc:function(e){Bj=e.wasm.cwrap(Ze,null,["array","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===_a.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),i=new Uint8Array(new Int32Array(a).buffer),s=n.dataIdMap.get(r.dataId).id;return Bj(i,a.length,Ej[r.dtype],s),r}};function Vj(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return Xi(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var Gj,Hj={kernelName:pn,backendName:"wasm",kernelFunc:Vj};function jj(e){let{inputs:t,backend:n,attrs:r}=e,[a,i]=function(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}(t.x.shape,r.perm),s=!0;for(let f=0;f<i.length;f++)i[f]!==f&&(s=!1);let o=function(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(s){let e=Vj({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),d=n.dataIdMap.get(l.dataId).id,c=n.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return Gj(d,h,l.shape.length,Ej[l.dtype],c,p,i.length),u}var qj,Kj={kernelName:na,backendName:"wasm",kernelFunc:jj,setupFunc:function(e){Gj=e.wasm.cwrap(na,null,["number","array","number","number","number","array","number"])}};function Xj(e,t,n){let r=e.shape,a=e.shape.length,i=_a.parseAxisParam(t,r),s=i,o=em.getAxesPermutation(s,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];s=em.getInnerMostAxes(s.length,a),l=jj({inputs:{x:e},attrs:{perm:o},backend:n});let i=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==i&&(u=!0)}return{transposed:l,originalAxes:i,axes:s,inputWasTransposed:u}}var Yj,Qj={kernelName:et,backendName:"wasm",setupFunc:function(e){qj=e.wasm.cwrap(et,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=s,{transposed:u,axes:d,originalAxes:c,inputWasTransposed:p}=Xj(s,a,t);if(p){l=u,o=t.dataIdMap.get(u.dataId).id}let h=l.shape.length;em.assertAxesAreInnerMostDims("all",d,h);let[f,m]=em.computeOutAndReduceShapes(l.shape,d),g=_a.sizeFromShape(m),y=t.makeOutput(f,s.dtype);if(0!==_a.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;qj(o,g,e)}if(p&&t.disposeData(u.dataId),i){let e=em.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}};var Jj={kernelName:tt,backendName:"wasm",setupFunc:function(e){Yj=e.wasm.cwrap(tt,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=s,{transposed:u,axes:d,originalAxes:c,inputWasTransposed:p}=Xj(s,a,t);if(p){l=u,o=t.dataIdMap.get(u.dataId).id}let h=l.shape.length;em.assertAxesAreInnerMostDims("any",d,h);let[f,m]=em.computeOutAndReduceShapes(l.shape,d),g=_a.sizeFromShape(m),y=t.makeOutput(f,s.dtype);if(0!==_a.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;Yj(o,g,e)}if(p&&t.disposeData(u.dataId),i){let e=em.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}};function Zj(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){let{backend:n,inputs:r,attrs:a}=e,{axis:i}=a,{x:s}=r,o=n.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:d,axes:c,inputWasTransposed:p}=Xj(s,i,n);if(p){let e=n.dataIdMap.get(d.dataId).id;e!==o&&(u=d,l=e)}let h=u.shape.slice(0,-1),f=n.makeOutput(h,"int32"),m=n.dataIdMap.get(f.dataId).id,g=_a.sizeFromShape(f.shape),y=u.shape[c[0]];return t(l,Ej[u.dtype],g,y,m),p&&n.disposeData(d.dataId),f}}}var eq,tq=Zj(nt),nq=Zj(rt),rq=Mj(at),aq=Mj(it),iq=Mj(st),sq=zj(lt),oq=Mj(ot);var lq,uq={kernelName:ut,backendName:"wasm",setupFunc:function(e){eq=e.wasm.cwrap(ut,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,i=r.dataIdMap.get(a.dataId).id,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=n,d=em.computePool2DInfo(a.shape,s,o,1,l,u),c=d.filterHeight,p=d.filterWidth,h=d.padInfo.top,f=d.padInfo.right,m=d.padInfo.bottom,g=d.padInfo.left,y=d.strideHeight,b=d.strideWidth,v=d.inChannels;if("channelsLast"!==d.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);if(1!==d.dilationWidth||1!==d.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${d.dilationHeight}, ${d.dilationWidth}].`);let x=r.makeOutput(d.outShape,"float32"),w=r.dataIdMap.get(x.dataId).id;return eq(i,a.shape[0],a.shape[1],a.shape[2],c,p,h,f,m,g,y,b,v,w),x}};var dq,cq={kernelName:ct,backendName:"wasm",setupFunc:function(e){lq=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r,d=em.computePool3DInfo(a.shape,i,s,1,o,l,u),c=n.makeOutput(d.outShape,a.dtype);return lq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}};var pq,hq={kernelName:pt,backendName:"wasm",setupFunc:function(e){dq=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r,d=em.computePool3DInfo(i.shape,s,o,1,l,u),c=n.makeOutput(i.shape,i.dtype);return dq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left,d.filterDepth,d.filterHeight,d.filterWidth),c}};var fq={kernelName:dt,backendName:"wasm",setupFunc:function(e){pq=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l}=r,u=em.computePool2DInfo(i.shape,s,o,1,l),d=n.makeOutput(i.shape,i.dtype);return pq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),d}};function mq(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,i=_a.sizeFromShape(r.shape),s=_a.inferFromImplicitShape(a,i);return _a.assert(i===_a.sizeFromShape(s),(()=>`new shape: ${s}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:s,dtype:r.dtype}}var gq,yq={kernelName:hr,backendName:"wasm",kernelFunc:mq};var bq={kernelName:ht,backendName:"wasm",setupFunc:function(e){gq=e.wasm.cwrap(ht,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i}=t,{transposeA:s,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=i.shape.length,d=s?a.shape[l-2]:a.shape[l-1],c=o?i.shape[u-1]:i.shape[u-2],p=s?a.shape[l-1]:a.shape[l-2],h=o?i.shape[u-2]:i.shape[u-1],f=a.shape.slice(0,-2),m=i.shape.slice(0,-2),g=_a.sizeFromShape(f),y=_a.sizeFromShape(m),b=Wl.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,h]);_a.assert(d===c,(()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`));let v=o?[y,h,c]:[y,c,h],x=mq({inputs:{x:a},backend:n,attrs:{shape:s?[g,d,p]:[g,p,d]}}),w=mq({inputs:{x:i},backend:n,attrs:{shape:v}}),k=n.dataIdMap.get(x.dataId).id,S=n.dataIdMap.get(w.dataId).id,I=s?x.shape[2]:x.shape[1],N=o?w.shape[1]:w.shape[2],T=Math.max(g,y),_=n.makeOutput([T,I,N],x.dtype),C=n.dataIdMap.get(_.dataId).id,E=new Uint8Array(new Int32Array(x.shape).buffer),A=new Uint8Array(new Int32Array(w.shape).buffer);return gq(k,E,x.shape.length,S,A,w.shape.length,s,o,C),n.disposeData(x.dataId),n.disposeData(w.dataId),_.shape=b,_}};function vq(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[i,s]=Cf.parseSliceParams(t,n,r),o=Cf.isSliceContinous(t.shape,i,s),l=a.readSync(t.dataId),u=a.makeOutput(s,t.dtype),d=_a.computeStrides(t.shape),c=a.dataIdMap.get(u.dataId);if(o){let e=Cf.computeFlatOffset(i,d);return"string"===t.dtype?c.stringBytes=l.slice(e,e+_a.sizeFromShape(s)):a.typedArrayFromHeap(u).set(l.subarray(e,e+_a.sizeFromShape(s))),u}if("string"===t.dtype){let e=T$(l,i,s,t.shape,t.dtype);return c.stringBytes=e,u}let p=a.typedArrayFromHeap(u),h=t.shape.length;if(2===h)!function(e,t,n,r,a){let i=0,s=r[0],o=r[1],l=s+a[0];for(let u=s;u<l;u++){let r=u*t+o;n.set(e.subarray(r,r+a[1]),i),i+=a[1]}}(l,d[0],p,i,s);else if(3===h)!function(e,t,n,r,a,i){let s=0,o=a[0],l=a[1],u=a[2],d=o+i[0],c=l+i[1];for(let p=o;p<d;p++)for(let a=l;a<c;a++){let o=p*t+a*n+u;r.set(e.subarray(o,o+i[2]),s),s+=i[2]}}(l,d[0],d[1],p,i,s);else if(4===h)!function(e,t,n,r,a,i,s){let o=0,l=i[0],u=i[1],d=i[2],c=l+s[0],p=u+s[1],h=d+s[2],f=i[3];for(let m=l;m<c;m++)for(let i=u;i<p;i++)for(let l=d;l<h;l++){let u=m*t+i*n+l*r+f;a.set(e.subarray(u,u+s[3]),o),o+=s[3]}}(l,d[0],d[1],d[2],p,i,s);else{let e=T$(l,i,s,t.shape,t.dtype);p.set(e)}return u}var xq={kernelName:_r,backendName:"wasm",kernelFunc:vq};var wq,kq={kernelName:ft,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:s}=r,o=i.reduce(((e,t)=>e*t)),l=em.getReshaped(a.shape,i,o),u=em.getPermuted(l.length,i.length),d=em.getReshapedPermuted(a.shape,i,o),c=em.getSliceBeginCoords(s,i.length),p=em.getSliceSize(d,s,i.length),h=mq({inputs:{x:a},backend:n,attrs:{shape:l}}),f=jj({inputs:{x:h},backend:n,attrs:{perm:u}}),m=mq({inputs:{x:f},backend:n,attrs:{shape:d}}),g=vq({inputs:{x:m},backend:n,attrs:{begin:c,size:p}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}};var Sq={kernelName:mt,backendName:"wasm",setupFunc:function(e){wq=e.wasm.cwrap(mt,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:i}=n,{size:s}=r,o=0!==i.shape.reduce(((e,t)=>e*t),1),l=1===a.shape.length?[s]:[a.shape[0],s],u=t.makeOutput(l,i.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return wq(d(a),s,o,d(i),Ej[i.dtype],d(u)),u}},Iq=zj(gt);var Nq={kernelName:bt,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.typedArrayFromHeap(r),s=n.typedArrayFromHeap(a),o=em.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function Tq(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),i=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(i),a}var _q,Cq={kernelName:vt,backendName:"wasm",kernelFunc:Tq},Eq=Mj(xt);var Aq={kernelName:wt,backendName:"wasm",setupFunc:function(e){_q=e.wasm.cwrap(wt,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:i,clipValueMax:s}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return _q(o,i,s,u),l}};function $q(e){let{inputs:t,backend:n}=e,r=_a.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map((e=>e.shape));em.assertParamsConsistent(a,r);let i=em.computeOutShape(t.map((e=>e.shape)),r),s=t.filter((e=>_a.sizeFromShape(e.shape)>0));if(1===s.length)return Vj({inputs:{x:s[0]},backend:n});let o=n.makeOutput(i,t[0].dtype);if(0===_a.sizeFromShape(i))return o;if("string"===s[0].dtype){let e=s.map((e=>{let t=[-1,_a.sizeFromShape(e.shape.slice(r))];return mq({inputs:{x:e},backend:n,attrs:{shape:t}})})),a=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));i=em.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=sA(a,i,t[0].dtype,l),d=em.computeOutShape(s.map((e=>e.shape)),r);return o.shape=d,n.dataIdMap.get(o.dataId).stringBytes=em.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}let l=_a.sizeFromShape(s[0].shape.slice(0,r)),u=0,d=s.map((e=>{let t=_a.sizeFromShape(e.shape.slice(r));return u+=t,t})),c=s.map((e=>n.typedArrayFromHeap(e))),p=n.typedArrayFromHeap(o);for(let h=0;h<l;h++){let e=h*u;for(let t=0;t<c.length;t++){let n=d[t],r=h*n,a=c[t].subarray(r,r+n);p.set(a,e),e+=n}}return o}var Rq,Fq={kernelName:It,backendName:"wasm",kernelFunc:$q};var Dq,Mq={kernelName:Nt,backendName:"wasm",setupFunc:function(e){Rq=e.wasm.cwrap(Nt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i}=t,s=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(i.dataId).id,{strides:l,dilations:u,pad:d,dimRoundingMode:c,dataFormat:p}=n,h=em.convertConv2DDataFormat(p),f=em.computeConv2DInfo(a.shape,i.shape,l,u,d,c,!1,h),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,S=f.strideHeight,I=f.strideWidth,N=f.inChannels,T=f.outChannels,_="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return Rq(s,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,v,x,_,w,k,S,I,N,T,E),C}};var Oq,Pq={kernelName:_t,backendName:"wasm",setupFunc:function(e){Dq=e.wasm.cwrap(_t,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:i}=n,{strides:s,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:d}=r,c=em.convertConv2DDataFormat(l),p=em.computeConv2DInfo(d,i.shape,s,1,o,u,!1,c),{batchSize:h,filterHeight:f,filterWidth:m,inChannels:g,inHeight:y,inWidth:b,outChannels:v,outHeight:x,outWidth:w,strideHeight:k,strideWidth:S}=p,I=f-1-p.padInfo.top,N=m-1-p.padInfo.left,T="channelsLast"===p.dataFormat,_=_a.computeStrides(p.inShape),C=_a.computeStrides(a.shape),[E,A,$]=_a.computeStrides(i.shape),R=_[0],F=T?_[1]:_[2],D=T?_[2]:1,M=T?1:_[1],O=C[0],P=T?C[1]:C[2],L=T?C[2]:1,z=T?1:C[1],B=t.makeOutput(p.inShape,"float32"),W=t.dataIdMap.get(B.dataId).id,U=t.dataIdMap.get(a.dataId).id,V=t.dataIdMap.get(i.dataId).id;return Dq(U,V,h,f,m,y,b,g,x,w,v,k,S,I,N,E,A,$,R,F,D,M,O,P,L,z,W),B}};var Lq,zq={kernelName:Ct,backendName:"wasm",setupFunc:function(e){Oq=e.wasm.cwrap(Ct,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=em.computeConv3DInfo(a.shape,i.shape,s,l,o),d=n.makeOutput(u.outShape,a.dtype);return Oq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}};var Bq,Wq={kernelName:Et,backendName:"wasm",setupFunc:function(e){Lq=e.wasm.cwrap(Et,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=em.computeConv3DInfo(a.shape,l,s,1,o),d=n.makeOutput(u.filterShape,i.dtype);return Lq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}};var Uq,Vq,Gq={kernelName:At,backendName:"wasm",setupFunc:function(e){Bq=e.wasm.cwrap(At,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:s,strides:o,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=em.computeConv3DInfo(l,i.shape,o,1,s),d=n.makeOutput(u.inShape,a.dtype);return Bq(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}},Hq=Mj($t),jq=Mj(Rt);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(Uq||(Uq={}));var qq,Kq={kernelName:Mt,backendName:"wasm",setupFunc:function(e){Vq=e.wasm.cwrap(Mt,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:i,extrapolationValue:s,cropSize:o}=a,{image:l,boxes:u,boxInd:d}=r,c=u.shape[0],[p,h]=o,f=[c,p,h,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=Tq({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(d.dataId).id,v=n.makeOutput(f,"float32"),x=n.dataIdMap.get(v.dataId).id,w=new Uint8Array(new Int32Array(l.shape).buffer);return Vq(g,y,b,c,w,p,h,Uq[i],s,x),null!=t&&n.disposeData(t.dataId),v}};var Xq,Yq={kernelName:Ft,backendName:"wasm",setupFunc:function(e){qq=e.wasm.cwrap(Ft,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r,l=a.shape.length;_a.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=em.getAxesPermutation([i],l),d=a;null!==u&&(d=jj({inputs:{x:a},attrs:{perm:u},backend:n}));let c=em.getInnerMostAxes(1,l)[0];em.assertAxesAreInnerMostDims("cumprod",[c],l);let p=n.makeOutput(d.shape,d.dtype),h=d.shape[c],f=n.dataIdMap.get(d.dataId).id,m=n.dataIdMap.get(p.dataId).id;qq(f,s?1:0,o?1:0,h,m,Ej[a.dtype]);let g=p;if(null!==u){g=jj({inputs:{x:p},attrs:{perm:em.getUndoAxesPermutation(u)},backend:n}),n.disposeData(d.dataId),n.disposeData(p.dataId)}return g}};var Qq,Jq={kernelName:Dt,backendName:"wasm",setupFunc:function(e){Xq=e.wasm.cwrap(Dt,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r,l=a.shape.length;_a.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=em.getAxesPermutation([i],l),d=a;null!==u&&(d=jj({inputs:{x:a},attrs:{perm:u},backend:n}));let c=em.getInnerMostAxes(1,l)[0];em.assertAxesAreInnerMostDims("cumsum",[c],l);let p=n.makeOutput(d.shape,d.dtype),h=d.shape[c],f=n.dataIdMap.get(d.dataId).id,m=n.dataIdMap.get(p.dataId).id;Xq(f,s?1:0,o?1:0,h,m,Ej[a.dtype]);let g=p;if(null!==u){g=jj({inputs:{x:p},attrs:{perm:em.getUndoAxesPermutation(u)},backend:n}),n.disposeData(d.dataId),n.disposeData(p.dataId)}return g}};var Zq,eK={kernelName:Ot,backendName:"wasm",setupFunc:function(e){Qq=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:i}=n,{size:s,binaryOutput:o}=r,l=0!==i.shape.reduce(((e,t)=>e*t),1),u=1===a.shape.length?[s]:[a.shape[0],s],d=t.makeOutput(u,i.dtype);function c(e){return t.dataIdMap.get(e.dataId).id}return Qq(c(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,s,l,c(i),Ej[i.dtype],o,c(d)),d}};var tK,nK={kernelName:Pt,backendName:"wasm",setupFunc:function(e){Zq=e.wasm.cwrap(Pt,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:i,dataFormat:s}=r,o=a.shape[0],l=("NHWC"===s?a.shape[1]:a.shape[2])*i,u=("NHWC"===s?a.shape[2]:a.shape[3])*i,d=("NHWC"===s?a.shape[3]:a.shape[1])/(i*i),c="NHWC"===s?[o,l,u,d]:[o,d,l,u],p=t.makeOutput(c,"float32"),h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(_a.computeStrides(a.shape)).buffer),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(_a.computeStrides(c)).buffer),y=t.dataIdMap.get(p.dataId).id;return Zq(h,i,"NHWC"===s?1:0,f,a.shape.length-1,m,g,c.length,y),p}};var rK,aK={kernelName:Lt,backendName:"wasm",setupFunc:function(e){tK=e.wasm.cwrap(Lt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i}=t,s=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(i.dataId).id,{strides:l,dilations:u,pad:d,dimRoundingMode:c}=n,p=null==u?[1,1]:u,h=em.computeConv2DInfo(a.shape,i.shape,l,p,d,c,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,y=h.padInfo.right,b=h.padInfo.bottom,v=h.padInfo.left,x=h.dilationHeight,w=h.dilationWidth,k=h.strideHeight,S=h.strideWidth,I=h.inChannels,N=h.outChannels,T="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(h.outShape,"float32"),C=r.dataIdMap.get(_.dataId).id;return tK(s,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,v,T,x,w,k,S,I,N,C),_}};var iK,sK={kernelName:Wt,backendName:"wasm",setupFunc:function(e){rK=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=_a.sizeFromShape(r.shape),i=n.makeOutput([...r.shape,...r.shape],r.dtype);return rK(n.dataIdMap.get(r.dataId).id,Ej[r.dtype],a,n.dataIdMap.get(i.dataId).id),i}};var oK,lK={kernelName:Ut,backendName:"wasm",setupFunc:function(e){iK=e.wasm.cwrap(Ut,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r;if(a.dtype!==i.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${i.dtype}`);let u=em.computeDilation2DInfo(a.shape,i.shape,s,o,"NHWC",l),d=n.makeOutput(u.outShape,a.dtype);return iK(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Ej[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),d}};var uK,dK={kernelName:Gt,backendName:"wasm",setupFunc:function(e){oK=e.wasm.cwrap(Gt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:s}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==i.dtype||a.dtype!==s.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${s.dtype}`);let d=em.computeDilation2DInfo(a.shape,i.shape,o,l,"NHWC",u),c=n.makeOutput(i.shape,i.dtype);return oK(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,Ej[a.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),c}};var cK,pK={kernelName:Vt,backendName:"wasm",setupFunc:function(e){uK=e.wasm.cwrap(Vt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:s}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==i.dtype||a.dtype!==s.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${s.dtype}`);let d=em.computeDilation2DInfo(a.shape,i.shape,o,l,"NHWC",u),c=n.makeOutput(a.shape,a.dtype);return uK(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,Ej[a.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),c}},hK=Mj(Kt);var fK={kernelName:Xt,backendName:"wasm",setupFunc:function(e){cK=e.wasm.cwrap(Xt,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,i=n.makeOutput(a.shape,"float32"),s=e=>n.dataIdMap.get(e.dataId).id;return cK(s(a),s(r),s(i)),i}},mK=zj(Qt,0,"bool"),gK=Mj(Yt),yK=Mj(Jt,"float32");function bK(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:i}=n,s=a.shape.length,o=a.shape.slice(),l=i;return i<0&&(_a.assert(-(s+1)<=i,(()=>`Axis must be in the interval [${-(s+1)}, ${s}]`)),l=s+i+1),o.splice(l,0,1),mq({inputs:{x:a},backend:r,attrs:{shape:o}})}var vK={kernelName:Zt,backendName:"wasm",kernelFunc:bK},xK=Mj(en,"float32");function wK(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||_a.inferDtype(n);let i=r.makeOutput(t,a);return r.typedArrayFromHeap(i).fill(n),i}var kK,SK={kernelName:nn,backendName:"wasm",kernelFunc:wK};var IK,NK={kernelName:rn,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),i=n.dataIdMap.get(r.dataId).id,s=n.dataIdMap.get(a.dataId).id,[o,l,u,d]=r.shape;return kK(i,o,l,u,d,s),a},setupFunc:function(e){kK=e.wasm.cwrap(rn,null,["number","number","number","number","number","number"])}},TK=Mj(an),_K=zj(sn);var CK,EK={kernelName:on,backendName:"wasm",setupFunc:function(e){IK=e.wasm.cwrap(on,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:i,mean:s,variance:o,offset:l,scale:u}=n,d=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(o.dataId).id,h=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(i.shape,i.dtype);if(0===_a.sizeFromShape(i.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return IK(d,c,p,h,f,a,g),m}};var AK,$K={kernelName:pa,backendName:"wasm",setupFunc:function(e){CK=e.wasm.cwrap(pa,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:d,dataFormat:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=em.computeConv2DInfo(a.shape,i.shape,l,d,u,p),g=Aj[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(i.dataId).id,v=m.outChannels,x=0;if(null!=s){let e=r.dataIdMap.get(s.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,F=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==c)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return CK(y,F,D,M,b,w,k,x,S,I,N,T,R,_,C,E,A,$,v,g,L,f||0,P),O}};var RK,FK={kernelName:ha,backendName:"wasm",setupFunc:function(e){AK=e.wasm.cwrap(ha,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:d,dataFormat:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=em.computeConv2DInfo(a.shape,i.shape,l,d,u,p,!0),g=Aj[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(i.dataId).id,v=m.outChannels,x=0;if(null!=s){let e=r.dataIdMap.get(s.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,F=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==c)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return AK(y,F,D,M,b,w,k,x,S,I,N,T,R,_,C,E,A,$,v,g,L,f||0,P),O}};var DK,MK={kernelName:un,backendName:"wasm",setupFunc:function(e){RK=e.wasm.cwrap(un,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[i,s,o,l]=Tf.prepareAndValidate(r,a),u=t.makeOutput(i,r.dtype);if(0===s)return u;let d=a.shape,c=d[d.length-1],p=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return RK(p,Ej[r.dtype],h,s,c,o,f,m),u}};var OK,PK={kernelName:ln,backendName:"wasm",setupFunc:function(e){DK=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:i}=n,{axis:s,batchDims:o}=r,l=_a.parseAxisParam(s,a.shape)[0],u=t.readSync(i.dataId),d=a.shape[l];for(let S=0;S<u.length;++S){let e=u[S];_a.assert(e<=d-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${d-1}]`))}let c=em.segment_util.collectGatherOpShapeInfo(a,i,l,o),p=mq({inputs:{x:a},attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]},backend:t}),h=_a.sizeFromShape(i.shape),f=mq({inputs:{x:i},attrs:{shape:[c.batchSize,h/c.batchSize]},backend:t}),m=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize],g=t.makeOutput(m,a.dtype);if(0===_a.sizeFromShape(a.shape))return g;let y=p.shape.length-1,b=t.dataIdMap.get(p.dataId).id,v=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(_a.computeStrides(p.shape)).buffer),k=new Uint8Array(new Int32Array(_a.computeStrides(m)).buffer);return DK(b,Ej[a.dtype],w,y,v,c.batchSize,k,x),t.disposeData(p.dataId),t.disposeData(f.dataId),g.shape=c.outputShape,g}},LK=zj(dn,0,"bool"),zK=zj(cn,0,"bool"),BK=Mj(mn,"bool"),WK=Mj(gn,"bool"),UK=Mj(yn,"bool");var VK,GK={kernelName:bn,backendName:"wasm",setupFunc:function(e){OK=e.wasm.cwrap(bn,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,i=r.makeOutput(t.shape,"float32");if(0!==_a.sizeFromShape(t.shape)){let e=r.dataIdMap.get(i.dataId).id;OK(a,Ej[t.dtype],n,e)}return i}},HK=zj(vn,0,"bool"),jK=zj(xn,0,"bool");var qK,KK={kernelName:wn,backendName:"wasm",setupFunc:function(e){VK=e.wasm.cwrap(wn,null,["number","number","number","number"])},kernelFunc:function(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:i}=t,s=Math.floor(i),o=n.makeOutput([s],"float32");return VK(n.dataIdMap.get(o.dataId).id,r,a,s),o}},XK=Mj(kn),YK=Mj(Sn),QK=zj(In,0,"bool"),JK=Mj(Nn),ZK=zj(Tn,0,"bool"),eX=zj(_n,0,"bool");var tX,nX={kernelName:An,backendName:"wasm",setupFunc:function(e){qK=e.wasm.cwrap(An,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:s,alpha:o,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return qK(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],i,s,o,l),u}};var rX,aX={kernelName:$n,backendName:"wasm",setupFunc:function(e){tX=e.wasm.cwrap($n,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:s}=t,{depthRadius:o,bias:l,alpha:u,beta:d}=r;if("float32"!==a.dtype||"float32"!==i.dtype||"float32"!==s.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let c=n.makeOutput(a.shape,a.dtype);return tX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,s.shape[3],o,l,u,d),c}};var iX,sX={kernelName:Fn,backendName:"wasm",setupFunc:function(e){rX=e.wasm.cwrap(Fn,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=s,{transposed:u,axes:d,originalAxes:c,inputWasTransposed:p}=Xj(s,a,t);if(p){l=u,o=t.dataIdMap.get(u.dataId).id}let h=l.shape.length;em.assertAxesAreInnerMostDims("max",d,h);let[f,m]=em.computeOutAndReduceShapes(l.shape,d),g=_a.sizeFromShape(m),y=t.makeOutput(f,s.dtype);if(0!==_a.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;rX(o,Ej[s.dtype],g,e)}if(p&&t.disposeData(u.dataId),i){let e=em.expandShapeToKeepDim(y.shape,c);y.shape=e}return y}},oX=zj(Dn);var lX,uX={kernelName:Mn,backendName:"wasm",setupFunc:function(e){iX=e.wasm.cwrap(Mn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,i=r.dataIdMap.get(a.dataId).id;_a.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=n,d=em.computePool2DInfo(a.shape,s,o,1,l,u),c=d.filterHeight,p=d.filterWidth,h=d.padInfo.top,f=d.padInfo.right,m=d.padInfo.bottom,g=d.padInfo.left,y=d.dilationHeight,b=d.dilationWidth,v=d.strideHeight,x=d.strideWidth,w=d.inChannels,k=d.outChannels;if("channelsLast"!==d.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(d.outShape,"float32"),I=r.dataIdMap.get(S.dataId).id;return iX(i,a.shape[0],a.shape[1],a.shape[2],c,p,h,f,m,g,y,b,v,x,w,k,I),S}};var dX,cX={kernelName:Pn,backendName:"wasm",setupFunc:function(e){lX=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r,d=em.computePool3DInfo(a.shape,i,s,1,o,l,u),c=n.makeOutput(d.outShape,a.dtype);return lX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}};var pX,hX={kernelName:Ln,backendName:"wasm",setupFunc:function(e){dX=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r,d=em.computePool3DInfo(i.shape,s,o,1,l,u),c=n.makeOutput(i.shape,i.dtype);return dX(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}};var fX,mX={kernelName:On,backendName:"wasm",setupFunc:function(e){pX=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r,d=em.computePool2DInfo(i.shape,s,o,1,l,u),c=n.makeOutput(i.shape,i.dtype);return pX(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left),c}};var gX,yX={kernelName:zn,backendName:"wasm",setupFunc:function(e){fX=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:l}=r;_a.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let u=[1,1];_a.assert(em.eitherStridesOrDilationsAreOne(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));let d=em.computePool2DInfo(a.shape,i,s,[1,1],o),c=n.makeOutput(d.outShape,a.dtype),p=n.makeOutput(d.outShape,"int32");return fX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,n.dataIdMap.get(p.dataId).id,Ej[a.dtype],l,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left),[c,p]}};var bX,vX={kernelName:Bn,backendName:"wasm",setupFunc:function(e){gX=e.wasm.cwrap(Bn,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Xj(s,a,t),f=c;if(h){let e=t.dataIdMap.get(d.dataId).id;e!==o&&(u=d,l=e,f=em.getInnerMostAxes(f.length,u.shape.length))}em.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=em.computeOutAndReduceShapes(u.shape,f),y=_a.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=Tq({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let v=t.makeOutput(m,"float32");if(0!==_a.sizeFromShape(u.shape)){let e=t.dataIdMap.get(v.dataId).id;gX(l,y,e)}if(h&&t.disposeData(d.dataId),i){let e=em.expandShapeToKeepDim(v.shape,p);v.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),v}};var xX,wX,kX={kernelName:Wn,backendName:"wasm",setupFunc:function(e){bX=e.wasm.cwrap(Wn,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Xj(s,a,t);if(h){let e=t.dataIdMap.get(d.dataId).id;e!==o&&(u=d,l=e)}let f=u.shape.length;em.assertAxesAreInnerMostDims("min",c,f);let[m,g]=em.computeOutAndReduceShapes(u.shape,c),y=_a.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==_a.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;bX(l,Ej[s.dtype],y,e)}if(h&&t.disposeData(d.dataId),i){let e=em.expandShapeToKeepDim(b.shape,p);b.shape=e}return b}},SX=zj(Un);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(xX||(xX={}));var IX,NX={kernelName:Vn,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,i=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),s=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(i,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),d=r.map((e=>e[0])),c=r.map((e=>e[1])),p=new Uint8Array(new Int32Array(d).buffer),h=new Uint8Array(new Int32Array(c).buffer);return wX(s,u,t.shape.length,Ej[t.dtype],p,h,xX[a],l),o},setupFunc:function(e){wX=e.wasm.cwrap(Vn,null,["number","array","number","number","array","array","number","number"])}};function TX(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,i=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(i.dataId).id,o=n.shape[r],l=_a.sizeFromShape(n.shape)/o;return 0===_a.sizeFromShape(i.shape)||IX(a,s,o,l),i}var _X,CX={kernelName:Pr,backendName:"wasm",setupFunc:function(e){IX=e.wasm.cwrap(Pr,null,["number","number","number","number"])},kernelFunc:TX};var EX,AX={kernelName:Hn,backendName:"wasm",setupFunc:function(e){_X=e.wasm.cwrap(Hn,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:s,normalized:o}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:TX({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,d]=l.shape,c=n.makeOutput([u,i],"int32");return _X(n.dataIdMap.get(l.dataId).id,u,d,i,s,n.dataIdMap.get(c.dataId).id),o||n.disposeData(l.dataId),c}},$X=zj(Gn),RX=zj(jn),FX=Mj(qn);function DX(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],i=n[2],s=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:i,pValidOutputs:s}}var MX,OX={kernelName:Xn,backendName:"wasm",setupFunc:function(e){EX=e.wasm.cwrap(Xn,"number",["number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:s}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(l.dataId).id,c=EX(u,d,i,a,s),{pSelectedIndices:p,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=DX(t,c);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",p)}};var PX,LX={kernelName:Yn,backendName:"wasm",setupFunc:function(e){MX=e.wasm.cwrap(Yn,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:s,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,d=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=MX(d,c,i,a,s,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=DX(t,p);return t.wasm._free(m),[t.makeOutput([f],"int32",h),t.makeOutput([],"int32",g)]}};var zX,BX={kernelName:Qn,backendName:"wasm",setupFunc:function(e){PX=e.wasm.cwrap(Qn,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:s,softNmsSigma:o}=r,{boxes:l,scores:u}=n,d=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=PX(d,c,i,a,s,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=DX(t,p);return t.wasm._free(g),[t.makeOutput([f],"int32",h),t.makeOutput([f],"float32",m)]}},WX=zj(Kn,0,"bool");var UX={kernelName:Zn,backendName:"wasm",setupFunc:function(e){zX=e.wasm.cwrap(Zn,null,["number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:s,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,s],i),d=n.dataIdMap.get(u.dataId).id,c=n.dataIdMap.get(a.dataId).id;return zX(c,s,o,l,d),u}};var VX={kernelName:Jn,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}};var GX,HX={kernelName:er,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return bK({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,s=t[0].dtype;t.forEach((e=>{_a.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),_a.assert(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=$q({inputs:t.map((e=>{let t=bK({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),l}};var jX,qX={kernelName:tr,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,i=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===_a.sizeFromShape(t.shape))return wK({backend:n,attrs:{shape:i,value:a,dtype:t.dtype}});let s=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(i,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),d=r.map((e=>e[0])),c=r.map((e=>e[1])),p=new Uint8Array(new Int32Array(d).buffer),h=new Uint8Array(new Int32Array(c).buffer);return GX(s,u,t.shape.length,Ej[t.dtype],p,h,a,l),o},setupFunc:function(e){GX=e.wasm.cwrap(tr,null,["number","array","number","number","array","array","number","number"])}},KX=zj(rr);var XX,YX={kernelName:ar,backendName:"wasm",setupFunc:function(e){jX=e.wasm.cwrap(ar,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,i=n.dataIdMap.get(r.dataId).id,s=n.dataIdMap.get(a.dataId).id,o=i,l=r,u=l;"float32"!==l.dtype&&(u=Tq({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let d=n.makeOutput(r.shape,"float32"),c=n.dataIdMap.get(d.dataId).id;return jX(o,s,c),"float32"!==l.dtype&&n.disposeData(u.dataId),d}};var QX,JX={kernelName:ir,backendName:"wasm",setupFunc:function(e){XX=e.wasm.cwrap(ir,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Xj(s,a,t),f=c;if(h){let e=t.dataIdMap.get(d.dataId).id;e!==o&&(u=d,l=e,f=em.getInnerMostAxes(f.length,u.shape.length))}em.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=em.computeOutAndReduceShapes(u.shape,f),y=_a.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==_a.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;XX(l,y,Ej[b.dtype],e)}if(h&&t.disposeData(d.dataId),i){let e=em.expandShapeToKeepDim(b.shape,p);b.shape=e}return b}},ZX={kernelName:ur,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:i,dtype:s}=n,o=b$(r,a,i,s),l=t.makeOutput([o.length],s);return t.typedArrayFromHeap(l).set(o),l}},eY=zj(jt),tY=Mj(cr),nY=Mj(pr),rY=Mj(br);var aY,iY={kernelName:gr,backendName:"wasm",setupFunc:function(e){QX=e.wasm.cwrap(gr,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:i}=r,{alignCorners:s,halfPixelCenters:o,size:l}=a,[u,d]=l,[c,p,h,f]=i.shape,m=[c,u,d,f],g=n.dataIdMap.get(i.dataId);"float32"!==g.dtype&&(t=Tq({backend:n,inputs:{x:i},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===_a.sizeFromShape(i.shape))return b;let v=n.dataIdMap.get(b.dataId).id;return QX(y,c,p,h,f,u,d,s?1:0,o?1:0,v),null!=t&&n.disposeData(t.dataId),b}};var sY,oY={kernelName:yr,backendName:"wasm",setupFunc:function(e){aY=e.wasm.cwrap(yr,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:i,dy:s}=n,{alignCorners:o}=a,l=r.makeOutput(i.shape,"float32"),u=r.dataIdMap.get(i.dataId);return"float32"!==u.dtype&&(t=Tq({backend:r,inputs:{x:i},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),aY(r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var lY,uY={kernelName:fr,backendName:"wasm",setupFunc:function(e){sY=e.wasm.cwrap(fr,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:i,halfPixelCenters:s,size:o}=r,[l,u]=o,[d,c,p,h]=a.shape,f=[d,l,u,h],m=t.makeOutput(f,"float32");if(0===_a.sizeFromShape(a.shape))return m;let g,y=t.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(g=Tq({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(g.dataId));let b=y.id,v=t.dataIdMap.get(m.dataId).id;return sY(b,d,c,p,h,l,u,i?1:0,s?1:0,v),null!=g&&t.disposeData(g.dataId),m}};var dY,cY={kernelName:mr,backendName:"wasm",setupFunc:function(e){lY=e.wasm.cwrap(mr,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:i,dy:s}=n,{alignCorners:o}=a,l=r.makeOutput(i.shape,"float32"),u=r.dataIdMap.get(i.dataId);return"float32"!==u.dtype&&(t=Tq({backend:r,inputs:{x:i},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),lY(r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var pY,hY={kernelName:vr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r,s=_a.parseAxisParam(i,a.shape);if(0===a.shape.length)return Vj({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(s).buffer),c=new Uint8Array(new Int32Array(a.shape).buffer);dY(l,d,s.length,c,a.shape.length,u);let p=mq({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),p},setupFunc:function(e){dY=e.wasm.cwrap(vr,null,["number","array","number","array","number","number"])}};var fY,mY={kernelName:da,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:i,fillValue:s,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(l.dataId).id,[c,p,h,f]=a.shape,[m,g]=em.getImageCenter(o,p,h),y="number"==typeof s?[s,s,s,0===s?0:255]:[...s,255],b=new Uint8Array(new Int32Array(y).buffer);return pY(u,c,p,h,f,i,m,g,b,y.length,d),l},setupFunc:function(e){pY=e.wasm.cwrap(da,null,["number","number","number","number","number","number","number","number","array","number","number"])}},gY=Mj(xr),yY=Mj(wr);var bY,vY={kernelName:kr,backendName:"wasm",setupFunc:function(e){fY=e.wasm.cwrap(kr,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:i}=n,{shape:s}=r,o=t.makeOutput(s,i.dtype);if(0===_a.sizeFromShape(s))return o;let{sliceRank:l,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=Hc.calculateShapes(i,a,s),h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=new Uint8Array(new Int32Array(c).buffer),g=t.dataIdMap.get(o.dataId).id;return fY(h,f,Ej[i.dtype],l,u,d,m,p,g),o}};var xY,wY={kernelName:Ir,backendName:"wasm",setupFunc:function(e){bY=e.wasm.cwrap(Ir,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:s}=r;if(a.dtype!==i.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${i.dtype}`);let o=n.makeOutput(i.shape,"int32");function l(e){return n.dataIdMap.get(e.dataId).id}return bY(l(a),l(i),a.shape[0],a.shape[1],i.shape[1],Ej[a.dtype],"left"===s,l(o)),o}};var kY,SY={kernelName:Nr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t,s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(i.dataId).id,u=n.makeOutput(a.shape,a.dtype),d=n.dataIdMap.get(u.dataId).id,c=r.shape.length,p=a.shape.length,h=0===c||c>1||1===p?1:_a.sizeFromShape(a.shape.slice(1));return xY(s,o,l,h,d),u},setupFunc:function(e){xY=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},IY=Mj(Tr);var NY={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){kY=e.wasm.cwrap($r,null,["number","number"])},kernelFunc:function(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id;return 0===_a.sizeFromShape(a.shape)||kY(r,i),a}},TY=Mj(Ar),_Y=Mj(Cr),CY=Mj(Er),EY=Mj(Rr);var AY,$Y={kernelName:Mr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:s}=r,o=_a.sizeFromShape(i),l=[[0,0]];l.push(...s);for(let g=1+i.length;g<a.shape.length;++g)l.push([0,0]);let u=qX.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=em.getReshaped(u.shape,i,o,!1),c=em.getPermuted(d.length,i.length,!1),p=em.getReshapedPermuted(u.shape,i,o,!1),h=mq({inputs:{x:u},backend:n,attrs:{shape:d}}),f=jj({inputs:{x:h},backend:n,attrs:{perm:c}}),m=mq({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),m}};var RY,FY={kernelName:Lr,backendName:"wasm",setupFunc:function(e){AY=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r}=e,{indices:a,values:i,denseShape:s,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],d=n.readSync(s.dataId)[0],c=[l+d,u],p=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(c,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(c.slice(0,1),i.dtype),b=n.dataIdMap.get(y.dataId).id,v=n.makeOutput([d],"bool"),x=n.dataIdMap.get(v.dataId).id,w=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(w.dataId).id,S=n.makeOutput([4],"int32"),I=n.dataIdMap.get(S.dataId).id,N=AY(p,h,Ej[i.dtype],l,d,u,f,g,b,x,k,I),T=n.readSync(S.dataId);switch(T[0]){case 1:t=em.getSparseFillEmptyRowsIndicesDenseShapeMismatch(T[1]);break;case 2:t=em.getSparseFillEmptyRowsNegativeIndexErrorMessage(T[1],T[2]);break;case 3:t=em.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T[1],T[2],T[3]);break;default:t=""}if(n.disposeData(S.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(v.dataId),n.disposeData(w.dataId),new Error(t);let _=m,C=y;return N!==c[0]&&(_=vq({inputs:{x:m},attrs:{begin:0,size:[N,u]},backend:n}),C=vq({inputs:{x:y},attrs:{begin:0,size:N},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[_,C,v,w]}};var DY,MY={kernelName:zr,backendName:"wasm",setupFunc:function(e){RY=e.wasm.cwrap(zr,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:i}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=r.shape[0],d=_a.sizeFromShape(i.shape),c=t.makeOutput([u,d],r.dtype),p=t.dataIdMap.get(c.dataId).id,h=t.makeOutput([d],i.dtype),f=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;RY(s,o,l,u,p,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=em.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=em.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=em.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=em.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=em.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(c.dataId),t.disposeData(h.dataId),new Error(y);return[c,h]}};function OY(e){DY=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function PY(e,t){let{backend:n,inputs:r}=e,{data:a,indices:i,segmentIds:s}=r,o=i.shape[0],l=n.readSync(s.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(em.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=a.shape.slice();d[0]=u;let c=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(i.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=n.makeOutput(d,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;DY(c,Ej[a.dtype],a.shape[0],p,h,m,y,t,0);let b,v=n.readSync(g.dataId);switch(v[0]){case 0:b=em.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=em.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=em.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:b=em.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}var LY={kernelName:Br,backendName:"wasm",setupFunc:OY,kernelFunc:function(e){return PY(e,!0)}};var zY,BY={kernelName:Wr,backendName:"wasm",setupFunc:OY,kernelFunc:function(e){return PY(e,!1)}};var WY={kernelName:Ur,backendName:"wasm",setupFunc:function(e){zY=e.wasm.cwrap(Ur,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:i,defaultValue:s}=n,{outputShape:o}=r,l=t.makeOutput(o,s.dtype);if(0===_a.sizeFromShape(o))return l;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:h}=em.calculateShapes(i,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(i.dataId).id,g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),b=t.dataIdMap.get(l.dataId).id;return zY(f,m,i.shape.length,g,Ej[s.dtype],u,d,c,y,h,b),l}};var UY,VY={kernelName:Or,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:s}=n,o=_a.parseAxisParam(s,a.shape)[0],l=em.prepareSplitSize(a,i,o),u=new Array(a.shape.length).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[o]=e;let n=vq({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}},GY=Mj(Fr),HY=Mj(Gr),jY=zj(Vr);var qY,KY={kernelName:la,backendName:"wasm",setupFunc:function(e){UY=e.wasm.cwrap(la,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:i}=n,s=t.dataIdMap.get(i.dataId).id,o=t.makeOutput(i.shape,i.dtype),l=t.dataIdMap.get(o.dataId).id;return UY(s,a,Ej[i.dtype],l),o}};var XY={kernelName:jr,backendName:"wasm",setupFunc:function(e){qY=e.wasm.cwrap(jr,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:i}=r,{begin:s,end:o,strides:l,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=Cf.sliceInfo(i.shape,s,o,l,u,d,c,p,h);if(g)t=mq({inputs:{x:i},backend:n,attrs:{shape:m}});else if(y||b){_a.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));let e=Cf.computeOutShape(v,x,w),r=vq({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});t=mq({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(i.dataId).id,a=new Uint8Array(new Int32Array(_a.computeStrides(i.shape)).buffer),s=new Uint8Array(new Int32Array(v).buffer),o=new Uint8Array(new Int32Array(x).buffer),l=new Uint8Array(new Int32Array(w).buffer),u=new Uint8Array(new Int32Array(f).buffer),d=new Uint8Array(new Int32Array(_a.computeStrides(f)).buffer),c=n.dataIdMap.get(e.dataId).id;qY(r,a,i.shape.length,s,o,l,u,d,f.length,c),t=mq({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}};var YY={kernelName:qr,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:i}=n,{separator:s,nGramWidths:o,leftPad:l,rightPad:u,padWidth:d,preserveShortSequences:c}=r,p=t.readSync(a.dataId),h=t.readSync(i.dataId),[f,m]=V$(p,h,s,o,l,u,d,c),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let y=t.makeOutput(i.shape,"int32");return t.typedArrayFromHeap(y).set(m),[g,y]}};var QY={kernelName:Kr,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:i}=n,{skipEmpty:s}=r,o=t.readSync(a.dataId),l=t.readSync(i.dataId),[u,d,c]=H$(o,l[0],s),p=d.length,h=t.makeOutput([p,2],"int32");t.typedArrayFromHeap(h).set(u);let f=t.makeOutput([p],"string");t.dataIdMap.get(f.dataId).stringBytes=d;let m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(c),[h,f,m]}};var JY,ZY={kernelName:Xr,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:i}=r,s=j$(t.readSync(a.dataId),i),o=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(o).set(s),o}},eQ=zj(Yr);var tQ,nQ={kernelName:Dr,backendName:"wasm",setupFunc:function(e){JY=e.wasm.cwrap(Dr,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Xj(s,a,t),f=c;if(h){let e=t.dataIdMap.get(d.dataId).id;e!==o&&(u=d,l=e,f=em.getInnerMostAxes(f.length,u.shape.length))}em.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=em.computeOutAndReduceShapes(u.shape,f),y=_a.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==_a.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;JY(l,y,Ej[b.dtype],e)}if(h&&t.disposeData(d.dataId),i){let e=em.expandShapeToKeepDim(b.shape,p);b.shape=e}return b}},rQ=Mj(Qr),aQ=Mj(Jr);var iQ,sQ={kernelName:Sr,backendName:"wasm",setupFunc:function(e){tQ=e.wasm.cwrap(Sr,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:i,updates:s}=n,{}=r,o=t.makeOutput(a.shape,a.dtype);if(0===_a.sizeFromShape(a.shape))return o;let{sliceRank:l,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=Hc.calculateShapes(s,i,a.shape),h=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(c).buffer),y=t.dataIdMap.get(o.dataId).id;return tQ(h,f,Ej[s.dtype],l,u,d,g,p,y,m),o}};var oQ,lQ={kernelName:Zr,backendName:"wasm",setupFunc:function(e){iQ=e.wasm.cwrap(Zr,null,["number","array","number","array","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,i=n.dataIdMap.get(a.dataId).id,{reps:s}=r,o=new Array(a.shape.length);for(let p=0;p<o.length;p++)o[p]=a.shape[p]*s[p];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),d=n.makeOutput(o,a.dtype),c=n.dataIdMap.get(d.dataId).id;return iQ(i,l,a.shape.length,u,o.length,Ej[d.dtype],c),d}};var uQ,dQ={kernelName:ea,backendName:"wasm",setupFunc:function(e){oQ=e.wasm.cwrap(ea,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:s}=r,o=n.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(a.shape).buffer),u=a.shape.slice();u[u.length-1]=i;let d=n.makeOutput(u,a.dtype),c=n.dataIdMap.get(d.dataId).id,p=n.makeOutput(u,"int32"),h=n.dataIdMap.get(p.dataId).id;return oQ(o,l,a.shape.length,Ej[a.dtype],i,s,c,h),[d,p]}};var cQ={kernelName:ta,backendName:"wasm",setupFunc:function(e){uQ=e.wasm.cwrap(ta,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:i,transforms:s}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:d}=a,[c,p,h,f]=i.shape,[m,g]=null!=d?d:[p,h],y=[c,m,g,f],b=new Uint8Array(new Int32Array(_a.computeStrides(i.shape)).buffer),v=new Uint8Array(new Int32Array(_a.computeStrides(y)).buffer),x=n.makeOutput(y,i.dtype),w=n.dataIdMap.get(x.dataId).id,k=n.dataIdMap.get(i.dataId).id,S=n.dataIdMap.get(s.dataId).id,I="nearest"===o?1:2;switch(l){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}return uQ(k,S,s.shape[0]>1,c,m,g,f,h,p,b,i.shape.length-1,v,y.length-1,I,t,u,w),x}};var pQ={kernelName:ra,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t,{outputValues:s,outputShape:o,indices:l}=tR(r.readSync(i.dataId),a,i.shape,i.dtype);return[r.makeOutput(o,i.dtype,void 0,s),r.makeOutput([l.length],"int32",void 0,l)]}};var hQ={kernelName:aa,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let s=a.shape[i],o=a.shape.length,l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==i&&(l[u++]=a.shape[h]);let d=new Array(s),c=new Array(o).fill(0),p=a.shape.slice();p[i]=1;for(let h=0;h<d.length;h++)c[i]=h,d[h]=vq({inputs:{x:a},attrs:{begin:c,size:p},backend:n});return d.map((e=>{let{dataId:t,dtype:n}=e;return{dataId:t,dtype:n,shape:l}}))}};var fQ={kernelName:oa,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}},mQ=[Dj,Oj,Pj,Lj,Wj,Uj,Qj,Jj,tq,nq,rq,aq,iq,sq,oq,uq,fq,cq,hq,bq,kq,Sq,Iq,Nq,Cq,Eq,Aq,Fq,Mq,Pq,zq,Wq,Gq,Hq,jq,Kq,Yq,Jq,eK,nK,aK,sK,lK,dK,pK,hK,fK,mK,gK,yK,vK,xK,SK,NK,TK,_K,EK,$K,FK,MK,PK,LK,zK,Hj,BK,WK,UK,GK,HK,jK,KK,YK,XK,QK,JK,ZK,eX,nX,aX,sX,oX,uX,cX,hX,mX,yX,vX,kX,SX,NX,AX,$X,RX,FX,OX,LX,BX,WX,UX,VX,HX,qX,KX,YX,JX,ZX,eY,tY,nY,rY,yq,iY,oY,uY,cY,hY,mY,gY,yY,vY,wY,SY,IY,NY,TY,_Y,CY,xq,CX,EY,$Y,FY,MY,LY,BY,WY,VY,GY,HY,jY,KY,XY,YY,QY,ZY,eQ,nQ,rQ,aQ,sQ,lQ,dQ,cQ,Kj,pQ,hQ,fQ];for(let n of mQ)wa(n);var gQ=Ge();gQ.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(pi){return!1}})),gQ.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(gQ.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(pi){return!1}}));var yQ=k(W()),bQ=k(U()),vQ=k(V()),xQ=yQ.default||yQ,wQ=vQ.default||vQ,kQ=class extends H{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(FQ),DQ=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new G(this,rs())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=_a.now();return e(),{kernelMs:_a.now()-t}}move(e,t,n,r,a){let i=this.dataIdNextNumber++;if("string"===r){let s=t;return void this.dataIdMap.set(e,{id:i,stringBytes:s,shape:n,dtype:r,memoryOffset:null,refCount:a})}let s=_a.sizeFromShape(n),o=s*_a.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:i,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(i,s,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:i,stringBytes:s}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=s.length)?s.slice(t,n):s;t=t||0,n=n||_a.sizeFromShape(i);let o=_a.bytesPerElement(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*o,r+n*o).buffer,a)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(null!=r?r:null,e,t);else{let r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=_a.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,i,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap(e){let{shape:t,dtype:n,dataId:r}=e,a=this.wasm.HEAPU8.buffer,{memoryOffset:i}=this.dataIdMap.get(r),s=_a.sizeFromShape(t);switch(n){case"float32":return new Float32Array(a,i,s);case"int32":return new Int32Array(a,i,s);case"bool":return new Uint8Array(a,i,s);default:throw new Error(`Unknown dtype ${n}`)}}};function SQ(e,t,n){if(null!=TQ)return TQ;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=CQ&&null!=CQ[r]?CQ[r]:n+r}async function IQ(){let[e,t]=await Promise.all([Ge().getAsync("WASM_HAS_SIMD_SUPPORT"),Ge().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=bQ.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?SQ(e,t,null!=_Q?_Q:r):r+n}};AQ&&(a.instantiateWasm=function(e){return(t,n)=>(_a.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}(SQ(e,t,null!=_Q?_Q:"")));let i,s=!1;a.onAbort=()=>{s||EQ||(EQ=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==TQ?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+xQ.toString()],{type:"text/javascript"}),i=xQ(a)):i=wQ(a),i.then((e=>{s=!0,EQ=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}var NQ=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],TQ=null,_Q=null,CQ={},EQ=!1,AQ=!1;function $Q(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(ts("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),EQ)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");TQ=e,AQ=t}function RQ(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(EQ)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)_Q=e;else{CQ=e;let t=NQ.filter((e=>null==CQ[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}AQ=t}var FQ=-1,DQ=-1;function MQ(e){FQ=e}function OQ(){if(-1===DQ)throw new Error("WASM backend not initialized.");return DQ}var PQ="4.21.0";gs("wasm",(async()=>{let{wasm:e}=await IQ();return new kQ(e)}),2);var LQ="4.21.0",zQ={tfjs:LQ,"tfjs-core":LQ,"tfjs-converter":"4.21.0","tfjs-backend-cpu":"4.21.0","tfjs-backend-webgl":"4.21.0","tfjs-backend-wasm":"4.21.0"};function BQ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e.beginPath(),t.slice(1).forEach(((n,r)=>{let{x:a,y:i}=n,s=t[r];e.moveTo(s.x,s.y),e.lineTo(a,i)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}h({},{AnchorPosition:()=>_J,DrawBox:()=>$J,DrawBoxOptions:()=>AJ,DrawFaceLandmarks:()=>bZ,DrawFaceLandmarksOptions:()=>yZ,DrawTextField:()=>EJ,DrawTextFieldOptions:()=>CJ,drawContour:()=>BQ,drawDetections:()=>RJ,drawFaceExpressions:()=>fZ,drawFaceLandmarks:()=>vZ});h({},{computeReshapedDimensions:()=>QQ,getCenterPoint:()=>JQ,isDimensions:()=>YQ,isEven:()=>KQ,isFloat:()=>qQ,isTensor:()=>UQ,isTensor1D:()=>VQ,isTensor2D:()=>GQ,isTensor3D:()=>HQ,isTensor4D:()=>jQ,isValidNumber:()=>eJ,isValidProbablitiy:()=>tJ,range:()=>ZQ,round:()=>XQ});var WQ=class e{constructor(e,t){if(!eJ(e)||!eJ(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new e(1/this.width,1/this.height)}};function UQ(e,t){return e instanceof li&&e.shape.length===t}function VQ(e){return UQ(e,1)}function GQ(e){return UQ(e,2)}function HQ(e){return UQ(e,3)}function jQ(e){return UQ(e,4)}function qQ(e){return e%1!==0}function KQ(e){return e%2===0}function XQ(e){let t=10**(arguments.length>1&&void 0!==arguments[1]?arguments[1]:2);return Math.floor(e*t)/t}function YQ(e){return e&&e.width&&e.height}function QQ(e,t){let{width:n,height:r}=e,a=t/Math.max(r,n);return new WQ(Math.round(n*a),Math.round(r*a))}function JQ(e){return e.reduce(((e,t)=>e.add(t)),new nJ(0,0)).div(new nJ(e.length,e.length))}function ZQ(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function eJ(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function tJ(e){return eJ(e)&&e>=0&&e<=1}var nJ=class e{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mul(t){return new e(this.x*t.x,this.y*t.y)}div(t){return new e(this.x/t.x,this.y/t.y)}abs(){return new e(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}},rJ=class e{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(eJ)}static assertIsValidBox(t,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=t||{},a=[r.left,r.top,r.right,r.bottom].every(eJ),i=[r.x,r.y,r.width,r.height].every(eJ);if(!i&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[s,o,l,u]=i?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];e.assertIsValidBox({x:s,y:o,width:l,height:u},"Box.constructor",n),this._x=s,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new nJ(this.left,this.top)}get topRight(){return new nJ(this.right,this.top)}get bottomLeft(){return new nJ(this.left,this.bottom)}get bottomRight(){return new nJ(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new e({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new e({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,i=Math.abs(r-a);return r<a&&(t-=i/2,r+=i),a<r&&(n-=i/2,a+=i),new e({x:t,y:n,width:r,height:a})}rescale(t){let n=YQ(t)?t.width:t,r=YQ(t)?t.height:t;return new e({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,i,s]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new e({x:r,y:a,width:i,height:s})}clipAtImageBorders(t,n){let{x:r,y:a,right:i,bottom:s}=this,o=Math.max(r,0),l=Math.max(a,0),u=i-o,d=s-l,c=Math.min(u,t-o),p=Math.min(d,n-l);return new e({x:o,y:l,width:c,height:p}).floor()}shift(t,n){let{width:r,height:a}=this,i=this.x+t,s=this.y+n;return new e({x:i,y:s,width:r,height:a})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=n,i=r,s=this.left,o=this.top,l=this.right,u=this.bottom;return l>t&&(a=-l+t+n,l=t),u>e&&(i=-u+e+r,u=e),s<1&&(i=2-s,s=1),o<1&&(i=2-o,o=1),{dy:1,edy:i,dx:1,edx:a,y:o,ey:u,x:s,ex:l,w:n,h:r}}calibrate(t){return new e({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},aJ=class extends rJ{constructor(e,t,n,r){super({left:e,top:t,right:n,bottom:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},iJ=class e{constructor(e,t,n,r,a){this._imageDims=new WQ(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new rJ(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new rJ(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new e(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},sJ=class e extends iJ{constructor(e,t,n){super(e,e,"",t,n)}forSize(t,n){let{score:r,relativeBox:a,imageDims:i}=super.forSize(t,n);return new e(r,a,i)}};function oJ(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left))*Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top));return n?r/(e.area+t.area-r):r/Math.min(e.area,t.area)}function lJ(e,t){return ss((()=>{let[n,r,a]=t,i=vl([...e.shape.slice(0,3),1],n,"float32"),s=vl([...e.shape.slice(0,3),1],r,"float32"),o=vl([...e.shape.slice(0,3),1],a,"float32"),l=nl([i,s,o],3);return Ku(e,l)}))}function uJ(e){return 1/(1+Math.exp(-e))}var dJ,cJ=class extends rJ{constructor(e,t,n,r){super({x:e,y:t,width:n,height:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},pJ=class{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new nJ(0,0),{width:r,height:a}=t;this._imgDims=new WQ(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new nJ(r,a)).add(n)))}get shift(){return new nJ(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new nJ(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new nJ(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e){let n=e instanceof sJ?e.box.floor():new rJ(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),i=(a(t)+a(n))/2,s=Math.floor(i/.45),o=JQ(e),l=Math.floor(Math.max(0,o.x-.5*s)),u=Math.floor(Math.max(0,o.y-.43*s));return new cJ(l,u,Math.min(s,this.imageWidth+l),Math.min(s,this.imageHeight+u))}alignMinBbox(e){let t=function(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),i=t.reduce(((e,t)=>e<t?t:e),0),s=n.reduce(((e,t)=>e<t?t:e),0);return new aJ(r,a,i,s)}(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},hJ=class extends pJ{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(JQ)}};function fJ(e){return e.detection instanceof sJ}function mJ(e,t){return{...e,detection:t}}function gJ(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function yJ(){return"object"==typeof n.g&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function bJ(e){let t="";if(!e&&yJ())try{e=p("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function vJ(){let e=n.g.Canvas||n.g.HTMLCanvasElement,t=n.g.Image||n.g.HTMLImageElement,r=n.g.Video||n.g.HTMLVideoElement,a=n.g.fetch,i=bJ();return{Canvas:e||class{},CanvasRenderingContext2D:n.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:n.g.ImageData||class{},Video:n.g.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(r)return new r;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:a,...i}}function xJ(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function wJ(e){dJ=e}function kJ(){return xJ()?wJ(gJ()):yJ()?wJ(vJ()):null}var SJ={getEnv:function(){if(!dJ)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return dJ},setEnv:wJ,initialize:kJ,createBrowserEnv:gJ,createFileSystem:bJ,createNodejsEnv:vJ,monkeyPatch:function(e){if(dJ||kJ(),!dJ)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=dJ.Canvas,Image:n=dJ.Image}=e;dJ.Canvas=t,dJ.Image=n,dJ.createCanvasElement=e.createCanvasElement||(()=>new t),dJ.createImageElement=e.createImageElement||(()=>new n),dJ.ImageData=e.ImageData||dJ.ImageData,dJ.Video=e.Video||dJ.Video,dJ.fetch=e.fetch||dJ.fetch,dJ.readFile=e.readFile||dJ.readFile},isBrowser:xJ,isNodejs:yJ};function IJ(e){return SJ.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function NJ(e){let{Canvas:t,CanvasRenderingContext2D:n}=SJ.getEnv();if(e instanceof n)return e;let r=IJ(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}kJ();var TJ,_J=((TJ=_J||{}).TOP_LEFT="TOP_LEFT",TJ.TOP_RIGHT="TOP_RIGHT",TJ.BOTTOM_LEFT="BOTTOM_LEFT",TJ.BOTTOM_RIGHT="BOTTOM_RIGHT",TJ),CJ=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:i,padding:s}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=i||"Georgia",this.padding=s||4}},EJ=class e{constructor(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.text="string"==typeof t?[t]:t instanceof e?t.text:t,this.anchor=n,this.options=new CJ(r)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,i=this.measureWidth(e),s=this.measureHeight(),o=r?this.anchor.x-i:this.anchor.x,l=a?this.anchor.y-s:this.anchor.y;if(t){let{width:e,height:n}=t;return{x:Math.max(Math.min(o,e-i),0),y:Math.max(Math.min(l,n-s),0)}}return{x:o,y:l}}draw(e){let t=IJ(e),n=NJ(t),{backgroundColor:r,fontColor:a,fontSize:i,fontStyle:s,padding:o}=this.options;n.font=`${i}px ${s}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let d=this.getUpperLeft(n,t);n.fillRect(d.x,d.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+d.x,a=o+d.y+(t+1)*i;n.fillText(e,r,a)}))}},AJ=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let i={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new CJ({...i,...a})}},$J=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.box=new rJ(e),this.options=new AJ(t)}draw(e){let t=NJ(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:i,width:s,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,i,s,o);let{label:l}=this.options;l&&new EJ([l],{x:a-r/2,y:i},this.options.drawLabelOptions).draw(e)}};function RJ(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof sJ?t.score:fJ(t)?t.detection.score:void 0,r=t instanceof sJ?t.box:fJ(t)?t.detection.box:new rJ(t),a=n?`${XQ(n)}`:void 0;new $J(r,{label:a}).draw(e)}))}function FJ(e){let{Image:t,Video:n}=SJ.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function DJ(e){let{Image:t,Video:n}=SJ.getEnv();return e instanceof t?new WQ(e.naturalWidth,e.naturalHeight):e instanceof n?new WQ(e.videoWidth,e.videoHeight):new WQ(e.width,e.height)}function MJ(e){let{width:t,height:n}=e,{createCanvasElement:r}=SJ.getEnv(),a=r();return a.width=t,a.height=n,a}function OJ(e,t){let{ImageData:n}=SJ.getEnv();if(!(e instanceof n)&&!FJ(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||DJ(e),i=MJ({width:r,height:a});return e instanceof n?NJ(i).putImageData(e,0,0):NJ(i).drawImage(e,0,0,r,a),i}function PJ(e){let{Image:t,Canvas:n,Video:r}=SJ.getEnv();return e instanceof t||e instanceof n||e instanceof r}var LJ=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(HQ(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(jQ(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof SJ.getEnv().Canvas?e:OJ(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return ZQ(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return QQ({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return this._inputSize=e,ss((()=>{let n=ZQ(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof li){let n=jQ(r)?r:vu(r);return n=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return ss((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),i=Math.round(a*(t?.5:1)),s=n>r?2:1,o=t=>{let n=e.shape.slice();return n[s]=t,vl(n,0,"float32")},l=o(i),u=a-l.shape[s],d=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>bo(e,"float32")));return nl(d,s)}))}(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=Nh.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof SJ.getEnv().Canvas)return gf.fromPixels(function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{Image:r,Canvas:a}=SJ.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return MJ({width:1,height:1});let i=DJ(e),s=t/Math.max(i.height,i.width),o=s*i.width,l=s*i.height,u=MJ({width:t,height:t}),d=e instanceof a?e:OJ(e),c=Math.abs(o-l)/2,p=n&&o<l?c:0,h=n&&l<o?c:0;return d.width>0&&d.height>0&&NJ(u).drawImage(d,p,h,o,l),u}(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return Mc(n.map((e=>bo(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function zJ(e){if(e instanceof LJ)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(IJ);return r.forEach(((e,r)=>{if(!PJ(e)&&!HQ(e)&&!jQ(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(jQ(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>PJ(e)&&function(e){return new Promise(((t,n)=>{function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}e instanceof SJ.getEnv().Canvas||FJ(e)?t(null):(e.addEventListener("load",a),e.addEventListener("error",r))}))}(e)))),new LJ(r,Array.isArray(e))}async function BJ(e,t){let{Canvas:n}=SJ.getEnv(),r=e;if(!(e instanceof n)){let t=await zJ(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await async function(e,t){let n=t||SJ.getEnv().createCanvasElement(),[r,a,i]=e.shape.slice(jQ(e)?1:0),s=ss((()=>e.as3D(r,a,i).toInt()));return await gf.toPixels(s,n),s.dispose(),n}(a)}let a=NJ(r);return t.map((e=>e instanceof sJ?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((e=>{let{x:t,y:n,width:r,height:i}=e,s=MJ({width:r,height:i});return r>0&&i>0&&NJ(s).putImageData(a.getImageData(t,n,r,i),0,0),s}))}async function WJ(e,t){if(!HQ(e)&&!jQ(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(jQ(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ss((()=>{let[n,r,a]=e.shape.slice(jQ(e)?1:0);return t.map((e=>e instanceof sJ?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((t=>{let{x:i,y:s,width:o,height:l}=t;return Nc(e.as3D(n,r,a),[s,i,0],[l,o,a])}))}))}async function UJ(e,t){let{fetch:n}=SJ.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}function VJ(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",a=(e=e.replace(r,"")).split("/").filter((e=>e)),i=e.endsWith(".json")?a[a.length-1]:n,s=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return s=e.startsWith("/")?`/${s}`:s,{modelBaseUri:s,manifestUri:"/"===s?`/${i}`:`${s}/${i}`}}async function GJ(e,t){let{manifestUri:n,modelBaseUri:r}=VJ(e,t),a=await async function(e){return(await UJ(e)).json()}(n);return jh.loadWeights(a,r)}var HJ=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((e=>{let{paramPath:t}=e;return{path:t,tensor:this.getParamFromPath(t)}}))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof di))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof di)))}variable(){this.getFrozenParams().forEach((e=>{let{path:t,tensor:n}=e;this.reassignParamFromPath(t,n.variable())}))}freeze(){this.getTrainableParams().forEach((e=>{let{path:t,tensor:n}=e,r=Xi(n.dataSync());n.dispose(),this.reassignParamFromPath(t,r)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((e=>{let{tensor:t}=e;return Array.from(t.dataSync())})).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await GJ(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=SJ.getEnv(),{manifestUri:n,modelBaseUri:r}=VJ(e,this.getDefaultModelName()),a=jh.weightsLoaderFactory((e=>Promise.all(e.map((e=>t(e).then((e=>"string"==typeof e?Buffer.from(e):e.buffer))))))),i=JSON.parse((await t(n)).toString()),s=await a(i,r);this.loadFromWeightMap(s)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof li))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function jJ(e,t,n){return ss((()=>{let r=bc(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=wo(r,t.bias),r}))}function qJ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return ss((()=>{let r=lc(n?wo(Nl(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):jJ(e,t.conv0,[2,2])),a=jJ(r,t.conv1,[1,1]),i=jJ(lc(wo(r,a)),t.conv2,[1,1]);return lc(wo(r,wo(a,i)))}))}function KJ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return ss((()=>{let a=lc(n?wo(Nl(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):jJ(e,t.conv0,r?[2,2]:[1,1])),i=jJ(a,t.conv1,[1,1]),s=jJ(lc(wo(a,i)),t.conv2,[1,1]),o=jJ(lc(wo(a,wo(i,s))),t.conv3,[1,1]);return lc(wo(a,wo(i,wo(s,o))))}))}function XJ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"same",r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return ss((()=>{let a=wo(Nl(e,t.filters,[1,1],n),t.bias);return r?lc(a):a}))}function YJ(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function QJ(e,t){return(n,r,a,i)=>{let s=Uc(e(n*r*a*a),[a,a,n,r]),o=zc(e(r));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:s,bias:o}}}function JJ(e,t){return(n,r,a)=>{let i=Bc(e(n*r),[n,r]),s=zc(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:i,bias:s}}}var ZJ=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function eZ(e,t){return(n,r,a)=>{let i=Uc(e(9*n),[3,3,n,1]),s=Uc(e(n*r),[1,1,n,r]),o=zc(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new ZJ(i,s,o)}}function tZ(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new ZJ(n,r,a)}}function nZ(e,t){return(n,r,a)=>{let i=e[n];if(!UQ(i,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${i}`);return t.push({originalPath:n,paramPath:a||n}),i}}function rZ(e){let t=e;return{extractWeights:function(e){let n=t.slice(0,e);return t=t.slice(e),n},getRemainingWeights:function(){return t}}}function aZ(e,t){let n=QJ(e,t),r=eZ(e,t);function a(e,t,a){return{conv0:arguments.length>3&&void 0!==arguments[3]&&arguments[3]?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),conv1:r(t,t,`${a}/conv1`),conv2:r(t,t,`${a}/conv2`)}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:function(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],{conv0:s,conv1:o,conv2:l}=a(e,t,n,i);return{conv0:s,conv1:o,conv2:l,conv3:r(t,t,`${n}/conv3`)}}}}function iZ(e){return t=>({filters:e(`${t}/filters`,4),bias:e(`${t}/bias`,1)})}function sZ(e,t){let n=nZ(e,t),r=iZ(n),a=tZ(n);return{extractDenseBlock3Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}},extractDenseBlock4Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`),conv3:a(`${e}/conv3`)}}}}var oZ=class extends HJ{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ss((()=>{let n=KJ(lJ(bo(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=KJ(n,t.dense1),n=KJ(n,t.dense2),n=KJ(n,t.dense3),n=el(n,[7,7],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await zJ(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock4Params:n}=sZ(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return YJ(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=rZ(e),{extractDenseBlock4Params:a}=aZ(n,t),i=a(3,32,"dense0",!0),s=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:i,dense1:s,dense2:o,dense3:l}}}(e)}};function lZ(e,t){return ss((()=>wo(rl(e,t.weights),t.bias)))}function uZ(e){let t={},n={};return Object.keys(e).forEach((r=>{(r.startsWith("fc")?n:t)[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var dZ=class extends HJ{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ss((()=>{let n=e instanceof LJ?this.faceFeatureExtractor.forwardInput(e):e;return lZ(n.as2D(n.shape[0],-1),t.fc)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:i}=rZ(e),s=JJ(a,r)(t,n,"fc");if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{paramMappings:r,params:{fc:s}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=uZ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=nZ(e,t),r={fc:(a="fc",{weights:n(`${a}/weights`,2),bias:n(`${a}/bias`,1)})};var a;return YJ(e,t),{params:r,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),i=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(i)}},cZ=["neutral","happy","sad","angry","fearful","disgusted","surprised"],pZ=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);cZ.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return cZ.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}};function hZ(e,t){return{...e,expressions:t}}function fZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,r=arguments.length>3?arguments[3]:void 0;(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof pZ?t:function(e){return e.expressions instanceof pZ}(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=a.asSortedArray().filter((e=>e.probability>n)),s=fJ(t)?t.detection.box.bottomLeft:r||new nJ(0,0);new EJ(i.map((e=>`${e.expression} (${XQ(e.probability)})`)),s).draw(e)}))}function mZ(e){return fJ(e)&&e.landmarks instanceof pJ&&e.unshiftedLandmarks instanceof pJ&&e.alignedRect instanceof sJ}function gZ(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:i}=e.detection,s=new sJ(e.detection.score,a.rescale(i.reverse()),i),o=function(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e.x-t.x)**2+(e.y-t.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e.positions||68!==e.positions.length)return r;let a=e.positions;return r.roll=((e,n)=>{let r=Math.hypot(n.x-e.x,n.y-e.y),a=n.y-e.y,i=Math.asin(a/r),s=t(i);return Math.floor(90-s)*(n.x-e.x<0?-1:1)})(a[27],a[66]),r.pitch=((e,r,a)=>{let i=n(e,a),s=new nJ((e.x+a.x)/2,(e.y+a.y)/2),o=n(r,s),l=Math.atan(o/i);return Math.floor(t(l))*(s.y-r.y<0?-1:1)})(a[14],a[30],a[2]),r.yaw=(i=a[14],s=a[33],o=a[2],Math.floor(i.x-s.x)-Math.floor(s.x-o.x)),r;var i,s,o}(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:s,angle:o}}var yZ=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:i,pointColor:s}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=i||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=s||"rgba(255, 0, 255, 1)"}},bZ=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.faceLandmarks=e,this.options=new yZ(t)}draw(e){let t=NJ(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:i,pointSize:s,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof hJ&&(t.strokeStyle=i,t.lineWidth=a,BQ(t,this.faceLandmarks.getJawOutline()),BQ(t,this.faceLandmarks.getLeftEyeBrow()),BQ(t,this.faceLandmarks.getRightEyeBrow()),BQ(t,this.faceLandmarks.getNose()),BQ(t,this.faceLandmarks.getLeftEye(),!0),BQ(t,this.faceLandmarks.getRightEye(),!0),BQ(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,s,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function vZ(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof pJ?t:mZ(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new bZ(n).draw(e)}))}function xZ(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=rZ(e),{extractConvParams:i,extractSeparableConvParams:s,extractReductionBlockParams:o,extractMainBlockParams:l}=function(e,t){let n=QJ(e,t),r=eZ(e,t);return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:function(e,t,a){return{separable_conv0:r(e,t,`${a}/separable_conv0`),separable_conv1:r(t,t,`${a}/separable_conv1`),expansion_conv:n(e,t,1,`${a}/expansion_conv`)}},extractMainBlockParams:function(e,t){return{separable_conv0:r(e,e,`${t}/separable_conv0`),separable_conv1:r(e,e,`${t}/separable_conv1`),separable_conv2:r(e,e,`${t}/separable_conv2`)}}}}(r,n),u={conv_in:i(3,32,3,"entry_flow/conv_in"),reduction_block_0:o(32,64,"entry_flow/reduction_block_0"),reduction_block_1:o(64,128,"entry_flow/reduction_block_1")},d={};ZQ(t,0,1).forEach((e=>{d[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let c={reduction_block:o(128,256,"exit_flow/reduction_block"),separable_conv:s(256,512,"exit_flow/separable_conv")};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:u,middle_flow:d,exit_flow:c}}}function wZ(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:i,extractMainBlockParams:s}=function(e,t){let n=nZ(e,t),r=iZ(n),a=tZ(n);return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),expansion_conv:r(`${e}/expansion_conv`)}},extractMainBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),separable_conv2:a(`${e}/separable_conv2`)}}}}(e,n),o={conv_in:r("entry_flow/conv_in"),reduction_block_0:i("entry_flow/reduction_block_0"),reduction_block_1:i("entry_flow/reduction_block_1")},l={};ZQ(t,0,1).forEach((e=>{l[`main_block_${e}`]=s(`middle_flow/main_block_${e}`)}));let u={reduction_block:i("exit_flow/reduction_block"),separable_conv:a("exit_flow/separable_conv")};return YJ(e,n),{params:{entry_flow:o,middle_flow:l,exit_flow:u},paramMappings:n}}function kZ(e,t,n){return wo(Nl(e,t.filters,n,"same"),t.bias)}function SZ(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?lc(e):e;return n=jJ(n,t.separable_conv0,[1,1]),n=jJ(lc(n),t.separable_conv1,[1,1]),n=ad(n,[3,3],[2,2],"same"),n=wo(n,kZ(e,t.expansion_conv,[2,2])),n}var IZ=class extends HJ{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ss((()=>{let n=lJ(bo(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),r=lc(kZ(n,t.entry_flow.conv_in,[2,2]));return r=SZ(r,t.entry_flow.reduction_block_0,!1),r=SZ(r,t.entry_flow.reduction_block_1),ZQ(this._numMainBlocks,0,1).forEach((e=>{r=function(e,t){let n=jJ(lc(e),t.separable_conv0,[1,1]);return n=jJ(lc(n),t.separable_conv1,[1,1]),n=jJ(lc(n),t.separable_conv2,[1,1]),n=wo(n,e),n}(r,t.middle_flow[`main_block_${e}`])})),r=SZ(r,t.exit_flow.reduction_block),r=lc(jJ(r,t.exit_flow.separable_conv,[1,1])),r}))}async forward(e){return this.forwardInput(await zJ(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return wZ(e,this._numMainBlocks)}extractParams(e){return xZ(e,this._numMainBlocks)}};var NZ,TZ=((NZ=TZ||{}).FEMALE="female",NZ.MALE="male",NZ),_Z=class extends dZ{postProcess(e,t,n){let r=n.map((e=>{let{width:n,height:r}=e,a=t/Math.max(r,n);return{width:n*a,height:r*a}})),a=r.length;return ss((()=>{let n=(e,t)=>Mc([vl([68],e,"float32"),vl([68],t,"float32")],1).as2D(1,136).as1D(),i=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0};return e.mul(vl([a,136],t,"float32")).sub(Mc(Array.from(Array(a),((e,t)=>n((e=>i(e,((e,t)=>e<t)))(t),(e=>i(e,((e,t)=>t<e)))(t)))))).div(Mc(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return ss((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((e=>{let[t,n]=e;return{height:t,width:n}})))}))}async forward(e){return this.forwardInput(await zJ(e))}async detectLandmarks(e){let t=await zJ(e),n=ss((()=>ep(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>KQ(t))),i=r.filter(((e,t)=>!KQ(t)));return new hJ(Array(68).fill(0).map(((e,t)=>new nJ(a[t],i[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},CZ=class extends _Z{constructor(){super("FaceLandmark68Net",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new oZ)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};var EZ=class extends HJ{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ss((()=>{let n=qJ(lJ(bo(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=qJ(n,t.dense1),n=qJ(n,t.dense2),n=el(n,[14,14],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await zJ(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock3Params:n}=sZ(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return YJ(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=rZ(e),{extractDenseBlock3Params:a}=aZ(n,t),i=a(3,32,"dense0",!0),s=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:i,dense1:s,dense2:o}}}(e)}};function AZ(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"same",{filters:i,bias:s}=t.conv,o=Nl(e,i,n,a);return o=wo(o,s),o=function(e,t){return wo(Io(e,t.weights),t.biases)}(o,t.scale),r?lc(o):o}function $Z(e,t){return AZ(e,t,[1,1],!1)}function RZ(e,t){return AZ(e,t,[2,2],!0,"valid")}function FZ(e,t){function n(n,r,a,i){let s=function(t,n,r){let a=e(t),i=a.length/(n*r*r);if(qQ(i))throw new Error(`depth has to be an integer: ${i}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return ss((()=>sp(Uc(a,[n,i,r,r]),[2,3,1,0])))}(n,r,a),o=zc(e(r));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:s,bias:o}}function r(r,a,i,s){let o=n(r,a,i,`${s}/conv`),l=function(n,r){let a=zc(e(n)),i=zc(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:i}}(a,`${s}/scale`);return{conv:o,scale:l}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e,t,n,a){return{conv1:r((arguments.length>4&&void 0!==arguments[4]&&arguments[4]?.5:1)*e,t,n,`${a}/conv1`),conv2:r(e,t,n,`${a}/conv2`)}}}}function DZ(e,t){let n=nZ(e,t);function r(e){let t=n(`${e}/conv/filters`,4),r=n(`${e}/conv/bias`,1),a=function(e){return{weights:n(`${e}/scale/weights`,1),biases:n(`${e}/scale/biases`,1)}}(e);return{conv:{filters:t,bias:r},scale:a}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e){return{conv1:r(`${e}/conv1`),conv2:r(`${e}/conv2`)}}}}function MZ(e,t){let n=function(e,t){return AZ(e,t,[1,1],!0)}(e,t.conv1);return n=$Z(n,t.conv2),n=wo(n,e),n=lc(n),n}function OZ(e,t){let n=RZ(e,t.conv1);n=$Z(n,t.conv2);let r=el(e,2,2,"valid"),a=ud(r.shape),i=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=ud(e);n=nl([n,t],1);let r=[...n.shape];r[2]=1;let a=ud(r);n=nl([n,a],2)}return r=i?nl([r,a],3):r,n=wo(r,n),n=lc(n),n}var PZ=class extends HJ{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ss((()=>{let n=RZ(lJ(bo(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);n=ad(n,3,2,"valid"),n=MZ(n,t.conv32_1),n=MZ(n,t.conv32_2),n=MZ(n,t.conv32_3),n=OZ(n,t.conv64_down),n=MZ(n,t.conv64_1),n=MZ(n,t.conv64_2),n=MZ(n,t.conv64_3),n=OZ(n,t.conv128_down),n=MZ(n,t.conv128_1),n=MZ(n,t.conv128_2),n=OZ(n,t.conv256_down),n=MZ(n,t.conv256_1),n=MZ(n,t.conv256_2),n=OZ(n,t.conv256_down_out);let r=n.mean([1,2]);return rl(r,t.fc)}))}async forward(e){return this.forwardInput(await zJ(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await zJ(e),r=ss((()=>ep(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=DZ(e,t),a=n("conv32_down"),i=r("conv32_1"),s=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),d=r("conv64_2"),c=r("conv64_3"),p=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!GQ(v))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${v}`);let x={conv32_down:a,conv32_1:i,conv32_2:s,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:d,conv64_3:c,conv128_down:p,conv128_1:h,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:v};return YJ(e,t),{params:x,paramMappings:t}}(e)}extractParams(e){return function(e){let{extractWeights:t,getRemainingWeights:n}=rZ(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:i}=FZ(t,r),s=a(4704,32,7,"conv32_down"),o=i(9216,32,3,"conv32_1"),l=i(9216,32,3,"conv32_2"),u=i(9216,32,3,"conv32_3"),d=i(36864,64,3,"conv64_down",!0),c=i(36864,64,3,"conv64_1"),p=i(36864,64,3,"conv64_2"),h=i(36864,64,3,"conv64_3"),f=i(147456,128,3,"conv128_down",!0),m=i(147456,128,3,"conv128_1"),g=i(147456,128,3,"conv128_2"),y=i(589824,256,3,"conv256_down",!0),b=i(589824,256,3,"conv256_1"),v=i(589824,256,3,"conv256_2"),x=i(589824,256,3,"conv256_down_out"),w=ss((()=>sp(Bc(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:s,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:d,conv64_1:c,conv64_2:p,conv64_3:h,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:v,conv256_down_out:x,fc:w},paramMappings:r}}(e)}};function LZ(e,t){return{...e,descriptor:t}}function zZ(e,t){return{...e,age:t}}function BZ(e,t,n){return{...e,gender:t,genderProbability:n}}function WZ(e,t){function n(n,r,a,i,s){let o=Uc(e(n*r*a*a),[a,a,n,r]),l=zc(e(r));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/${s?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function r(e,t,r,a){let{filters:i,bias:s}=n(e,t,r,a,!0);return{filters:i,batch_norm_offset:s}}function a(n,a,i){let s=function(n,r){let a=Uc(e(9*n),[3,3,n,1]),i=zc(e(n)),s=zc(e(n)),o=zc(e(n)),l=zc(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:i,batch_norm_offset:s,batch_norm_mean:o,batch_norm_variance:l}}(n,`${i}/depthwise_conv`);return{depthwise_conv:s,pointwise_conv:r(n,a,1,`${i}/pointwise_conv`)}}return{extractMobilenetV1Params:function(){return{conv_0:r(3,32,3,"mobilenetv1/conv_0"),conv_1:a(32,64,"mobilenetv1/conv_1"),conv_2:a(64,128,"mobilenetv1/conv_2"),conv_3:a(128,128,"mobilenetv1/conv_3"),conv_4:a(128,256,"mobilenetv1/conv_4"),conv_5:a(256,256,"mobilenetv1/conv_5"),conv_6:a(256,512,"mobilenetv1/conv_6"),conv_7:a(512,512,"mobilenetv1/conv_7"),conv_8:a(512,512,"mobilenetv1/conv_8"),conv_9:a(512,512,"mobilenetv1/conv_9"),conv_10:a(512,512,"mobilenetv1/conv_10"),conv_11:a(512,512,"mobilenetv1/conv_11"),conv_12:a(512,1024,"mobilenetv1/conv_12"),conv_13:a(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function(){return{conv_0:r(1024,256,1,"prediction_layer/conv_0"),conv_1:r(256,512,3,"prediction_layer/conv_1"),conv_2:r(512,128,1,"prediction_layer/conv_2"),conv_3:r(128,256,3,"prediction_layer/conv_3"),conv_4:r(256,128,1,"prediction_layer/conv_4"),conv_5:r(128,256,3,"prediction_layer/conv_5"),conv_6:r(256,64,1,"prediction_layer/conv_6"),conv_7:r(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:n(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:n(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:n(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}function UZ(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=function(e,t){let n=nZ(e,t);function r(e,t,r){return{filters:n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),batch_norm_offset:n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`)}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,i=`${t}/depthwise_conv`,s=`${t}/pointwise_conv`;return{depthwise_conv:{filters:n(`${a}/depthwise_weights`,4,`${i}/filters`),batch_norm_scale:n(`${a}/BatchNorm/gamma`,1,`${i}/batch_norm_scale`),batch_norm_offset:n(`${a}/BatchNorm/beta`,1,`${i}/batch_norm_offset`),batch_norm_mean:n(`${a}/BatchNorm/moving_mean`,1,`${i}/batch_norm_mean`),batch_norm_variance:n(`${a}/BatchNorm/moving_variance`,1,`${i}/batch_norm_variance`)},pointwise_conv:r("MobilenetV1",e,s)}}function i(e,t){return{filters:n(`${e}/weights`,4,`${t}/filters`),bias:n(`${e}/biases`,1,`${t}/bias`)}}function s(e){return{box_encoding_predictor:i(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),class_predictor:i(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`)}}return{extractMobilenetV1Params:function(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}},extractPredictionLayerParams:function(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:s(0),box_predictor_1:s(1),box_predictor_2:s(2),box_predictor_3:s(3),box_predictor_4:s(4),box_predictor_5:s(5)}}}}(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!HQ(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let i={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return YJ(e,t),{params:i,paramMappings:t}}function VZ(e,t,n){return ss((()=>{let r=Nl(e,t.filters,n,"same");return r=wo(r,t.batch_norm_offset),xl(r,0,6)}))}function GZ(e,t){return ss((()=>{let n,r=VZ(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,i=function(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}(a);r=function(e,t,n){return ss((()=>{let r=Ll(e,t.filters,n,"same");return r=dl(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,.0010000000474974513),xl(r,0,6)}))}(r,e.depthwise_conv,i),r=VZ(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function HZ(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),i=Math.min(r[t][1],r[t][3]),s=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),d=Math.max(r[n][0],r[n][2]),c=Math.max(r[n][1],r[n][3]),p=(s-a)*(o-i),h=(d-l)*(c-u);if(p<=0||h<=0)return 0;let f=Math.max(a,l),m=Math.max(i,u),g=Math.min(s,d),y=Math.min(o,c),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(p+h-b)}function jZ(e,t){let{sizes:n,centers:r}=function(e){let t=ep(sp(e,[1,0])),n=[Ku(t[2],t[0]),Ku(t[3],t[1])];return{sizes:n,centers:[wo(t[0],So(n[0],2)),wo(t[1],So(n[1],2))]}}(e),a=ep(sp(t,[1,0])),i=So(Io(bu(So(a[2],5)),n[0]),2),s=wo(Io(So(a[0],10),n[0]),r[0]),o=So(Io(bu(So(a[3],5)),n[1]),2),l=wo(Io(So(a[1],10),n[1]),r[1]);return sp(Mc([Ku(s,i),Ku(l,o),wo(s,i),wo(l,o)]),[1,0])}function qZ(e,t){return ss((()=>{let n=e.shape[0];return{boxPredictionEncoding:Zo(XJ(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:Zo(XJ(e,t.class_predictor),[n,-1,3])}}))}var KZ=class{constructor(){let{minConfidence:e,maxResults:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},XZ=class extends HJ{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ss((()=>{let n=bo(e.toBatchTensor(512,!1),"float32"),r=GZ(Ku(So(n,127.5),1),t.mobilenetv1),{boxPredictions:a,classPredictions:i}=function(e,t,n){return ss((()=>{let r=VZ(e,n.conv_0,[1,1]),a=VZ(r,n.conv_1,[2,2]),i=VZ(a,n.conv_2,[1,1]),s=VZ(i,n.conv_3,[2,2]),o=VZ(s,n.conv_4,[1,1]),l=VZ(o,n.conv_5,[2,2]),u=VZ(l,n.conv_6,[1,1]),d=VZ(u,n.conv_7,[2,2]),c=qZ(t,n.box_predictor_0),p=qZ(e,n.box_predictor_1),h=qZ(a,n.box_predictor_2),f=qZ(s,n.box_predictor_3),m=qZ(l,n.box_predictor_4),g=qZ(d,n.box_predictor_5);return{boxPredictions:nl([c.boxPredictionEncoding,p.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:nl([c.classPrediction,p.classPrediction,h.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}}))}(r.out,r.conv11,t.prediction_layer);return function(e,t,n){return ss((()=>{let r=e.shape[0],a=jZ(Zo(wu(n.extra_dim,[r,1,1]),[-1,4]),Zo(e,[-1,4]));a=Zo(a,[r,a.shape[0]/r,4]);let i=al(il(t,[0,0,1],[-1,-1,-1])),s=il(i,[0,0,0],[-1,-1,1]);return s=Zo(s,[r,s.shape[1]]),{boxes:ep(a),scores:ep(s)}}))}(a,i,t.output_layer)}))}async forward(e){return this.forwardInput(await zJ(e))}async locateFaces(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{maxResults:n,minConfidence:r}=new KZ(t),a=await zJ(e),{boxes:i,scores:s}=this.forwardInput(a),o=i[0],l=s[0];for(let y=1;y<i.length;y++)i[y].dispose(),s[y].dispose();let u=Array.from(l.dataSync()),d=function(e,t,n,r,a){let i=e.shape[0],s=Math.min(n,i),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=s)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=HZ(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}(o,u,n,.5,r),c=a.getReshapedInputDimensions(0),p=a.inputSize,h=p/c.width,f=p/c.height,m=o.arraySync(),g=d.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,i]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*h));return new sJ(u[e],new cJ(r,t,i-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return UZ(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=rZ(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:i}=WZ(n,t),s=a(),o=i(),l={extra_dim:Wc(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:s,prediction_layer:o,output_layer:l},paramMappings:t}}(e)}};var YZ=[new nJ(.738768,.874946),new nJ(2.42204,2.65704),new nJ(4.30971,7.04493),new nJ(10.246,4.59428),new nJ(12.6868,11.8741)],QZ=[new nJ(1.603231,2.094468),new nJ(6.041143,7.080126),new nJ(2.882459,3.518061),new nJ(4.266906,5.178857),new nJ(9.041765,10.66308)],JZ=[117.001,114.697,97.404],ZZ=e=>"number"==typeof e;function e0(e){return ss((()=>{let t=Io(e,cu(.10000000149011612));return wo(lc(Ku(e,t)),t)}))}function t0(e,t){return ss((()=>{let n=kd(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Nl(n,t.conv.filters,[1,1],"valid"),n=Ku(n,t.bn.sub),n=Io(n,t.bn.truediv),n=wo(n,t.conv.bias),e0(n)}))}function n0(e,t){return ss((()=>{let n=kd(e,[[0,0],[1,1],[1,1],[0,0]]);return n=bc(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=wo(n,t.bias),e0(n)}))}function r0(e,t){let n=QJ(e,t);let r=eZ(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function(r,a,i){let s=n(r,a,3,`${i}/conv`),o=function(n,r){let a=zc(e(n)),i=zc(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:i}}(a,`${i}/bn`);return{conv:s,bn:o}},extractSeparableConvParams:r}}function a0(e,t){let n=nZ(e,t);function r(e){return{filters:n(`${e}/filters`,4),bias:n(`${e}/bias`,1)}}return{extractConvParams:r,extractConvWithBatchNormParams:function(e){let t=r(`${e}/conv`),a=function(e){return{sub:n(`${e}/sub`,1),truediv:n(`${e}/truediv`,1)}}(`${e}/bn`);return{conv:t,bn:a}},extractSeparableConvParams:tZ(n)}}var i0=class{constructor(){let{inputSize:e,scoreThreshold:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},s0=class e extends HJ{constructor(e){super("TinyYolov2"),function(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!ZZ(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>ZZ(e.x)&&ZZ(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(ZZ)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=t0(e,t.conv0);return n=ad(n,[2,2],[2,2],"same"),n=t0(n,t.conv1),n=ad(n,[2,2],[2,2],"same"),n=t0(n,t.conv2),n=ad(n,[2,2],[2,2],"same"),n=t0(n,t.conv3),n=ad(n,[2,2],[2,2],"same"),n=t0(n,t.conv4),n=ad(n,[2,2],[2,2],"same"),n=t0(n,t.conv5),n=ad(n,[2,2],[1,1],"same"),n=t0(n,t.conv6),n=t0(n,t.conv7),XJ(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?e0(XJ(e,t.conv0,"valid",!1)):n0(e,t.conv0);return n=ad(n,[2,2],[2,2],"same"),n=n0(n,t.conv1),n=ad(n,[2,2],[2,2],"same"),n=n0(n,t.conv2),n=ad(n,[2,2],[2,2],"same"),n=n0(n,t.conv3),n=ad(n,[2,2],[2,2],"same"),n=n0(n,t.conv4),n=ad(n,[2,2],[2,2],"same"),n=n0(n,t.conv5),n=ad(n,[2,2],[1,1],"same"),n=t.conv6?n0(n,t.conv6):n,n=t.conv7?n0(n,t.conv7):n,XJ(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return ss((()=>{let r=bo(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?lJ(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await zJ(e),t)}async detect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{inputSize:n,scoreThreshold:r}=new i0(t),a=await zJ(e),i=await this.forwardInput(a,n),s=ss((()=>ep(i)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(s,a.getReshapedInputDimensions(0),r);i.dispose(),s.dispose();let u=l.map((e=>e.box)),d=l.map((e=>e.score)),c=l.map((e=>e.classScore)),p=l.map((e=>this.config.classes[e.label]));return function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),i=[];for(;a.length>0;){let t=a.pop();i.push(t);let s=a,o=[];for(let n=0;n<s.length;n++){let a=s[n],i=e[t],l=e[a];o.push(oJ(i,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return i}(u.map((e=>e.rescale(n))),d,this.config.iouThreshold,!0).map((e=>new iJ(d[e],c[e],p[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return function(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:i,extractSeparableConvParams:s}=a0(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:e>7?s("conv6"):void 0,conv7:e>8?s("conv7"):void 0,conv8:a("conv8")}}else n={conv0:i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:i("conv6"),conv7:i("conv7"),conv8:a("conv8")};return YJ(e,r),{params:n,paramMappings:r}}(e,this.config)}extractParams(t){let n=this.config.filterSizes||e.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(7!==r&&8!==r&&9!==r)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return function(e,t,n,r){let a,{extractWeights:i,getRemainingWeights:s}=rZ(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:d}=r0(i,o);if(t.withSeparableConvs){let[e,i,s,o,u,c,p,h,f]=r;a={conv0:t.isFirstLayerConv2d?l(e,i,3,"conv0"):d(e,i,"conv0"),conv1:d(i,s,"conv1"),conv2:d(s,o,"conv2"),conv3:d(o,u,"conv3"),conv4:d(u,c,"conv4"),conv5:d(c,p,"conv5"),conv6:h?d(p,h,"conv6"):void 0,conv7:f?d(h,f,"conv7"):void 0,conv8:l(f||h||p,5*n,1,"conv8")}}else{let[e,t,i,s,o,d,c,p,h]=r;a={conv0:u(e,t,"conv0"),conv1:u(t,i,"conv1"),conv2:u(i,s,"conv2"),conv3:u(s,o,"conv3"),conv4:u(o,d,"conv4"),conv5:u(d,c,"conv5"),conv6:u(c,p,"conv6"),conv7:u(p,h,"conv7"),conv8:l(h,5*n,1,"conv8")}}if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{params:a,paramMappings:o}}(t,this.config,this.boxEncodingSize,n)}async extractBoxes(e,t,n){let{width:r,height:a}=t,i=Math.max(r,a),s=i/r,o=i/a,l=e.shape[1],u=this.config.anchors.length,[d,c,p]=ss((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]);return[t.slice([0,0,0,0],[l,l,u,4]),t.slice([0,0,0,4],[l,l,u,1]),this.withClassScores?_c(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):cu(0)]})),h=[],f=await c.array(),m=await d.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=uJ(f[g][e][t][0]);if(!n||r>n){let n=(e+uJ(m[g][e][t][0]))/l*s,a=(g+uJ(m[g][e][t][1]))/l*o,i=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*s,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*o,d=n-i/2,c=a-u/2,f={row:g,col:e,anchor:t},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(p,f):{classScore:1,label:0};h.push({box:new aJ(d,c,d+i,c+u),score:r,classScore:r*y,label:b,...f})}}return d.dispose(),c.dispose(),p.dispose(),h}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,i=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>i[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}};s0.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var o0=s0,l0=class extends o0{constructor(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:QZ,meanRgb:JZ}:{anchors:YZ,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new sJ(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var u0=class extends i0{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},d0=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function c0(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:e=>{let{alignedRect:t}=e;return t},i=e.map((e=>mZ(e)?a(e):e.detection)),s=r||(t instanceof li?await WJ(t,i):await BJ(t,i)),o=await n(s);return s.forEach((e=>e instanceof li&&e.dispose())),o}var p0=[new nJ(1.603231,2.094468),new nJ(6.041143,7.080126),new nJ(2.882459,3.518061),new nJ(4.266906,5.178857),new nJ(9.041765,10.66308)],h0=[117.001,114.697,97.404],f0=class extends o0{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:p0,meanRgb:h0,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new sJ(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},m0={ssdMobilenetv1:new XZ,tinyFaceDetector:new f0,tinyYolov2:new l0,faceLandmark68Net:new CZ,faceLandmark68TinyNet:new class extends _Z{constructor(){super("FaceLandmark68TinyNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new EZ)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},faceRecognitionNet:new PZ,faceExpressionNet:new class extends dZ{constructor(){super("FaceExpressionNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new oZ)}forwardInput(e){return ss((()=>_c(this.runNet(e))))}async forward(e){return this.forwardInput(await zJ(e))}async predictExpressions(e){let t=await zJ(e),n=await this.forwardInput(t),r=await Promise.all(ep(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new pZ(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}},ageGenderNet:new class extends HJ{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new IZ(2);super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ss((()=>{let n=e instanceof LJ?this.faceFeatureExtractor.forwardInput(e):e,r=el(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:lZ(r,t.fc.age).as1D(),gender:lZ(r,t.fc.gender)}}))}forwardInput(e){return ss((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:_c(n)}}))}async forward(e){return this.forwardInput(await zJ(e))}async predictAgeAndGender(e){let t=await zJ(e),n=await this.forwardInput(t),r=ep(n.age),a=ep(n.gender),i=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),s=await Promise.all(i.map((async e=>{let{ageTensor:t,genderTensor:n}=e,r=t.dataSync()[0],a=n.dataSync()[0],i=a>.5,s=i?"male":"female",o=i?a:1-a;return t.dispose(),n.dispose(),{age:r,gender:s,genderProbability:o}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?s:s[0]}getDefaultModelName(){return"age_gender_model"}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=rZ(e),a=JJ(n,t),i=a(512,1,"fc/age"),s=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:i,gender:s}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=uZ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=nZ(e,t);function r(e){return{weights:n(`${e}/weights`,2),bias:n(`${e}/bias`,1)}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return YJ(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}}},g0=class extends d0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},y0=class extends g0{async run(){let e=await this.parentTask,t=await c0(e,this.input,(async e=>Promise.all(e.map((e=>m0.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>hZ(e,t[n])))}withAgeAndGender(){return new x0(this,this.input)}},b0=class extends y0{withAgeAndGender(){return new w0(this,this.input)}withFaceDescriptors(){return new S0(this,this.input)}},v0=class extends d0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},x0=class extends v0{async run(){let e=await this.parentTask,t=await c0(e,this.input,(async e=>Promise.all(e.map((e=>m0.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:i}=t[n];return zZ(BZ(e,a,i),r)}))}withFaceExpressions(){return new y0(this,this.input)}},w0=class extends x0{withFaceExpressions(){return new b0(this,this.input)}withFaceDescriptors(){return new S0(this,this.input)}},k0=class extends d0{constructor(e,t){super(),this.parentTask=e,this.input=t}},S0=class extends k0{async run(){let e=await this.parentTask;return(await c0(e,this.input,(e=>Promise.all(e.map((e=>m0.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>LZ(e[n],t)))}withFaceExpressions(){return new b0(this,this.input)}withAgeAndGender(){return new w0(this,this.input)}},I0=class extends d0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?m0.faceLandmark68TinyNet:m0.faceLandmark68Net}},N0=class extends I0{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof li?await WJ(this.input,t):await BJ(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof li&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>gZ(e,r[t])))}withFaceExpressions(){return new b0(this,this.input)}withAgeAndGender(){return new w0(this,this.input)}withFaceDescriptors(){return new S0(this,this.input)}},T0=class extends d0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new KZ;super(),this.input=e,this.options=t}},_0=class extends T0{async run(){let e,{input:t,options:n}=this;if(n instanceof u0)e=m0.tinyFaceDetector.locateFaces(t,n);else if(n instanceof KZ)e=m0.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof i0))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=m0.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>mJ({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new N0(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new y0(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new x0(this.runAndExtendWithFaceDetections(),this.input)}};function C0(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new KZ;return new _0(e,t)}function E0(e,t){let{width:n,height:r}=new WQ(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map((e=>E0(e,{width:n,height:r})));if(mZ(e)){let t=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return gZ(mJ(e,t),a)}return fJ(e)?mJ(e,e.detection.forSize(n,r)):e instanceof pJ||e instanceof sJ?e.forSize(n,r):e}function A0(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;const r=t.width*t.height,a=function(e,t){const{cx:n,cy:r,r:a}=e,{x:i,y:s,width:o,height:l}=t,u=Math.min(o,l)/100;let d=0;for(let c=i;c<=i+o;c+=u)for(let e=s;e<=s+l;e+=u){const t=c-n,i=e-r;t*t+i*i<=a*a&&(d+=u*u)}return d}(e,t),i=a/r,s=t.x+t.width/2,o=t.y+t.height/2,l=s-e.cx,u=o-e.cy,d=l*l+u*u,c=d<=e.r*e.r,p=d<=e.r/4*(e.r/2);return i>=n&&c&&p}const $0=(e,n,r)=>{const[a,i]=(0,t.useState)(!1),[s,o]=(0,t.useState)(!1);return(0,t.useEffect)((()=>{(async()=>{await Promise.all([m0.tinyFaceDetector.loadFromUri("ia_models")]),o(!0)})()}),[]),(0,t.useEffect)((()=>{if(s&&e){const e=async()=>{if(n.current&&r.current){const e=n.current,t=r.current,a={width:e.clientWidth,height:e.clientHeight};!function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{width:r,height:a}=n?DJ(t):t;e.width=r,e.height=a}(t,a);const s=new u0({inputSize:416,scoreThreshold:.3}),o=E0(await C0(e,s),a),l={cx:e.clientWidth/2,cy:e.clientHeight/2,r:150};let u=!1;o.forEach((e=>{const{x:t,y:n,width:r,height:a}=e.box;u=A0(l,{x:t,y:n,width:r,height:a},.8)})),i(u)}},t=setInterval(e,100);return()=>clearInterval(t)}}),[s,e]),{isFaceDetected:a,modelsLoaded:s}};function R0(e,t){return function(){return e.apply(t,arguments)}}const{toString:F0}=Object.prototype,{getPrototypeOf:D0}=Object,M0=(O0=Object.create(null),e=>{const t=F0.call(e);return O0[t]||(O0[t]=t.slice(8,-1).toLowerCase())});var O0;const P0=e=>(e=e.toLowerCase(),t=>M0(t)===e),L0=e=>t=>typeof t===e,{isArray:z0}=Array,B0=L0("undefined");const W0=P0("ArrayBuffer");const U0=L0("string"),V0=L0("function"),G0=L0("number"),H0=e=>null!==e&&"object"===typeof e,j0=e=>{if("object"!==M0(e))return!1;const t=D0(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},q0=P0("Date"),K0=P0("File"),X0=P0("Blob"),Y0=P0("FileList"),Q0=P0("URLSearchParams"),[J0,Z0,e1,t1]=["ReadableStream","Request","Response","Headers"].map(P0);function n1(e,t){let n,r,{allOwnKeys:a=!1}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(null!==e&&"undefined"!==typeof e)if("object"!==typeof e&&(e=[e]),z0(e))for(n=0,r=e.length;n<r;n++)t.call(null,e[n],n,e);else{const r=a?Object.getOwnPropertyNames(e):Object.keys(e),i=r.length;let s;for(n=0;n<i;n++)s=r[n],t.call(null,e[s],s,e)}}function r1(e,t){t=t.toLowerCase();const n=Object.keys(e);let r,a=n.length;for(;a-- >0;)if(r=n[a],t===r.toLowerCase())return r;return null}const a1="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:global,i1=e=>!B0(e)&&e!==a1;const s1=(o1="undefined"!==typeof Uint8Array&&D0(Uint8Array),e=>o1&&e instanceof o1);var o1;const l1=P0("HTMLFormElement"),u1=(e=>{let{hasOwnProperty:t}=e;return(e,n)=>t.call(e,n)})(Object.prototype),d1=P0("RegExp"),c1=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};n1(n,((n,a)=>{let i;!1!==(i=t(n,a,e))&&(r[a]=i||n)})),Object.defineProperties(e,r)},p1="abcdefghijklmnopqrstuvwxyz",h1="0123456789",f1={DIGIT:h1,ALPHA:p1,ALPHA_DIGIT:p1+p1.toUpperCase()+h1};const m1=P0("AsyncFunction"),g1=((e,t)=>{return e?setImmediate:t?(n=`axios@${Math.random()}`,r=[],a1.addEventListener("message",(e=>{let{source:t,data:a}=e;t===a1&&a===n&&r.length&&r.shift()()}),!1),e=>{r.push(e),a1.postMessage(n,"*")}):e=>setTimeout(e);var n,r})("function"===typeof setImmediate,V0(a1.postMessage)),y1="undefined"!==typeof queueMicrotask?queueMicrotask.bind(a1):"undefined"!==typeof process&&process.nextTick||g1,b1={isArray:z0,isArrayBuffer:W0,isBuffer:function(e){return null!==e&&!B0(e)&&null!==e.constructor&&!B0(e.constructor)&&V0(e.constructor.isBuffer)&&e.constructor.isBuffer(e)},isFormData:e=>{let t;return e&&("function"===typeof FormData&&e instanceof FormData||V0(e.append)&&("formdata"===(t=M0(e))||"object"===t&&V0(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){let t;return t="undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&W0(e.buffer),t},isString:U0,isNumber:G0,isBoolean:e=>!0===e||!1===e,isObject:H0,isPlainObject:j0,isReadableStream:J0,isRequest:Z0,isResponse:e1,isHeaders:t1,isUndefined:B0,isDate:q0,isFile:K0,isBlob:X0,isRegExp:d1,isFunction:V0,isStream:e=>H0(e)&&V0(e.pipe),isURLSearchParams:Q0,isTypedArray:s1,isFileList:Y0,forEach:n1,merge:function e(){const{caseless:t}=i1(this)&&this||{},n={},r=(r,a)=>{const i=t&&r1(n,a)||a;j0(n[i])&&j0(r)?n[i]=e(n[i],r):j0(r)?n[i]=e({},r):z0(r)?n[i]=r.slice():n[i]=r};for(let a=0,i=arguments.length;a<i;a++)arguments[a]&&n1(arguments[a],r);return n},extend:function(e,t,n){let{allOwnKeys:r}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n1(t,((t,r)=>{n&&V0(t)?e[r]=R0(t,n):e[r]=t}),{allOwnKeys:r}),e},trim:e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:e=>(65279===e.charCodeAt(0)&&(e=e.slice(1)),e),inherits:(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:(e,t,n,r)=>{let a,i,s;const o={};if(t=t||{},null==e)return t;do{for(a=Object.getOwnPropertyNames(e),i=a.length;i-- >0;)s=a[i],r&&!r(s,e,t)||o[s]||(t[s]=e[s],o[s]=!0);e=!1!==n&&D0(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:M0,kindOfTest:P0,endsWith:(e,t,n)=>{e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return-1!==r&&r===n},toArray:e=>{if(!e)return null;if(z0(e))return e;let t=e.length;if(!G0(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},forEachEntry:(e,t)=>{const n=(e&&e[Symbol.iterator]).call(e);let r;for(;(r=n.next())&&!r.done;){const n=r.value;t.call(e,n[0],n[1])}},matchAll:(e,t)=>{let n;const r=[];for(;null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:l1,hasOwnProperty:u1,hasOwnProp:u1,reduceDescriptors:c1,freezeMethods:e=>{c1(e,((t,n)=>{if(V0(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=e[n];V0(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:(e,t)=>{const n={},r=e=>{e.forEach((e=>{n[e]=!0}))};return z0(e)?r(e):r(String(e).split(t)),n},toCamelCase:e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n})),noop:()=>{},toFiniteNumber:(e,t)=>null!=e&&Number.isFinite(e=+e)?e:t,findKey:r1,global:a1,isContextDefined:i1,ALPHABET:f1,generateString:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:16,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f1.ALPHA_DIGIT,n="";const{length:r}=t;for(;e--;)n+=t[Math.random()*r|0];return n},isSpecCompliantForm:function(e){return!!(e&&V0(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])},toJSONObject:e=>{const t=new Array(10),n=(e,r)=>{if(H0(e)){if(t.indexOf(e)>=0)return;if(!("toJSON"in e)){t[r]=e;const a=z0(e)?[]:{};return n1(e,((e,t)=>{const i=n(e,r+1);!B0(i)&&(a[t]=i)})),t[r]=void 0,a}}return e};return n(e,0)},isAsyncFn:m1,isThenable:e=>e&&(H0(e)||V0(e))&&V0(e.then)&&V0(e.catch),setImmediate:g1,asap:y1};function v1(e,t,n,r,a){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),a&&(this.response=a,this.status=a.status?a.status:null)}b1.inherits(v1,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:b1.toJSONObject(this.config),code:this.code,status:this.status}}});const x1=v1.prototype,w1={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((e=>{w1[e]={value:e}})),Object.defineProperties(v1,w1),Object.defineProperty(x1,"isAxiosError",{value:!0}),v1.from=(e,t,n,r,a,i)=>{const s=Object.create(x1);return b1.toFlatObject(e,s,(function(e){return e!==Error.prototype}),(e=>"isAxiosError"!==e)),v1.call(s,e.message,t,n,r,a),s.cause=e,s.name=e.name,i&&Object.assign(s,i),s};const k1=v1;function S1(e){return b1.isPlainObject(e)||b1.isArray(e)}function I1(e){return b1.endsWith(e,"[]")?e.slice(0,-2):e}function N1(e,t,n){return e?e.concat(t).map((function(e,t){return e=I1(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}const T1=b1.toFlatObject(b1,{},null,(function(e){return/^is[A-Z]/.test(e)}));const _1=function(e,t,n){if(!b1.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;const r=(n=b1.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!b1.isUndefined(t[e])}))).metaTokens,a=n.visitor||u,i=n.dots,s=n.indexes,o=(n.Blob||"undefined"!==typeof Blob&&Blob)&&b1.isSpecCompliantForm(t);if(!b1.isFunction(a))throw new TypeError("visitor must be a function");function l(e){if(null===e)return"";if(b1.isDate(e))return e.toISOString();if(!o&&b1.isBlob(e))throw new k1("Blob is not supported. Use a Buffer instead.");return b1.isArrayBuffer(e)||b1.isTypedArray(e)?o&&"function"===typeof Blob?new Blob([e]):Buffer.from(e):e}function u(e,n,a){let o=e;if(e&&!a&&"object"===typeof e)if(b1.endsWith(n,"{}"))n=r?n:n.slice(0,-2),e=JSON.stringify(e);else if(b1.isArray(e)&&function(e){return b1.isArray(e)&&!e.some(S1)}(e)||(b1.isFileList(e)||b1.endsWith(n,"[]"))&&(o=b1.toArray(e)))return n=I1(n),o.forEach((function(e,r){!b1.isUndefined(e)&&null!==e&&t.append(!0===s?N1([n],r,i):null===s?n:n+"[]",l(e))})),!1;return!!S1(e)||(t.append(N1(a,n,i),l(e)),!1)}const d=[],c=Object.assign(T1,{defaultVisitor:u,convertValue:l,isVisitable:S1});if(!b1.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!b1.isUndefined(n)){if(-1!==d.indexOf(n))throw Error("Circular reference detected in "+r.join("."));d.push(n),b1.forEach(n,(function(n,i){!0===(!(b1.isUndefined(n)||null===n)&&a.call(t,n,b1.isString(i)?i.trim():i,r,c))&&e(n,r?r.concat(i):[i])})),d.pop()}}(e),t};function C1(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function E1(e,t){this._pairs=[],e&&_1(e,this,t)}const A1=E1.prototype;A1.append=function(e,t){this._pairs.push([e,t])},A1.toString=function(e){const t=e?function(t){return e.call(this,t,C1)}:C1;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};const $1=E1;function R1(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function F1(e,t,n){if(!t)return e;const r=n&&n.encode||R1;b1.isFunction(n)&&(n={serialize:n});const a=n&&n.serialize;let i;if(i=a?a(t,n):b1.isURLSearchParams(t)?t.toString():new $1(t,n).toString(r),i){const t=e.indexOf("#");-1!==t&&(e=e.slice(0,t)),e+=(-1===e.indexOf("?")?"?":"&")+i}return e}const D1=class{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){b1.forEach(this.handlers,(function(t){null!==t&&e(t)}))}},M1={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},O1={isBrowser:!0,classes:{URLSearchParams:"undefined"!==typeof URLSearchParams?URLSearchParams:$1,FormData:"undefined"!==typeof FormData?FormData:null,Blob:"undefined"!==typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},P1="undefined"!==typeof window&&"undefined"!==typeof document,L1="object"===typeof navigator&&navigator||void 0,z1=P1&&(!L1||["ReactNative","NativeScript","NS"].indexOf(L1.product)<0),B1="undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"===typeof self.importScripts,W1=P1&&window.location.href||"http://localhost",U1={...e,...O1};const V1=function(e){function t(e,n,r,a){let i=e[a++];if("__proto__"===i)return!0;const s=Number.isFinite(+i),o=a>=e.length;if(i=!i&&b1.isArray(r)?r.length:i,o)return b1.hasOwnProp(r,i)?r[i]=[r[i],n]:r[i]=n,!s;r[i]&&b1.isObject(r[i])||(r[i]=[]);return t(e,n,r[i],a)&&b1.isArray(r[i])&&(r[i]=function(e){const t={},n=Object.keys(e);let r;const a=n.length;let i;for(r=0;r<a;r++)i=n[r],t[i]=e[i];return t}(r[i])),!s}if(b1.isFormData(e)&&b1.isFunction(e.entries)){const n={};return b1.forEachEntry(e,((e,r)=>{t(function(e){return b1.matchAll(/\w+|\[(\w*)]/g,e).map((e=>"[]"===e[0]?"":e[1]||e[0]))}(e),r,n,0)})),n}return null};const G1={transitional:M1,adapter:["xhr","http","fetch"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,a=b1.isObject(e);a&&b1.isHTMLForm(e)&&(e=new FormData(e));if(b1.isFormData(e))return r?JSON.stringify(V1(e)):e;if(b1.isArrayBuffer(e)||b1.isBuffer(e)||b1.isStream(e)||b1.isFile(e)||b1.isBlob(e)||b1.isReadableStream(e))return e;if(b1.isArrayBufferView(e))return e.buffer;if(b1.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let i;if(a){if(n.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return _1(e,new U1.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return U1.isNode&&b1.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}(e,this.formSerializer).toString();if((i=b1.isFileList(e))||n.indexOf("multipart/form-data")>-1){const t=this.env&&this.env.FormData;return _1(i?{"files[]":e}:e,t&&new t,this.formSerializer)}}return a||r?(t.setContentType("application/json",!1),function(e,t,n){if(b1.isString(e))try{return(t||JSON.parse)(e),b1.trim(e)}catch(pi){if("SyntaxError"!==pi.name)throw pi}return(n||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){const t=this.transitional||G1.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(b1.isResponse(e)||b1.isReadableStream(e))return e;if(e&&b1.isString(e)&&(n&&!this.responseType||r)){const n=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(pi){if(n){if("SyntaxError"===pi.name)throw k1.from(pi,k1.ERR_BAD_RESPONSE,this,null,this.response);throw pi}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:U1.classes.FormData,Blob:U1.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};b1.forEach(["delete","get","head","post","put","patch"],(e=>{G1.headers[e]={}}));const H1=G1,j1=b1.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),q1=Symbol("internals");function K1(e){return e&&String(e).trim().toLowerCase()}function X1(e){return!1===e||null==e?e:b1.isArray(e)?e.map(X1):String(e)}function Y1(e,t,n,r,a){return b1.isFunction(r)?r.call(this,t,n):(a&&(t=n),b1.isString(t)?b1.isString(r)?-1!==t.indexOf(r):b1.isRegExp(r)?r.test(t):void 0:void 0)}class Q1{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function a(e,t,n){const a=K1(t);if(!a)throw new Error("header name must be a non-empty string");const i=b1.findKey(r,a);(!i||void 0===r[i]||!0===n||void 0===n&&!1!==r[i])&&(r[i||t]=X1(e))}const i=(e,t)=>b1.forEach(e,((e,n)=>a(e,n,t)));if(b1.isPlainObject(e)||e instanceof this.constructor)i(e,t);else if(b1.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))i((e=>{const t={};let n,r,a;return e&&e.split("\n").forEach((function(e){a=e.indexOf(":"),n=e.substring(0,a).trim().toLowerCase(),r=e.substring(a+1).trim(),!n||t[n]&&j1[n]||("set-cookie"===n?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)})),t})(e),t);else if(b1.isHeaders(e))for(const[s,o]of e.entries())a(o,s,n);else null!=e&&a(t,e,n);return this}get(e,t){if(e=K1(e)){const n=b1.findKey(this,e);if(n){const e=this[n];if(!t)return e;if(!0===t)return function(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}(e);if(b1.isFunction(t))return t.call(this,e,n);if(b1.isRegExp(t))return t.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=K1(e)){const n=b1.findKey(this,e);return!(!n||void 0===this[n]||t&&!Y1(0,this[n],n,t))}return!1}delete(e,t){const n=this;let r=!1;function a(e){if(e=K1(e)){const a=b1.findKey(n,e);!a||t&&!Y1(0,n[a],a,t)||(delete n[a],r=!0)}}return b1.isArray(e)?e.forEach(a):a(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;for(;n--;){const a=t[n];e&&!Y1(0,this[a],a,e,!0)||(delete this[a],r=!0)}return r}normalize(e){const t=this,n={};return b1.forEach(this,((r,a)=>{const i=b1.findKey(n,a);if(i)return t[i]=X1(r),void delete t[a];const s=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((e,t,n)=>t.toUpperCase()+n))}(a):String(a).trim();s!==a&&delete t[a],t[s]=X1(r),n[s]=!0})),this}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.constructor.concat(this,...t)}toJSON(e){const t=Object.create(null);return b1.forEach(this,((n,r)=>{null!=n&&!1!==n&&(t[r]=e&&b1.isArray(n)?n.join(", "):n)})),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((e=>{let[t,n]=e;return t+": "+n})).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e){const t=new this(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return r.forEach((e=>t.set(e))),t}static accessor(e){const t=(this[q1]=this[q1]={accessors:{}}).accessors,n=this.prototype;function r(e){const r=K1(e);t[r]||(!function(e,t){const n=b1.toCamelCase(" "+t);["get","set","has"].forEach((r=>{Object.defineProperty(e,r+n,{value:function(e,n,a){return this[r].call(this,t,e,n,a)},configurable:!0})}))}(n,e),t[r]=!0)}return b1.isArray(e)?e.forEach(r):r(e),this}}Q1.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),b1.reduceDescriptors(Q1.prototype,((e,t)=>{let{value:n}=e,r=t[0].toUpperCase()+t.slice(1);return{get:()=>n,set(e){this[r]=e}}})),b1.freezeMethods(Q1);const J1=Q1;function Z1(e,t){const n=this||H1,r=t||n,a=J1.from(r.headers);let i=r.data;return b1.forEach(e,(function(e){i=e.call(n,i,a.normalize(),t?t.status:void 0)})),a.normalize(),i}function e2(e){return!(!e||!e.__CANCEL__)}function t2(e,t,n){k1.call(this,null==e?"canceled":e,k1.ERR_CANCELED,t,n),this.name="CanceledError"}b1.inherits(t2,k1,{__CANCEL__:!0});const n2=t2;function r2(e,t,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new k1("Request failed with status code "+n.status,[k1.ERR_BAD_REQUEST,k1.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}const a2=function(e,t){e=e||10;const n=new Array(e),r=new Array(e);let a,i=0,s=0;return t=void 0!==t?t:1e3,function(o){const l=Date.now(),u=r[s];a||(a=l),n[i]=o,r[i]=l;let d=s,c=0;for(;d!==i;)c+=n[d++],d%=e;if(i=(i+1)%e,i===s&&(s=(s+1)%e),l-a<t)return;const p=u&&l-u;return p?Math.round(1e3*c/p):void 0}};const i2=function(e,t){let n,r,a=0,i=1e3/t;const s=function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Date.now();a=i,n=null,r&&(clearTimeout(r),r=null),e.apply(null,t)};return[function(){const e=Date.now(),t=e-a;for(var o=arguments.length,l=new Array(o),u=0;u<o;u++)l[u]=arguments[u];t>=i?s(l,e):(n=l,r||(r=setTimeout((()=>{r=null,s(n)}),i-t)))},()=>n&&s(n)]},s2=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3,r=0;const a=a2(50,250);return i2((n=>{const i=n.loaded,s=n.lengthComputable?n.total:void 0,o=i-r,l=a(o);r=i;e({loaded:i,total:s,progress:s?i/s:void 0,bytes:o,rate:l||void 0,estimated:l&&s&&i<=s?(s-i)/l:void 0,event:n,lengthComputable:null!=s,[t?"download":"upload"]:!0})}),n)},o2=(e,t)=>{const n=null!=e;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},l2=e=>function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return b1.asap((()=>e(...n)))},u2=U1.hasStandardBrowserEnv?((e,t)=>n=>(n=new URL(n,U1.origin),e.protocol===n.protocol&&e.host===n.host&&(t||e.port===n.port)))(new URL(U1.origin),U1.navigator&&/(msie|trident)/i.test(U1.navigator.userAgent)):()=>!0,d2=U1.hasStandardBrowserEnv?{write(e,t,n,r,a,i){const s=[e+"="+encodeURIComponent(t)];b1.isNumber(n)&&s.push("expires="+new Date(n).toGMTString()),b1.isString(r)&&s.push("path="+r),b1.isString(a)&&s.push("domain="+a),!0===i&&s.push("secure"),document.cookie=s.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function c2(e,t){return e&&!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)?function(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}const p2=e=>e instanceof J1?{...e}:e;function h2(e,t){t=t||{};const n={};function r(e,t,n,r){return b1.isPlainObject(e)&&b1.isPlainObject(t)?b1.merge.call({caseless:r},e,t):b1.isPlainObject(t)?b1.merge({},t):b1.isArray(t)?t.slice():t}function a(e,t,n,a){return b1.isUndefined(t)?b1.isUndefined(e)?void 0:r(void 0,e,0,a):r(e,t,0,a)}function i(e,t){if(!b1.isUndefined(t))return r(void 0,t)}function s(e,t){return b1.isUndefined(t)?b1.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function o(n,a,i){return i in t?r(n,a):i in e?r(void 0,n):void 0}const l={url:i,method:i,data:i,baseURL:s,transformRequest:s,transformResponse:s,paramsSerializer:s,timeout:s,timeoutMessage:s,withCredentials:s,withXSRFToken:s,adapter:s,responseType:s,xsrfCookieName:s,xsrfHeaderName:s,onUploadProgress:s,onDownloadProgress:s,decompress:s,maxContentLength:s,maxBodyLength:s,beforeRedirect:s,transport:s,httpAgent:s,httpsAgent:s,cancelToken:s,socketPath:s,responseEncoding:s,validateStatus:o,headers:(e,t,n)=>a(p2(e),p2(t),0,!0)};return b1.forEach(Object.keys(Object.assign({},e,t)),(function(r){const i=l[r]||a,s=i(e[r],t[r],r);b1.isUndefined(s)&&i!==o||(n[r]=s)})),n}const f2=e=>{const t=h2({},e);let n,{data:r,withXSRFToken:a,xsrfHeaderName:i,xsrfCookieName:s,headers:o,auth:l}=t;if(t.headers=o=J1.from(o),t.url=F1(c2(t.baseURL,t.url),e.params,e.paramsSerializer),l&&o.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):""))),b1.isFormData(r))if(U1.hasStandardBrowserEnv||U1.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0);else if(!1!==(n=o.getContentType())){const[e,...t]=n?n.split(";").map((e=>e.trim())).filter(Boolean):[];o.setContentType([e||"multipart/form-data",...t].join("; "))}if(U1.hasStandardBrowserEnv&&(a&&b1.isFunction(a)&&(a=a(t)),a||!1!==a&&u2(t.url))){const e=i&&s&&d2.read(s);e&&o.set(i,e)}return t},m2="undefined"!==typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){const r=f2(e);let a=r.data;const i=J1.from(r.headers).normalize();let s,o,l,u,d,{responseType:c,onUploadProgress:p,onDownloadProgress:h}=r;function f(){u&&u(),d&&d(),r.cancelToken&&r.cancelToken.unsubscribe(s),r.signal&&r.signal.removeEventListener("abort",s)}let m=new XMLHttpRequest;function g(){if(!m)return;const r=J1.from("getAllResponseHeaders"in m&&m.getAllResponseHeaders());r2((function(e){t(e),f()}),(function(e){n(e),f()}),{data:c&&"text"!==c&&"json"!==c?m.response:m.responseText,status:m.status,statusText:m.statusText,headers:r,config:e,request:m}),m=null}m.open(r.method.toUpperCase(),r.url,!0),m.timeout=r.timeout,"onloadend"in m?m.onloadend=g:m.onreadystatechange=function(){m&&4===m.readyState&&(0!==m.status||m.responseURL&&0===m.responseURL.indexOf("file:"))&&setTimeout(g)},m.onabort=function(){m&&(n(new k1("Request aborted",k1.ECONNABORTED,e,m)),m=null)},m.onerror=function(){n(new k1("Network Error",k1.ERR_NETWORK,e,m)),m=null},m.ontimeout=function(){let t=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const a=r.transitional||M1;r.timeoutErrorMessage&&(t=r.timeoutErrorMessage),n(new k1(t,a.clarifyTimeoutError?k1.ETIMEDOUT:k1.ECONNABORTED,e,m)),m=null},void 0===a&&i.setContentType(null),"setRequestHeader"in m&&b1.forEach(i.toJSON(),(function(e,t){m.setRequestHeader(t,e)})),b1.isUndefined(r.withCredentials)||(m.withCredentials=!!r.withCredentials),c&&"json"!==c&&(m.responseType=r.responseType),h&&([l,d]=s2(h,!0),m.addEventListener("progress",l)),p&&m.upload&&([o,u]=s2(p),m.upload.addEventListener("progress",o),m.upload.addEventListener("loadend",u)),(r.cancelToken||r.signal)&&(s=t=>{m&&(n(!t||t.type?new n2(null,e,m):t),m.abort(),m=null)},r.cancelToken&&r.cancelToken.subscribe(s),r.signal&&(r.signal.aborted?s():r.signal.addEventListener("abort",s)));const y=function(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}(r.url);y&&-1===U1.protocols.indexOf(y)?n(new k1("Unsupported protocol "+y+":",k1.ERR_BAD_REQUEST,e)):m.send(a||null)}))},g2=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let n,r=new AbortController;const a=function(e){if(!n){n=!0,s();const t=e instanceof Error?e:this.reason;r.abort(t instanceof k1?t:new n2(t instanceof Error?t.message:t))}};let i=t&&setTimeout((()=>{i=null,a(new k1(`timeout ${t} of ms exceeded`,k1.ETIMEDOUT))}),t);const s=()=>{e&&(i&&clearTimeout(i),i=null,e.forEach((e=>{e.unsubscribe?e.unsubscribe(a):e.removeEventListener("abort",a)})),e=null)};e.forEach((e=>e.addEventListener("abort",a)));const{signal:o}=r;return o.unsubscribe=()=>b1.asap(s),o}},y2=function*(e,t){let n=e.byteLength;if(!t||n<t)return void(yield e);let r,a=0;for(;a<n;)r=a+t,yield e.slice(a,r),a=r},b2=async function*(e){if(e[Symbol.asyncIterator])return void(yield*e);const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)break;yield n}}finally{await t.cancel()}},v2=(e,t,n,r)=>{const a=async function*(e,t){for await(const n of b2(e))yield*y2(n,t)}(e,t);let i,s=0,o=e=>{i||(i=!0,r&&r(e))};return new ReadableStream({async pull(e){try{const{done:t,value:r}=await a.next();if(t)return o(),void e.close();let i=r.byteLength;if(n){let e=s+=i;n(e)}e.enqueue(new Uint8Array(r))}catch(t){throw o(t),t}},cancel:e=>(o(e),a.return())},{highWaterMark:2})},x2="function"===typeof fetch&&"function"===typeof Request&&"function"===typeof Response,w2=x2&&"function"===typeof ReadableStream,k2=x2&&("function"===typeof TextEncoder?(S2=new TextEncoder,e=>S2.encode(e)):async e=>new Uint8Array(await new Response(e).arrayBuffer()));var S2;const I2=function(e){try{for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return!!e(...n)}catch(pi){return!1}},N2=w2&&I2((()=>{let e=!1;const t=new Request(U1.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t})),T2=w2&&I2((()=>b1.isReadableStream(new Response("").body))),_2={stream:T2&&(e=>e.body)};var C2;x2&&(C2=new Response,["text","arrayBuffer","blob","formData","stream"].forEach((e=>{!_2[e]&&(_2[e]=b1.isFunction(C2[e])?t=>t[e]():(t,n)=>{throw new k1(`Response type '${e}' is not supported`,k1.ERR_NOT_SUPPORT,n)})})));const E2=async(e,t)=>{const n=b1.toFiniteNumber(e.getContentLength());return null==n?(async e=>{if(null==e)return 0;if(b1.isBlob(e))return e.size;if(b1.isSpecCompliantForm(e)){const t=new Request(U1.origin,{method:"POST",body:e});return(await t.arrayBuffer()).byteLength}return b1.isArrayBufferView(e)||b1.isArrayBuffer(e)?e.byteLength:(b1.isURLSearchParams(e)&&(e+=""),b1.isString(e)?(await k2(e)).byteLength:void 0)})(t):n},A2={http:null,xhr:m2,fetch:x2&&(async e=>{let{url:t,method:n,data:r,signal:a,cancelToken:i,timeout:s,onDownloadProgress:o,onUploadProgress:l,responseType:u,headers:d,withCredentials:c="same-origin",fetchOptions:p}=f2(e);u=u?(u+"").toLowerCase():"text";let h,f=g2([a,i&&i.toAbortSignal()],s);const m=f&&f.unsubscribe&&(()=>{f.unsubscribe()});let g;try{if(l&&N2&&"get"!==n&&"head"!==n&&0!==(g=await E2(d,r))){let e,n=new Request(t,{method:"POST",body:r,duplex:"half"});if(b1.isFormData(r)&&(e=n.headers.get("content-type"))&&d.setContentType(e),n.body){const[e,t]=o2(g,s2(l2(l)));r=v2(n.body,65536,e,t)}}b1.isString(c)||(c=c?"include":"omit");const a="credentials"in Request.prototype;h=new Request(t,{...p,signal:f,method:n.toUpperCase(),headers:d.normalize().toJSON(),body:r,duplex:"half",credentials:a?c:void 0});let i=await fetch(h);const s=T2&&("stream"===u||"response"===u);if(T2&&(o||s&&m)){const e={};["status","statusText","headers"].forEach((t=>{e[t]=i[t]}));const t=b1.toFiniteNumber(i.headers.get("content-length")),[n,r]=o&&o2(t,s2(l2(o),!0))||[];i=new Response(v2(i.body,65536,n,(()=>{r&&r(),m&&m()})),e)}u=u||"text";let y=await _2[b1.findKey(_2,u)||"text"](i,e);return!s&&m&&m(),await new Promise(((t,n)=>{r2(t,n,{data:y,headers:J1.from(i.headers),status:i.status,statusText:i.statusText,config:e,request:h})}))}catch(y){if(m&&m(),y&&"TypeError"===y.name&&/fetch/i.test(y.message))throw Object.assign(new k1("Network Error",k1.ERR_NETWORK,e,h),{cause:y.cause||y});throw k1.from(y,y&&y.code,e,h)}})};b1.forEach(A2,((e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch(pi){}Object.defineProperty(e,"adapterName",{value:t})}}));const $2=e=>`- ${e}`,R2=e=>b1.isFunction(e)||null===e||!1===e,F2=e=>{e=b1.isArray(e)?e:[e];const{length:t}=e;let n,r;const a={};for(let i=0;i<t;i++){let t;if(n=e[i],r=n,!R2(n)&&(r=A2[(t=String(n)).toLowerCase()],void 0===r))throw new k1(`Unknown adapter '${t}'`);if(r)break;a[t||"#"+i]=r}if(!r){const e=Object.entries(a).map((e=>{let[t,n]=e;return`adapter ${t} `+(!1===n?"is not supported by the environment":"is not available in the build")}));let n=t?e.length>1?"since :\n"+e.map($2).join("\n"):" "+$2(e[0]):"as no adapter specified";throw new k1("There is no suitable adapter to dispatch the request "+n,"ERR_NOT_SUPPORT")}return r};function D2(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new n2(null,e)}function M2(e){D2(e),e.headers=J1.from(e.headers),e.data=Z1.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1);return F2(e.adapter||H1.adapter)(e).then((function(t){return D2(e),t.data=Z1.call(e,e.transformResponse,t),t.headers=J1.from(t.headers),t}),(function(t){return e2(t)||(D2(e),t&&t.response&&(t.response.data=Z1.call(e,e.transformResponse,t.response),t.response.headers=J1.from(t.response.headers))),Promise.reject(t)}))}const O2="1.7.8",P2={};["object","boolean","number","function","string","symbol"].forEach(((e,t)=>{P2[e]=function(n){return typeof n===e||"a"+(t<1?"n ":" ")+e}}));const L2={};P2.transitional=function(e,t,n){function r(e,t){return"[Axios v1.7.8] Transitional option '"+e+"'"+t+(n?". "+n:"")}return(n,a,i)=>{if(!1===e)throw new k1(r(a," has been removed"+(t?" in "+t:"")),k1.ERR_DEPRECATED);return t&&!L2[a]&&(L2[a]=!0,console.warn(r(a," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,a,i)}},P2.spelling=function(e){return(t,n)=>(console.warn(`${n} is likely a misspelling of ${e}`),!0)};const z2={assertOptions:function(e,t,n){if("object"!==typeof e)throw new k1("options must be an object",k1.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let a=r.length;for(;a-- >0;){const i=r[a],s=t[i];if(s){const t=e[i],n=void 0===t||s(t,i,e);if(!0!==n)throw new k1("option "+i+" must be "+n,k1.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new k1("Unknown option "+i,k1.ERR_BAD_OPTION)}},validators:P2},B2=z2.validators;class W2{constructor(e){this.defaults=e,this.interceptors={request:new D1,response:new D1}}async request(e,t){try{return await this._request(e,t)}catch(n){if(n instanceof Error){let e={};Error.captureStackTrace?Error.captureStackTrace(e):e=new Error;const t=e.stack?e.stack.replace(/^.+\n/,""):"";try{n.stack?t&&!String(n.stack).endsWith(t.replace(/^.+\n.+\n/,""))&&(n.stack+="\n"+t):n.stack=t}catch(pi){}}throw n}}_request(e,t){"string"===typeof e?(t=t||{}).url=e:t=e||{},t=h2(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:a}=t;void 0!==n&&z2.assertOptions(n,{silentJSONParsing:B2.transitional(B2.boolean),forcedJSONParsing:B2.transitional(B2.boolean),clarifyTimeoutError:B2.transitional(B2.boolean)},!1),null!=r&&(b1.isFunction(r)?t.paramsSerializer={serialize:r}:z2.assertOptions(r,{encode:B2.function,serialize:B2.function},!0)),z2.assertOptions(t,{baseUrl:B2.spelling("baseURL"),withXsrfToken:B2.spelling("withXSRFToken")},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase();let i=a&&b1.merge(a.common,a[t.method]);a&&b1.forEach(["delete","get","head","post","put","patch","common"],(e=>{delete a[e]})),t.headers=J1.concat(i,a);const s=[];let o=!0;this.interceptors.request.forEach((function(e){"function"===typeof e.runWhen&&!1===e.runWhen(t)||(o=o&&e.synchronous,s.unshift(e.fulfilled,e.rejected))}));const l=[];let u;this.interceptors.response.forEach((function(e){l.push(e.fulfilled,e.rejected)}));let d,c=0;if(!o){const e=[M2.bind(this),void 0];for(e.unshift.apply(e,s),e.push.apply(e,l),d=e.length,u=Promise.resolve(t);c<d;)u=u.then(e[c++],e[c++]);return u}d=s.length;let p=t;for(c=0;c<d;){const e=s[c++],t=s[c++];try{p=e(p)}catch(h){t.call(this,h);break}}try{u=M2.call(this,p)}catch(h){return Promise.reject(h)}for(c=0,d=l.length;c<d;)u=u.then(l[c++],l[c++]);return u}getUri(e){return F1(c2((e=h2(this.defaults,e)).baseURL,e.url),e.params,e.paramsSerializer)}}b1.forEach(["delete","get","head","options"],(function(e){W2.prototype[e]=function(t,n){return this.request(h2(n||{},{method:e,url:t,data:(n||{}).data}))}})),b1.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,a){return this.request(h2(a||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}W2.prototype[e]=t(),W2.prototype[e+"Form"]=t(!0)}));const U2=W2;class V2{constructor(e){if("function"!==typeof e)throw new TypeError("executor must be a function.");let t;this.promise=new Promise((function(e){t=e}));const n=this;this.promise.then((e=>{if(!n._listeners)return;let t=n._listeners.length;for(;t-- >0;)n._listeners[t](e);n._listeners=null})),this.promise.then=e=>{let t;const r=new Promise((e=>{n.subscribe(e),t=e})).then(e);return r.cancel=function(){n.unsubscribe(t)},r},e((function(e,r,a){n.reason||(n.reason=new n2(e,r,a),t(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}toAbortSignal(){const e=new AbortController,t=t=>{e.abort(t)};return this.subscribe(t),e.signal.unsubscribe=()=>this.unsubscribe(t),e.signal}static source(){let e;return{token:new V2((function(t){e=t})),cancel:e}}}const G2=V2;const H2={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(H2).forEach((e=>{let[t,n]=e;H2[n]=t}));const j2=H2;const q2=function e(t){const n=new U2(t),r=R0(U2.prototype.request,n);return b1.extend(r,U2.prototype,n,{allOwnKeys:!0}),b1.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(h2(t,n))},r}(H1);q2.Axios=U2,q2.CanceledError=n2,q2.CancelToken=G2,q2.isCancel=e2,q2.VERSION=O2,q2.toFormData=_1,q2.AxiosError=k1,q2.Cancel=q2.CanceledError,q2.all=function(e){return Promise.all(e)},q2.spread=function(e){return function(t){return e.apply(null,t)}},q2.isAxiosError=function(e){return b1.isObject(e)&&!0===e.isAxiosError},q2.mergeConfig=h2,q2.AxiosHeaders=J1,q2.formToJSON=e=>V1(b1.isHTMLForm(e)?new FormData(e):e),q2.getAdapter=F2,q2.HttpStatusCode=j2,q2.default=q2;const K2=q2,X2={s:"size_s",m:"size_m",l:"size_l"},Y2=e=>{const{text:t,type:n,className:r,align:a="start",size:o="m",max:l}=e,u=[n,r,X2[o],a],d={max:l};return(0,s.jsx)("div",{className:i("text_box",d,u),children:t})},Q2=(0,t.memo)((e=>{const{Svg:t,width:n="46px",height:r="46px",color:a="accent"}=e;return(0,s.jsx)("div",{style:{width:n,height:r},className:i("SvgContainer",{},[a]),children:(0,s.jsx)(t,{className:"Svg",width:n,height:r})})}));var J2;function Z2(){return Z2=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Z2.apply(null,arguments)}function e3(e,n){let{title:r,titleId:a,...i}=e;return t.createElement("svg",Z2({fill:"currentColor",height:"800px",width:"800px",id:"Capa_1",xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink",viewBox:"0 0 487 487",xmlSpace:"preserve",ref:n,"aria-labelledby":a},i),r?t.createElement("title",{id:a},r):null,J2||(J2=t.createElement("g",null,t.createElement("g",null,t.createElement("path",{d:"M308.1,277.95c0,35.7-28.9,64.6-64.6,64.6s-64.6-28.9-64.6-64.6s28.9-64.6,64.6-64.6S308.1,242.25,308.1,277.95z  M440.3,116.05c25.8,0,46.7,20.9,46.7,46.7v122.4v103.8c0,27.5-22.3,49.8-49.8,49.8H49.8c-27.5,0-49.8-22.3-49.8-49.8v-103.9 v-122.3l0,0c0-25.8,20.9-46.7,46.7-46.7h93.4l4.4-18.6c6.7-28.8,32.4-49.2,62-49.2h74.1c29.6,0,55.3,20.4,62,49.2l4.3,18.6H440.3z  M97.4,183.45c0-12.9-10.5-23.4-23.4-23.4c-13,0-23.5,10.5-23.5,23.4s10.5,23.4,23.4,23.4C86.9,206.95,97.4,196.45,97.4,183.45z  M358.7,277.95c0-63.6-51.6-115.2-115.2-115.2s-115.2,51.6-115.2,115.2s51.6,115.2,115.2,115.2S358.7,341.55,358.7,277.95z"})))))}const t3=t.forwardRef(e3);n.p;var n3;function r3(){return r3=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},r3.apply(null,arguments)}function a3(e,n){let{title:r,titleId:a,...i}=e;return t.createElement("svg",r3({xmlns:"http://www.w3.org/2000/svg",width:7,height:12,fill:"none",viewBox:"0 0 7 12",className:"p_ZQ v61B",ref:n,"aria-labelledby":a},i),r?t.createElement("title",{id:a},r):null,n3||(n3=t.createElement("path",{stroke:"currentColor",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"m1 1 5 5-5 5"})))}const i3=t.forwardRef(a3),s3=(n.p,{start:"justifyStart",center:"justifyCenter",end:"justifyEnd",between:"justifyBetween",around:"justifyAround"}),o3={start:"alignStart",center:"alignCenter",end:"alignEnd"},l3={5:"gap5",10:"gap10",15:"gap15",25:"gap25",30:"gap30"},u3=e=>{const{className:t,children:n,justify:r="start",align:a="center",wrap:o="nowrap",gap:l,max:u,...d}=e,c=[t,s3[r],o3[a],o,l&&l3[l]],p={max:u};return(0,s.jsx)("div",{className:i("HStack",p,c),...d,children:n})},d3=e=>{const{children:t,max:n,isHide:r=!1}=e,a={max:n,hide:r};return(0,s.jsx)("div",{className:i("common_section",a,[]),children:t})},c3={start:"justifyStart",center:"justifyCenter",end:"justifyEnd",between:"justifyBetween"},p3={start:"alignStart",center:"alignCenter",end:"alignEnd"},h3={5:"gap5",10:"gap10",15:"gap15",25:"gap25",30:"gap30"},f3=e=>{const{className:t,children:n,justify:r="start",align:a="center",wrap:o="nowrap",gap:l,max:u,...d}=e,c=[t,c3[r],p3[a],o,l&&h3[l]],p={max:u};return(0,s.jsx)("div",{className:i("VStack",p,c),...d,children:n})},m3=e=>{const{onClick:t,text:n,disabled:r,width:a,max:o}=e,l={disabled:r,max:o};return(0,s.jsx)("div",{style:{width:a},className:i("button",l,[]),onClick:t,children:n})};const g3=function(){const e=(0,t.useRef)(null),n=(0,t.useRef)(null),r=(0,t.useRef)(null),[i,d]=(0,t.useState)(!1),[c,p]=(0,t.useState)(null),[h,f]=(0,t.useState)(null),[m,g]=(0,t.useState)(null),{isCameraOn:y,startCamera:b,stopCamera:v}=((e,n,r,a,i)=>{const[s,o]=(0,t.useState)(!1),l=()=>{if(a.current&&r.current){const t=a.current,n=t.getContext("2d");if(n)return t.width=r.current.videoWidth,t.height=r.current.videoHeight,n.drawImage(r.current,0,0,t.width,t.height),void e(t.toDataURL("image/jpeg"))}e(null)};return{isCameraOn:s,startCamera:async()=>{(async()=>{try{const t=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}});i.current=t,r.current&&(r.current.srcObject=t),o(!0),e(null),n(null)}catch(t){n("\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043a\u0430\u043c\u0435\u0440\u0435"),console.error(t)}})()},stopCamera:()=>{l(),i.current&&i.current.getTracks().forEach((e=>e.stop())),o(!1)}}})(f,g,e,n,r),{isFaceDetected:x}=$0(y,e,n);return(0,t.useEffect)((()=>{var e;const t=new URLSearchParams(window.location.search),n=JSON.parse(decodeURIComponent(null!==(e=null===t||void 0===t?void 0:t.get("data"))&&void 0!==e?e:"{}"));p(n);const r="Telegram"in window?window.Telegram:void 0;null===r||void 0===r||r.WebApp.ready(),null===r||void 0===r||r.WebApp.expand()}),[]),(0,s.jsxs)(f3,{className:"app",children:[(0,s.jsxs)(d3,{max:!0,isHide:!(!h&&!y),children:[(0,s.jsxs)(o,{children:[(0,s.jsx)(Y2,{text:"\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f",type:"hint",align:"start",max:!0}),(0,s.jsxs)(f3,{gap:"15",style:{padding:"56px 78px"},children:[(0,s.jsx)("tgs-player",{style:{width:"130px",height:"130px"},width:"200px",autoplay:!0,loop:!0,mode:"normal",src:"https://data.chpic.su/stickers/u/UtyaDuck/UtyaDuck_005.tgs",id:"tgsPlayer__main__UtyaDuck"}),(0,s.jsx)(Y2,{text:"\u041a\u0430\u043c\u0435\u0440\u0430 \u0432\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u0430",type:"text",align:"center",size:"l",max:!0}),(0,s.jsx)(Y2,{text:"\u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043d\u0430 \u043a\u043d\u043e\u043f\u043a\u0443 \u043d\u0438\u0436\u0435 \u0438 \u0440\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u0435 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u043a\u0430\u043c\u0435\u0440\u0435",type:"text",align:"center",max:!0})]})]}),(0,s.jsx)(o,{clickable:!0,max:!0,onClick:b,children:(0,s.jsxs)(u3,{gap:"10",max:!0,children:[(0,s.jsx)(Q2,{Svg:t3}),(0,s.jsx)(Y2,{text:"\u0412\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u0430\u043c\u0435\u0440\u0443",type:"text",max:!0}),(0,s.jsx)(Q2,{width:"12px",height:"12px",color:"subtitle",Svg:i3})]})})]}),(0,s.jsxs)(d3,{max:!0,isHide:!y,children:[(0,s.jsx)(l,{isFaceDetected:x,videoRef:e,isShow:y,canvasRef:n}),(0,s.jsx)(o,{max:!0,children:(0,s.jsx)(u3,{max:!0,children:(0,s.jsx)(Y2,{text:"\u041f\u0440\u043e\u0439\u0434\u0438\u0442\u0435 \u0444\u043e\u0442\u043e\u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c \u0434\u043b\u044f \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438. \u041d\u0430 \u0444\u043e\u0442\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u043e\u0442\u0447\u0435\u0442\u043b\u0438\u0432\u043e \u0432\u0438\u0434\u043d\u043e \u0432\u0430\u0448\u0435 \u043b\u0438\u0446\u043e",type:"text",max:!0})})}),(0,s.jsx)(o,{clickable:!0,max:!0,onClick:v,disabled:!x,children:(0,s.jsxs)(u3,{gap:"10",max:!0,children:[(0,s.jsx)(Q2,{Svg:t3}),(0,s.jsx)(Y2,{text:"\u0421\u0434\u0435\u043b\u0430\u0442\u044c \u0444\u043e\u0442\u043e",type:"text",max:!0}),(0,s.jsx)(Q2,{width:"12px",height:"12px",color:"subtitle",Svg:i3})]})})]}),h&&(0,s.jsxs)(f3,{max:!0,gap:"15",children:[(0,s.jsx)(u,{photoUrl:h}),(0,s.jsx)(m3,{width:"calc(100% - 20px)",onClick:b,text:"\u041f\u0435\u0440\u0435\u0441\u043d\u044f\u0442\u044c \u0444\u043e\u0442\u043e",disabled:i}),(0,s.jsx)(m3,{width:"calc(100% - 20px)",onClick:()=>{const e="Telegram"in window?window.Telegram:void 0;if("registration"===(null===c||void 0===c?void 0:c.type))if(e){var t,n,r;if(!h)return void g("\u0424\u043e\u0442\u043e \u043d\u0435 \u0441\u0434\u0435\u043b\u0430\u043d\u043e! \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430.");const e=a(h,"image/jpeg"),i=new FormData,s={userPhone:null!==(t=null===c||void 0===c?void 0:c.userPhone)&&void 0!==t?t:"",userId:null!==(n=null===c||void 0===c?void 0:c.userId)&&void 0!==n?n:"",isSavePhoto:null!==(r=null===c||void 0===c?void 0:c.isSavePhoto)&&void 0!==r?r:"0",photo:e};i.append("userPhone",s.userPhone),i.append("userId",s.userId),i.append("photo",s.photo),i.append("isSavePhoto",s.isSavePhoto),d(!0),((e,t,n)=>{const r="Telegram"in window?window.Telegram:void 0;r&&K2.post("http://localhost:5000/api/users/registration",e).then((e=>{t(!1);const a=e.data;switch(a.status){case 0:case 1:r.WebApp.sendData(JSON.stringify(a));break;case 2:n("\u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.");break;default:n("\u041e\u0448\u0438\u0431\u043a\u0430. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u043f\u043e\u0437\u0436\u0435."),console.warn("Unexpected response:",a)}})).catch((e=>{t(!1),n("\u041e\u0448\u0438\u0431\u043a\u0430. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u043f\u043e\u0437\u0436\u0435."),r.WebApp.sendData(JSON.stringify({result:"server_error"}))}))})(i,d,g)}else g("\u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0431\u044b\u043b\u043e \u043e\u0442\u043a\u0440\u044b\u0442\u043e \u041d\u0415 \u0432 \u0422\u0435\u043b\u0435\u0433\u0440\u0430\u043c\u043c\u0435");else if("identification"===(null===c||void 0===c?void 0:c.type))if(e){var i;if(!h)return void g("\u0424\u043e\u0442\u043e \u043d\u0435 \u0441\u0434\u0435\u043b\u0430\u043d\u043e! \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430.");const e=a(h,"image/jpeg"),t=new FormData,n={userId:null!==(i=null===c||void 0===c?void 0:c.userId)&&void 0!==i?i:"",photo:e};t.append("userId",n.userId),t.append("photo",n.photo),d(!0),((e,t,n)=>{const r="Telegram"in window?window.Telegram:void 0;r&&K2.post("http://localhost:5000/api/embeddings/identification",e).then((e=>{t(!1);const a=e.data;switch(a.status){case 0:case 1:r.WebApp.sendData(JSON.stringify(a));break;case 2:n("\u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.");break;default:n("\u041e\u0448\u0438\u0431\u043a\u0430. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u043f\u043e\u0437\u0436\u0435."),console.warn("Unexpected response:",a)}})).catch((e=>{let n;t(!1),e.response?(n=e.response.data,r.WebApp.sendData(JSON.stringify(n))):(n={status:2,text:"server_error"},r.WebApp.sendData(JSON.stringify(n)))}))})(t,d,g)}else g("\u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0431\u044b\u043b\u043e \u043e\u0442\u043a\u0440\u044b\u0442\u043e \u041d\u0415 \u0432 \u0422\u0435\u043b\u0435\u0433\u0440\u0430\u043c\u043c\u0435")},text:"\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0444\u043e\u0442\u043e",disabled:i})]}),(0,s.jsx)("canvas",{ref:n,style:{display:"none"}})]})};r.createRoot(document.getElementById("root")).render((0,s.jsx)(t.StrictMode,{children:(0,s.jsx)(g3,{})}))})()})();
//# sourceMappingURL=main.311e6a28.js.map