{"version":3,"file":"static/js/485.a4c0cdf8.chunk.js","mappings":"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","sources":["shared/ui/Button/Button.tsx","utils/photoUtils.ts","api/user/registration.ts","components/PhotoSendSection/PhotoSendSection.tsx","api/user/identification.ts"],"sourcesContent":["import React from \"react\";\r\nimport './Button.css'\r\nimport {classNames, Mods} from \"../../../lib/classNames/classNames\";\r\n\r\ninterface ButtonProps {\r\n    onClick: () => void;\r\n    text: string,\r\n    disabled: boolean,\r\n    width?: string,\r\n    max?: boolean,\r\n}\r\n\r\nexport const Button: React.FC<ButtonProps> = (props) => {\r\n    const {\r\n        onClick,\r\n        text,\r\n        disabled,\r\n        width,\r\n        max,\r\n    } = props\r\n\r\n    const mods: Mods = {\r\n        'disabled': disabled,\r\n        'max': max,\r\n    }\r\n\r\n    return (\r\n        <div\r\n            style={{width:width}}\r\n            className={classNames('button', mods, [])}\r\n            onClick={onClick}\r\n        >\r\n            {text}\r\n        </div>\r\n    );\r\n};\r\n","// Функция для конвертации строки в формате base64 в объект Blob с заданным типом MIME\r\nexport const base64ToBlob = (base64: string, mimeType: string): Blob => {\r\n    // Шаг 1: Удаляем префикс \"data:image/jpeg;base64,\" из строки base64 (если он присутствует)\r\n    const byteString = atob(base64.split(\",\")[1]);\r\n    // atob() - это встроенная функция JavaScript, которая декодирует строку из формата base64 в обычную строку (ASCII).\r\n\r\n    // Шаг 2: Создаем ArrayBuffer для хранения бинарных данных\r\n    const arrayBuffer = new ArrayBuffer(byteString.length); // ArrayBuffer — это объект, представляющий низкоуровневые данные в бинарном формате.\r\n    const uint8Array = new Uint8Array(arrayBuffer); // Uint8Array — это тип данных, представляющий массив 8-битных целых чисел (от 0 до 255).\r\n\r\n    // Шаг 3: Заполняем массив uint8Array значениями из строки byteString\r\n    // Каждому символу строки byteString соответствует один байт, который добавляется в массив uint8Array.\r\n    for (let i = 0; i < byteString.length; i++) {\r\n        uint8Array[i] = byteString.charCodeAt(i); // charCodeAt(i) — метод, который возвращает код символа в строке на позиции i.\r\n    }\r\n\r\n    // Шаг 4: Создаем объект Blob из массива uint8Array с заданным MIME-типом\r\n    // Blob — это объект, представляющий данные, которые могут быть файлами или другими бинарными данными.\r\n    return new Blob([uint8Array], { type: mimeType });\r\n};\r\n","import axios from 'axios';\r\nimport {InterfaceResponse, Telegram} from \"../../types/type\";\r\n\r\n// Берем URL API из переменной окружения\r\nconst URL = process.env.REACT_APP_API_URL\r\n\r\n// Определяем интерфейс для данных, которые мы добавляем в FormData\r\nexport interface FormDataRegistration {\r\n    userPhone: string;\r\n    userId: string;\r\n    photo: Blob;\r\n    isSavePhoto: '0' | '1';\r\n}\r\n\r\n// Тип, который перечисляет все возможные значения для поля text\r\ntype RegistrationResponseText =\r\n    | \"missing_photo\"\r\n    | \"missing_user_id\"\r\n    | \"missing_user_phone\"\r\n    | \"user_exist_number\"\r\n    | \"user_exist_id\"\r\n    | \"face_not_found\"\r\n    | \"user_exist_face\"\r\n    | \"success\"\r\n    | \"server_error\";\r\n\r\n// Интерфейс для ответа от сервера\r\ntype RegistrationResponse = InterfaceResponse<RegistrationResponseText>;\r\n\r\nexport const registration=(\r\n    data: FormData,// Данные для регистрации\r\n    setIsFetching: (val: boolean) => void, // Функция для управления состоянием загрузки\r\n    setError: (error: string | null) => void,// Функция для отображения ошибок\r\n) => {\r\n    const tg: Telegram | undefined = 'Telegram' in window ? window.Telegram as Telegram : undefined;\r\n    if (tg) {\r\n        axios\r\n            .post<RegistrationResponse>(`${URL}api/users/registration`, data)\r\n            .then(res => {\r\n                // Завершаем загрузку\r\n                setIsFetching(false);\r\n                const result = res.data;\r\n\r\n                // Обрабатываем ответ от сервера\r\n                switch (result.status) {\r\n                    case 0: // Пользователь существует\r\n                    case 1: // Успешная регистрация\r\n                        tg.WebApp.sendData(JSON.stringify(result));\r\n                        break;\r\n\r\n                    case 2: // Ошибки валидации или системная ошибка\r\n                        setError('Попробуйте еще раз.'); // Устанавливаем текст ошибки для отображения\r\n                        break;\r\n\r\n                    default: // Непредвиденный статус\r\n                        setError(\"Ошибка. Пожалуйста, попробуйте позже.\");\r\n                        console.warn(\"Unexpected response:\", result);\r\n                        break;\r\n                }\r\n\r\n            })\r\n            .catch(err => {\r\n                setIsFetching(false);// Завершаем загрузку\r\n                setError(\"Ошибка. Пожалуйста, попробуйте позже.\"); // Показываем общее сообщение об ошибке\r\n\r\n                tg.WebApp.sendData(JSON.stringify({result: 'server_error'}));\r\n\r\n            })\r\n    }\r\n}\r\n","import React, {useState} from \"react\";\r\nimport './PhotoSendSection.css'\r\nimport {Button} from \"../../shared/ui/Button/Button\";\r\nimport {REMAKE_PHOTO, SEND} from \"../../types/const\";\r\nimport {VStack} from \"../../shared/ui/VStack/VStack\";\r\nimport {base64ToBlob} from \"../../utils/photoUtils\";\r\nimport {FormDataRegistration, registration} from \"../../api/user/registration\";\r\nimport {FormDataCheckExist, identification} from \"../../api/user/identification\";\r\n\r\ninterface ImgProps {\r\n    photoUrl: string | null;\r\n    setIsCameraOn:any,\r\n    params:any,\r\n    setError:any,\r\n}\r\n\r\nconst PhotoSendSection: React.FC<ImgProps> = ({photoUrl,\r\n                                                  setIsCameraOn,\r\n                                                  params,\r\n                                                  setError,\r\n                                              }) => {\r\n\r\n    const [isFetching, setIsFetching] = useState(false); // Флаг состояния загрузки\r\n\r\n    const handleSendPhoto = () => {\r\n        const tg: any = 'Telegram' in window ? window.Telegram : undefined;\r\n        if (params?.type === 'registration') {\r\n            // Логика для регистрации\r\n            if (tg) {\r\n\r\n\r\n                if (!photoUrl) {\r\n                    setError(\"Фото не сделано! Попробуйте снова.\");\r\n                    return;\r\n                }\r\n\r\n                const blob = base64ToBlob(photoUrl, \"image/jpeg\");\r\n\r\n                // Создаем formData для отправки медиа\r\n                const formData = new FormData();\r\n\r\n                const data: FormDataRegistration = {\r\n                    userPhone: params?.userPhone ?? '',\r\n                    userId: params?.userId ?? '',\r\n                    isSavePhoto: params?.isSavePhoto ?? '0',\r\n                    photo: blob\r\n                }\r\n\r\n                formData.append('userPhone', data.userPhone);\r\n                formData.append('userId', data.userId);\r\n                formData.append('photo', data.photo);\r\n                formData.append('isSavePhoto', data.isSavePhoto);\r\n\r\n                setIsFetching(true)\r\n\r\n                registration(\r\n                    formData,\r\n                    setIsFetching,\r\n                    setError,\r\n                )\r\n            } else {\r\n\r\n                setError(\"Приложение было открыто НЕ в Телеграмме\");\r\n            }\r\n        } else if (params?.type === 'identification') {\r\n            // Логика для идентификации\r\n            if (tg) {\r\n\r\n                if (!photoUrl) {\r\n                    setError(\"Фото не сделано! Попробуйте снова.\");\r\n                    return;\r\n                }\r\n\r\n                const blob = base64ToBlob(photoUrl, \"image/jpeg\");\r\n\r\n                const formData = new FormData();\r\n\r\n                const data: FormDataCheckExist = {\r\n                    userId: params?.userId ?? '',\r\n                    photo: blob\r\n                }\r\n\r\n                formData.append('userId', data.userId);\r\n                formData.append('photo', data.photo);\r\n\r\n                setIsFetching(true)\r\n\r\n                identification(\r\n                    formData,\r\n                    setIsFetching,\r\n                    setError,\r\n                )\r\n            } else {\r\n                setError(\"Приложение было открыто НЕ в Телеграмме\");\r\n            }\r\n        }\r\n    };\r\n\r\n    if (!photoUrl) {\r\n        return <></>\r\n    }\r\n    return (\r\n        <VStack\r\n            max\r\n            gap={'15'}\r\n        >\r\n        <div\r\n            className={`img_box`}\r\n        >\r\n            <img\r\n                className=\"img\"\r\n                src={photoUrl ?? ''}\r\n                alt=\"Сделанное фото\"\r\n            />\r\n        </div>\r\n            <Button\r\n                width={'calc(100% - 20px)'}\r\n                onClick={()=>setIsCameraOn(true)}\r\n                text={REMAKE_PHOTO}\r\n                disabled={isFetching}\r\n            />\r\n            <Button\r\n                width={'calc(100% - 20px)'}\r\n                onClick={handleSendPhoto}\r\n                text={SEND}\r\n                disabled={isFetching}\r\n            />\r\n\r\n\r\n        </VStack>\r\n    );\r\n};\r\nexport default PhotoSendSection\r\n","import axios from 'axios';\r\nimport {InterfaceResponse, Telegram} from \"../../types/type\";\r\n\r\n// Берем URL API из переменной окружения\r\nconst URL = process.env.REACT_APP_API_URL\r\n\r\n// Определяем интерфейс для данных, которые мы добавляем в FormData\r\nexport interface FormDataCheckExist {\r\n    userId: string;\r\n    photo: Blob\r\n}\r\n\r\n// Тип, который перечисляет все возможные значения для поля text\r\ntype IdentificationResponseText =\r\n    | \"missing_photo\"  // Ошибка: нет фото\r\n    | \"missing_user_id\"  // Ошибка: нет userId\r\n    | \"face_not_found\"  // Ошибка: лицо не найдено на изображении\r\n    | \"embedding_not_found\"  // Ошибка: эмбеддинг не найден в базе\r\n    | \"similarity_not_confirmed\"  // Ошибка: сходство не подтверждено\r\n    | \"success\"  // Успех: верификация прошла успешно\r\n    | \"server_error\";  // Ошибка сервера\r\n\r\n// Интерфейс для ответа от сервера\r\ntype IdentificationResponse = InterfaceResponse<IdentificationResponseText>;\r\n\r\nexport const identification = (\r\n    data: FormData,// Данные для идентификации\r\n    setIsFetching: (val: boolean) => void, // Функция для управления состоянием загрузки\r\n    setError: (error: string | null) => void,// Функция для отображения ошибок\r\n) => {\r\n    const tg: Telegram | undefined = 'Telegram' in window ? window.Telegram as Telegram : undefined;\r\n    if (tg) {\r\n        axios\r\n            .post<IdentificationResponse>(`${URL}api/embeddings/identification`, data)\r\n            .then(res => {\r\n                // Завершаем загрузку\r\n                setIsFetching(false);\r\n                const result = res.data;\r\n\r\n                // Обрабатываем ответ от сервера\r\n                // Обрабатываем ответ от сервера\r\n                switch (result.status) {\r\n                    case 0: // Эмбеддинг для пользователя не найден в базе ИЛИ найден, но не совпал\r\n                    case 1: // Успешно пройдена\r\n                        tg.WebApp.sendData(JSON.stringify(result));\r\n                        break;\r\n\r\n                    case 2: // Ошибки валидации или системная ошибка\r\n                        setError('Попробуйте еще раз.'); // Устанавливаем текст ошибки для отображения\r\n                        break;\r\n\r\n                    default: // Непредвиденный статус\r\n                        setError(\"Ошибка. Пожалуйста, попробуйте позже.\");\r\n                        console.warn(\"Unexpected response:\", result);\r\n                        break;\r\n                }\r\n\r\n            })\r\n            .catch(err => {\r\n                setIsFetching(false);// Завершаем загрузку\r\n\r\n                let response: IdentificationResponse\r\n                // Проверяем, есть ли ответ от сервера\r\n                if (err.response) {\r\n                    response = err.response.data as IdentificationResponse;\r\n                    tg.WebApp.sendData(JSON.stringify(response)); // Отправляем данные из ответа\r\n                } else {\r\n                    // Общая ошибка (например, сеть недоступна)\r\n                    response = {status: 2, text: \"server_error\"}\r\n                    tg.WebApp.sendData(JSON.stringify(response));\r\n                }\r\n            })\r\n    }\r\n}\r\n"],"names":["Button","props","onClick","text","disabled","width","max","mods","_jsx","style","className","classNames","children","base64ToBlob","base64","mimeType","byteString","atob","split","arrayBuffer","ArrayBuffer","length","uint8Array","Uint8Array","i","charCodeAt","Blob","type","_ref","photoUrl","setIsCameraOn","params","setError","isFetching","setIsFetching","useState","_jsxs","VStack","gap","src","alt","REMAKE_PHOTO","handleSendPhoto","tg","window","Telegram","undefined","_params$userPhone","_params$userId","_params$isSavePhoto","blob","formData","FormData","data","userPhone","userId","isSavePhoto","photo","append","registration","axios","post","then","res","result","status","WebApp","sendData","JSON","stringify","console","warn","catch","err","_params$userId2","identification","response","SEND","_Fragment"],"sourceRoot":""}