{"version":3,"file":"static/js/119.2f8e54d7.chunk.js","mappings":"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","sources":["shared/assets/svg/Camea.svg","utils/faceUtils.ts","hooks/useFaceDetection.ts","components/CameraSection/CameraSection.tsx","shared/ui/Button/Button.tsx","utils/photoUtils.ts","api/user/registration.ts","components/PhotoSendSection/PhotoSendSection.tsx","api/user/identification.ts","components/Photo/Photo.tsx","shared/ui/CommonSection/CommonSection.tsx","shared/ui/HStack/HStack.tsx","shared/ui/Section/Section.tsx","shared/ui/Svg/Svg.tsx","shared/ui/Text/Text.tsx","types/const.ts","shared/assets/svg/Arrow.svg"],"sourcesContent":["var _g;\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nimport * as React from \"react\";\nfunction SvgCamea(_ref, svgRef) {\n  let {\n    title,\n    titleId,\n    ...props\n  } = _ref;\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    fill: \"currentColor\",\n    height: \"800px\",\n    width: \"800px\",\n    id: \"Capa_1\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    viewBox: \"0 0 487 487\",\n    xmlSpace: \"preserve\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _g || (_g = /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M308.1,277.95c0,35.7-28.9,64.6-64.6,64.6s-64.6-28.9-64.6-64.6s28.9-64.6,64.6-64.6S308.1,242.25,308.1,277.95z  M440.3,116.05c25.8,0,46.7,20.9,46.7,46.7v122.4v103.8c0,27.5-22.3,49.8-49.8,49.8H49.8c-27.5,0-49.8-22.3-49.8-49.8v-103.9 v-122.3l0,0c0-25.8,20.9-46.7,46.7-46.7h93.4l4.4-18.6c6.7-28.8,32.4-49.2,62-49.2h74.1c29.6,0,55.3,20.4,62,49.2l4.3,18.6H440.3z  M97.4,183.45c0-12.9-10.5-23.4-23.4-23.4c-13,0-23.5,10.5-23.5,23.4s10.5,23.4,23.4,23.4C86.9,206.95,97.4,196.45,97.4,183.45z  M358.7,277.95c0-63.6-51.6-115.2-115.2-115.2s-115.2,51.6-115.2,115.2s51.6,115.2,115.2,115.2S358.7,341.55,358.7,277.95z\"\n  })))));\n}\nconst ForwardRef = /*#__PURE__*/React.forwardRef(SvgCamea);\nexport default __webpack_public_path__ + \"static/media/Camea.9f20b0db6505e8b7520a0e6122529d24.svg\";\nexport { ForwardRef as ReactComponent };","export interface Circle {\r\n    cx: number; // Координата X центра круга\r\n    cy: number; // Координата Y центра круга\r\n    r: number;  // Радиус круга\r\n}\r\n\r\nexport interface Rectangle {\r\n    x: number;     // Координата X верхнего левого угла прямоугольника\r\n    y: number;     // Координата Y верхнего левого угла прямоугольника\r\n    width: number; // Ширина прямоугольника\r\n    height: number; // Высота прямоугольника\r\n}\r\n\r\n// Функция для проверки, перекрывает ли прямоугольник круг, с учетом порогового значения (threshold)\r\nexport function isRectangleCoveredByCircle(circle: Circle, rect: Rectangle, threshold = 0.8): boolean {\r\n\r\n    // Вычисляем площадь прямоугольника\r\n    const rectArea = rect.width * rect.height;\r\n    // Вычисляем площадь круга\r\n    const circleArea = Math.PI * circle.r * circle.r;\r\n\r\n    // Проверяем, чтобы прямоугольник не был слишком маленьким ( в 5 раз и более)\r\n    if (rectArea*5 < circleArea) {\r\n        return false;\r\n    }\r\n\r\n    // Вычисляем площадь пересечения прямоугольника и круга\r\n    const intersectionArea = calculateIntersectionArea(circle, rect);\r\n\r\n    // Рассчитываем долю пересекающейся площади (отношение площади пересечения к площади прямоугольника)\r\n    const overlapRatio = intersectionArea / rectArea;\r\n\r\n    // Координаты центра прямоугольника\r\n    const rectCenterX = rect.x + rect.width / 2; // Центр прямоугольника по оси X\r\n    const rectCenterY = rect.y + rect.height / 2; // Центр прямоугольника по оси Y\r\n\r\n    // Проверяем, находится ли центр прямоугольника внутри круга\r\n    const dx = rectCenterX - circle.cx; // Расстояние по оси X от центра прямоугольника до центра круга\r\n    const dy = rectCenterY - circle.cy; // Расстояние по оси Y от центра прямоугольника до центра круга\r\n    const distanceSquared = dx * dx + dy * dy; // Квадрат расстояния между центрами прямоугольника и круга\r\n\r\n    // Проверка, лежит ли центр прямоугольника внутри круга (по формуле расстояния между точками)\r\n    const isCenterInsideCircle = distanceSquared <= circle.r * circle.r;\r\n\r\n    // Проверка, лежит ли центр прямоугольника в пределах маленького радиуса (для дополнительной проверки)\r\n    const smallR = circle.r / 4; // Маленький радиус (четверть от радиуса круга)\r\n    const isCenterWithinSmallRadius = distanceSquared <= (smallR) * (circle.r / 2); // Проверяем, лежит ли центр внутри маленького круга\r\n\r\n    // Возвращаем true, если доля пересечения больше порогового значения, центр прямоугольника внутри круга\r\n    // и центр прямоугольника находится в пределах маленького радиуса\r\n    return overlapRatio >= threshold && isCenterInsideCircle && isCenterWithinSmallRadius;\r\n}\r\n\r\n// Функция для вычисления площади пересечения круга и прямоугольника\r\nfunction calculateIntersectionArea(circle: Circle, rect: Rectangle): number {\r\n    const { cx, cy, r } = circle; // Извлекаем параметры круга\r\n    const { x, y, width, height } = rect; // Извлекаем параметры прямоугольника\r\n\r\n    // Шаг для численного расчета площади пересечения (меньший шаг - более точный расчет)\r\n    const step = Math.min(width, height) / 100;\r\n    let intersectionArea = 0;// Переменная для хранения площади пересечения\r\n\r\n    // Перебираем все точки внутри прямоугольника с шагом step по осям X и Y\r\n    for (let px = x; px <= x + width; px += step) {\r\n        for (let py = y; py <= y + height; py += step) {\r\n            // Проверяем, находится ли точка внутри круга\r\n            const dx = px - cx; // Расстояние по оси X от точки до центра круга\r\n            const dy = py - cy; // Расстояние по оси Y от точки до центра круга\r\n            if (dx * dx + dy * dy <= r * r) {\r\n                // Если точка лежит внутри круга, увеличиваем площадь пересечения\r\n                intersectionArea += step * step; // Добавляем площадь соответствующего квадрата\r\n            }\r\n        }\r\n    }\r\n    // Возвращаем вычисленную площадь пересечения\r\n    return intersectionArea;\r\n}\r\n","import {useState, useEffect} from \"react\";\r\nimport Human, {Config, FaceResult} from \"@vladmandic/human\";\r\nimport {Circle, isRectangleCoveredByCircle, Rectangle} from \"../utils/faceUtils\";\r\n\r\n// Конфигурация для Human\r\nconst config: Partial<Config> = {\r\n    modelBasePath: \"https://cdn.jsdelivr.net/npm/@vladmandic/human/models/\", // Путь к моделям\r\n    face: {\r\n        enabled: true, // Включаем детекцию лиц\r\n        detector: {rotation: false, maxDetected: 1, minConfidence: 0.3}, // Ограничиваем до 1 лица для оптимизации\r\n        mesh: {enabled: false}, // Отключаем 3D-сетку лица, если не нужна\r\n        iris: {enabled: false}, // Отключаем детекцию радужки\r\n        description: {\r\n            enabled: false, // Отключаем анализ лица (возраст, пол и т.д.)\r\n            minConfidence: 0.5// Минимальная уверенность для детекции лица\r\n        },\r\n        emotion: {enabled: false}, // Отключаем анализ эмоций\r\n    },\r\n    body: {enabled: false}, // Отключаем детекцию тела\r\n    hand: {enabled: false}, // Отключаем детекцию рук\r\n    gesture: {enabled: false}, // Отключаем детекцию жестов\r\n    backend: \"webgl\", // Используем WebGL для ускорения (можно заменить на \"wasm\" или \"cpu\")\r\n    cacheSensitivity: 0, // Отключаем кэширование для реального времени\r\n};\r\n\r\n// Интерфейс для размеров\r\ninterface Dimensions {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\n// Интерфейс для масштабированного FaceResult\r\ninterface ScaledFaceResult extends FaceResult {\r\n    box: [number, number, number, number]; // [x, y, width, height]\r\n}\r\n\r\n// Функция масштабирования\r\nfunction resizeResults<T extends FaceResult | FaceResult[]>(\r\n    results: T,\r\n    inputDimensions: Dimensions,\r\n    targetDimensions: Dimensions\r\n): T {\r\n    // Эмулируем inputSize: 416, как в TinyFaceDetector\r\n    const modelInputSize = 416;\r\n    const videoAspectRatio = inputDimensions.width / inputDimensions.height;\r\n    let modelWidth = modelInputSize;\r\n    let modelHeight = modelInputSize;\r\n\r\n    // Сохраняем пропорции видео\r\n    if (videoAspectRatio > 1) {\r\n        modelHeight = modelInputSize / videoAspectRatio;\r\n    } else {\r\n        modelWidth = modelInputSize * videoAspectRatio;\r\n    }\r\n\r\n    // Масштабируем от разрешения видео к modelInputSize\r\n    const scaleXModel = modelWidth / inputDimensions.width;\r\n    const scaleYModel = modelHeight / inputDimensions.height;\r\n\r\n    // Масштабируем от modelInputSize к канвасу\r\n    const scaleXCanvas = targetDimensions.width / modelWidth;\r\n    const scaleYCanvas = targetDimensions.height / modelHeight;\r\n\r\n    const scaleFaceResult = (face: FaceResult): ScaledFaceResult => {\r\n        const [x, y, width, height] = face.box;\r\n        // Сначала масштабируем к modelInputSize\r\n        const modelX = x * scaleXModel;\r\n        const modelY = y * scaleYModel;\r\n        const modelWidthScaled = width * scaleXModel;\r\n        const modelHeightScaled = height * scaleYModel;\r\n        // Затем масштабируем к канвасу\r\n        return {\r\n            ...face,\r\n            box: [\r\n                modelX * scaleXCanvas,\r\n                modelY * scaleYCanvas,\r\n                modelWidthScaled * scaleXCanvas,\r\n                modelHeightScaled * scaleYCanvas,\r\n            ],\r\n        };\r\n    };\r\n\r\n    if (Array.isArray(results)) {\r\n        return results.map(scaleFaceResult) as T;\r\n    }\r\n    return scaleFaceResult(results) as T;\r\n}\r\n\r\nexport const useFaceDetection = (\r\n    isCameraOn: boolean, // Пропс, который говорит, включена ли камера\r\n    videoRef: React.RefObject<HTMLVideoElement>, // Ссылка на элемент video, который будет показывать видео с камеры\r\n    canvasRef: React.RefObject<HTMLCanvasElement>, // Ссылка на элемент canvas, на котором будет отображаться сделанное фото\r\n    videoBorderRef: React.RefObject<HTMLDivElement>,\r\n    isLoaded: boolean,\r\n    setLog: any\r\n) => {\r\n    const [isFaceDetected, setIsFaceDetected] = useState(false);// Состояние для отслеживания, было ли найдено лицо\r\n    const [humanLoaded, setHumanLoaded] = useState(false);\r\n    const [detectionStart, setDetectionStart] = useState(false);\r\n    const [humanInstance, setHumanInstance] = useState<Human | null>(null);\r\n    const [isDraw] = useState(false);// Состояние для отслеживания, загружены ли модели\r\n\r\n// Инициализация Human\r\n    useEffect(() => {\r\n        const initHuman = async () => {\r\n            console.log(\"Начало инициализации Human:\", new Date().toISOString());\r\n            try {\r\n                const human = new Human(config);\r\n                await human.load(); // Загружаем модели\r\n                await human.warmup(); // Прогреваем модель для ускорения первого вызова\r\n                setHumanInstance(human);\r\n                setHumanLoaded(true);\r\n                console.log(\"Human инициализирован:\", new Date().toISOString());\r\n            } catch (error) {\r\n                console.error(\"Ошибка инициализации Human:\", error);\r\n            }\r\n        };\r\n        initHuman();\r\n    }, []);\r\n\r\n    // Детекция лиц\r\n    useEffect(() => {\r\n        let animationFrameId = null;\r\n        let lastDetectionTime = 0;\r\n        const new_log = `${humanLoaded}${isCameraOn}${isLoaded}${Boolean(videoRef.current)}${Boolean(canvasRef.current)}${Boolean(videoBorderRef.current)}${Boolean(humanInstance)}`\r\n\r\n        setLog(new_log)\r\n        if (humanLoaded &&\r\n            isCameraOn &&\r\n            isLoaded &&\r\n            videoRef.current &&\r\n            canvasRef.current &&\r\n            videoBorderRef.current &&\r\n            humanInstance\r\n        ) {\r\n            let i = 0\r\n            const detectFace = async () => {\r\n\r\n                const now = Date.now();\r\n                try {\r\n                    i++\r\n                    let y = i\r\n                    if (videoRef.current && canvasRef.current && videoBorderRef.current) { // Если video и canvas элементы существуют\r\n                        setDetectionStart(true)\r\n                        if (now - lastDetectionTime >= 200) { // Детекция каждые 200 мс\r\n\r\n                            const video = videoRef.current;\r\n                            const canvas = canvasRef.current;\r\n                            const video_border = videoBorderRef.current;\r\n\r\n                            // Настроим размеры канваса, чтобы он соответствовал размеру видео\r\n                            const displaySize = {\r\n                                width: video_border.offsetWidth,\r\n                                height: video_border.offsetHeight\r\n                            };\r\n\r\n                            canvas.width = displaySize.width;\r\n                            canvas.height = displaySize.height;\r\n\r\n                            const inputSize = {\r\n                                width: video.videoWidth,\r\n                                height: video.videoHeight,\r\n                            };\r\n\r\n                            if (!inputSize.width || !inputSize.height) return;\r\n\r\n                            let faces: FaceResult[] = [];\r\n                            const result = await humanInstance.detect(video); // Выполняем детекцию\r\n\r\n                            faces = result.face || []; // Извлекаем массив лиц\r\n                            lastDetectionTime = now;\r\n\r\n                            const resizedFaces = resizeResults(faces, inputSize, displaySize);\r\n\r\n                            let ctx: any = null\r\n                            if (isDraw) {\r\n                                ctx = canvas.getContext('2d');\r\n                                if (!ctx) return\r\n                                ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n                            }\r\n\r\n\r\n                            // Проверяем, попадает ли лицо в оверлей\r\n                            const circle: Circle = {cx: canvas.clientWidth / 2, cy: canvas.clientHeight / 2, r: 150}; // Создаем круг в центре видео с радиусом 150px\r\n\r\n                            let faceDetected = false// Флаг для проверки, было ли найдено лицо в области круга\r\n                            resizedFaces.forEach((face) => {\r\n                                    // Извлекаем координаты bounding box лица\r\n                                    let [x, y, width, height] = face.box;\r\n\r\n                                    const transformedX = canvas.clientWidth - (x + width);\r\n\r\n                                    const rectangle: Rectangle = {x: transformedX, y, width, height}\r\n\r\n                                    faceDetected = isRectangleCoveredByCircle(circle, rectangle, 0.8)\r\n                                    if (isDraw && ctx) {\r\n                                        // Рисуем рамку\r\n                                        ctx.lineWidth = 4;\r\n                                        ctx.lineCap = 'square';\r\n                                        ctx.lineJoin = 'bevel';\r\n                                        ctx.strokeStyle = '#5199d9';\r\n\r\n\r\n                                        //ctx.strokeRect(transformedX, y, width, height);\r\n                                        ctx.strokeRect(transformedX, y, width, height);\r\n                                    }\r\n                                }\r\n                            );\r\n                            setIsFaceDetected(faceDetected);\r\n                            if (isDraw && ctx) {\r\n                                ctx.beginPath();\r\n                                ctx.arc(circle.cx, circle.cy, circle.r, 0, 2 * Math.PI); // Рисуем круг\r\n                                ctx.fillStyle = faceDetected ? 'transparent' : 'transparent'; // Зеленый если лицо внутри круга, красный если нет\r\n                                ctx.fill();\r\n                                ctx.lineWidth = 4;\r\n                                ctx.strokeStyle = faceDetected ? 'green' : 'red';\r\n                                ctx.stroke();\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                } catch (error) {\r\n                    console.error('Ошибка в detectFace:', error);\r\n                } finally {\r\n                    animationFrameId = requestAnimationFrame(detectFace);\r\n                }\r\n            };\r\n            detectFace()\r\n        }\r\n\r\n    }, [humanLoaded, isCameraOn, isLoaded, humanInstance]);\r\n\r\n    return {isFaceDetected, detectionStart};\r\n};\r\n\r\n","import React, {useEffect, useRef, useState} from \"react\";\r\nimport './CameraSection.css'\r\nimport {Section} from \"../../shared/ui/Section/Section\";\r\nimport {HStack} from \"../../shared/ui/HStack/HStack\";\r\nimport {Text} from \"../../shared/ui/Text/Text\";\r\nimport {CAMERA_DESC, TAKE_PHOTO} from \"../../types/const\";\r\nimport {Svg} from \"../../shared/ui/Svg/Svg\";\r\nimport {CommonSection} from \"../../shared/ui/CommonSection/CommonSection\";\r\nimport {ReactComponent as CameraSvg} from '../../shared/assets/svg/Camea.svg'\r\nimport {ReactComponent as ArrowSvg} from '../../shared/assets/svg/Arrow.svg'\r\nimport {useFaceDetection} from \"../../hooks/useFaceDetection\";\r\n\r\n\r\ninterface CameraProps {\r\n    log: string |null,    // Признак, что лицо было обнаружено на видео\r\n    setLog: any,    // Признак, что лицо было обнаружено на видео\r\n\r\n    setPhotoUrl: any, // Функция для установки URL снимка (состояние для изображения)\r\n    setIsCameraOn: any\r\n    isCameraOn: any\r\n}\r\n\r\nconst CameraSection: React.FC<CameraProps> = ({\r\n                                                  setPhotoUrl,\r\n                                                  isCameraOn,\r\n                                                  setIsCameraOn,\r\n                                                  setLog,\r\n                                                  log,\r\n                                              }) => {\r\n    const [isLoaded, setIsLoaded] = useState(false);\r\n    const videoBorderRef = useRef<HTMLDivElement | null>(null); // Ссылка на элемент video, который будет показывать видео с камеры\r\n    const videoRef = useRef<HTMLVideoElement | null>(null); // Ссылка на элемент video, который будет показывать видео с камеры\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null); // Ссылка на элемент canvas, на котором будет отображаться сделанное фото\r\n    const streamRef = useRef<MediaStream | null>(null); // Ссылка на поток видео\r\n\r\n    const {\r\n        isFaceDetected,\r\n        detectionStart\r\n    } = useFaceDetection(isCameraOn, videoRef, canvasRef, videoBorderRef,isLoaded,setLog)\r\n\r\n    useEffect(() => {\r\n        const startVideo = async () => {\r\n            try {\r\n\r\n                // Получаем доступ к камере\r\n                const stream = await navigator.mediaDevices.getUserMedia({\r\n                    video: {facingMode: \"user\"}, // Фронтальная камера\r\n                });\r\n                streamRef.current = stream;\r\n\r\n                if (videoRef.current) {\r\n                    // Привязываем поток\r\n                    videoRef.current.srcObject = stream;\r\n\r\n                    // Обрабатываем событие canplay для уверенности, что видео готово\r\n                    videoRef.current.addEventListener('canplay', () => {\r\n                        // Явно вызываем play для надёжности\r\n                        if (videoRef.current) {\r\n                            videoRef.current.play()\r\n                                .catch(err => {\r\n                                    console.error(`Ошибка воспроизведения видео ${new Date().toLocaleTimeString()}:`, err);\r\n                                    setLog(\"Не удалось воспроизвести видео\");\r\n                                });\r\n                        }\r\n\r\n                    }, {once: true});\r\n\r\n                    videoRef.current.addEventListener('timeupdate', () => {\r\n                        setIsLoaded(true);\r\n                    }, {once: true});\r\n                    setPhotoUrl(null);\r\n                    setLog(null);\r\n                } else {\r\n                    console.warn(\"videoRef не готов\");\r\n                    setLog(\"Ошибка инициализации видео\");\r\n                }\r\n            } catch (err) {\r\n                setLog(\"Ошибка доступа к камере\");\r\n                console.error(\"Ошибка getUserMedia:\", err);\r\n            }\r\n        };\r\n\r\n        startVideo();\r\n\r\n        // Очистка при размонтировании\r\n        return () => {\r\n            if (streamRef.current) {\r\n                streamRef.current.getTracks().forEach(track => track.stop());\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    const takePhoto = () => {\r\n        if (canvasRef.current && videoRef.current) {\r\n            const canvas = canvasRef.current; // Получаем ссылку на канвас\r\n            const context = canvas.getContext(\"2d\"); // Получаем контекст рисования канваса\r\n            if (context) {\r\n                // Устанавливаем размеры канваса, чтобы они соответствовали видео\r\n                canvas.width = videoRef.current.videoWidth;\r\n                canvas.height = videoRef.current.videoHeight;\r\n                // Рисуем изображение с видео на канвасе\r\n                context.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\r\n                // Устанавливаем фото как DataURL с форматом JPEG\r\n                setPhotoUrl(canvas.toDataURL(\"image/jpeg\"));\r\n            } else {\r\n                setPhotoUrl(null) // Если не удалось сделать снимок, сбрасываем URL\r\n                if (streamRef.current) {\r\n\r\n                    // Останавливаем все треки (видео и аудио), связанные с камерой\r\n                    streamRef.current.getTracks().forEach((track: { stop: () => any; }) => track.stop());\r\n                }\r\n            }\r\n        } else {\r\n            setPhotoUrl(null) // Если не удалось сделать снимок, сбрасываем URL\r\n            if (streamRef.current) {\r\n\r\n                // Останавливаем все треки (видео и аудио), связанные с камерой\r\n                streamRef.current.getTracks().forEach((track: { stop: () => any; }) => track.stop());\r\n            }\r\n        }\r\n\r\n        setIsCameraOn(false);\r\n    };\r\n    return (\r\n        <CommonSection\r\n            max\r\n        >\r\n            <Section className={`video_box`}>\r\n\r\n                <video\r\n                    className=\"video_online\"\r\n                    ref={videoRef}\r\n                    playsInline\r\n                    webkit-playsinline=\"true\"\r\n                    muted\r\n                    controls={false}\r\n                />\r\n                <div ref={videoBorderRef} className=\"video_box__wrapper\"/>\r\n                <canvas\r\n                    ref={canvasRef}\r\n                    className={'canvas'}\r\n                />\r\n                {/* Оверлей для отображения информации о распознавании лица */}\r\n                <div\r\n                    className={`face_overlay ${isFaceDetected ? 'ok' : 'err'} ${detectionStart ? 'detection_start' : 'detection_loaded'}`}\r\n\r\n                />\r\n            </Section>\r\n            <Section max>\r\n                <HStack max>\r\n                    <Text\r\n                        text={CAMERA_DESC}\r\n                        type={'text'}\r\n                        max\r\n                    />\r\n                </HStack>\r\n            </Section>\r\n            <Section\r\n                clickable\r\n                max\r\n                onClick={takePhoto}\r\n                disabled={!isFaceDetected}\r\n            >\r\n                <HStack gap={'10'} max>\r\n                    <Svg Svg={CameraSvg}/>\r\n                    <Text\r\n                        text={TAKE_PHOTO}\r\n                        type={'text'}\r\n                        max\r\n                    />\r\n                    <Svg width={'12px'} height={'12px'} color={'subtitle'} Svg={ArrowSvg}/>\r\n                </HStack>\r\n\r\n            </Section>\r\n            {log && <Section\r\n                max\r\n            >\r\n                <HStack gap={'10'} max>\r\n                    <Text\r\n                        text={log}\r\n                        type={'text'}\r\n                        max\r\n                    />\r\n                </HStack>\r\n\r\n            </Section>}\r\n        </CommonSection>\r\n    );\r\n};\r\n\r\nexport default CameraSection\r\n","import React from \"react\";\r\nimport './Button.css'\r\nimport {classNames, Mods} from \"../../../lib/classNames/classNames\";\r\n\r\ninterface ButtonProps {\r\n    onClick: () => void;\r\n    text: string,\r\n    disabled: boolean,\r\n    width?: string,\r\n    max?: boolean,\r\n}\r\n\r\nexport const Button: React.FC<ButtonProps> = (props) => {\r\n    const {\r\n        onClick,\r\n        text,\r\n        disabled,\r\n        width,\r\n        max,\r\n    } = props\r\n\r\n    const mods: Mods = {\r\n        'disabled': disabled,\r\n        'max': max,\r\n    }\r\n\r\n    return (\r\n        <div\r\n            style={{width:width}}\r\n            className={classNames('button', mods, [])}\r\n            onClick={onClick}\r\n        >\r\n            {text}\r\n        </div>\r\n    );\r\n};\r\n","// Функция для конвертации строки в формате base64 в объект Blob с заданным типом MIME\r\nexport const base64ToBlob = (base64: string, mimeType: string): Blob => {\r\n    // Шаг 1: Удаляем префикс \"data:image/jpeg;base64,\" из строки base64 (если он присутствует)\r\n    const byteString = atob(base64.split(\",\")[1]);\r\n    // atob() - это встроенная функция JavaScript, которая декодирует строку из формата base64 в обычную строку (ASCII).\r\n\r\n    // Шаг 2: Создаем ArrayBuffer для хранения бинарных данных\r\n    const arrayBuffer = new ArrayBuffer(byteString.length); // ArrayBuffer — это объект, представляющий низкоуровневые данные в бинарном формате.\r\n    const uint8Array = new Uint8Array(arrayBuffer); // Uint8Array — это тип данных, представляющий массив 8-битных целых чисел (от 0 до 255).\r\n\r\n    // Шаг 3: Заполняем массив uint8Array значениями из строки byteString\r\n    // Каждому символу строки byteString соответствует один байт, который добавляется в массив uint8Array.\r\n    for (let i = 0; i < byteString.length; i++) {\r\n        uint8Array[i] = byteString.charCodeAt(i); // charCodeAt(i) — метод, который возвращает код символа в строке на позиции i.\r\n    }\r\n\r\n    // Шаг 4: Создаем объект Blob из массива uint8Array с заданным MIME-типом\r\n    // Blob — это объект, представляющий данные, которые могут быть файлами или другими бинарными данными.\r\n    return new Blob([uint8Array], { type: mimeType });\r\n};\r\n","import axios from 'axios';\r\nimport {InterfaceResponse, Telegram} from \"../../types/type\";\r\n\r\n// Берем URL API из переменной окружения\r\nconst URL = process.env.REACT_APP_API_URL\r\n\r\n// Определяем интерфейс для данных, которые мы добавляем в FormData\r\nexport interface FormDataRegistration {\r\n    userPhone: string;\r\n    userId: string;\r\n    photo: Blob;\r\n    isSavePhoto: '0' | '1';\r\n}\r\n\r\n// Тип, который перечисляет все возможные значения для поля text\r\ntype RegistrationResponseText =\r\n    | \"missing_photo\"\r\n    | \"missing_user_id\"\r\n    | \"missing_user_phone\"\r\n    | \"user_exist_number\"\r\n    | \"user_exist_id\"\r\n    | \"face_not_found\"\r\n    | \"user_exist_face\"\r\n    | \"success\"\r\n    | \"server_error\";\r\n\r\n// Интерфейс для ответа от сервера\r\ntype RegistrationResponse = InterfaceResponse<RegistrationResponseText>;\r\n\r\nexport const registration=(\r\n    data: FormData,// Данные для регистрации\r\n    setIsFetching: (val: boolean) => void, // Функция для управления состоянием загрузки\r\n    setError: (error: string | null) => void,// Функция для отображения ошибок\r\n) => {\r\n    const tg: Telegram | undefined = 'Telegram' in window ? window.Telegram as Telegram : undefined;\r\n    if (tg) {\r\n        axios\r\n            .post<RegistrationResponse>(`${URL}api/users/registration`, data)\r\n            .then(res => {\r\n                // Завершаем загрузку\r\n                setIsFetching(false);\r\n                const result = res.data;\r\n\r\n                // Обрабатываем ответ от сервера\r\n                switch (result.status) {\r\n                    case 0: // Пользователь существует\r\n                    case 1: // Успешная регистрация\r\n                        tg.WebApp.sendData(JSON.stringify(result));\r\n                        break;\r\n\r\n                    case 2: // Ошибки валидации или системная ошибка\r\n                        setError('Попробуйте еще раз.'); // Устанавливаем текст ошибки для отображения\r\n                        break;\r\n\r\n                    default: // Непредвиденный статус\r\n                        setError(\"Ошибка. Пожалуйста, попробуйте позже.\");\r\n                        console.warn(\"Unexpected response:\", result);\r\n                        break;\r\n                }\r\n\r\n            })\r\n            .catch(err => {\r\n                setIsFetching(false);// Завершаем загрузку\r\n                setError(\"Ошибка. Пожалуйста, попробуйте позже.\"); // Показываем общее сообщение об ошибке\r\n\r\n                tg.WebApp.sendData(JSON.stringify({result: 'server_error'}));\r\n\r\n            })\r\n    }\r\n}\r\n","import React, {useState} from \"react\";\r\nimport './PhotoSendSection.css'\r\nimport {Button} from \"../../shared/ui/Button/Button\";\r\nimport {REMAKE_PHOTO, SEND} from \"../../types/const\";\r\nimport {VStack} from \"../../shared/ui/VStack/VStack\";\r\nimport {base64ToBlob} from \"../../utils/photoUtils\";\r\nimport {FormDataRegistration, registration} from \"../../api/user/registration\";\r\nimport {FormDataCheckExist, identification} from \"../../api/user/identification\";\r\n\r\ninterface ImgProps {\r\n    photoUrl: string | null;\r\n    setIsCameraOn:any,\r\n    params:any,\r\n    setError:any,\r\n}\r\n\r\nconst PhotoSendSection: React.FC<ImgProps> = ({photoUrl,\r\n                                                  setIsCameraOn,\r\n                                                  params,\r\n                                                  setError,\r\n                                              }) => {\r\n\r\n    const [isFetching, setIsFetching] = useState(false); // Флаг состояния загрузки\r\n\r\n    const handleSendPhoto = () => {\r\n        const tg: any = 'Telegram' in window ? window.Telegram : undefined;\r\n        if (params?.type === 'registration') {\r\n            // Логика для регистрации\r\n            if (tg) {\r\n\r\n\r\n                if (!photoUrl) {\r\n                    setError(\"Фото не сделано! Попробуйте снова.\");\r\n                    return;\r\n                }\r\n\r\n                const blob = base64ToBlob(photoUrl, \"image/jpeg\");\r\n\r\n                // Создаем formData для отправки медиа\r\n                const formData = new FormData();\r\n\r\n                const data: FormDataRegistration = {\r\n                    userPhone: params?.userPhone ?? '',\r\n                    userId: params?.userId ?? '',\r\n                    isSavePhoto: params?.isSavePhoto ?? '0',\r\n                    photo: blob\r\n                }\r\n\r\n                formData.append('userPhone', data.userPhone);\r\n                formData.append('userId', data.userId);\r\n                formData.append('photo', data.photo);\r\n                formData.append('isSavePhoto', data.isSavePhoto);\r\n\r\n                setIsFetching(true)\r\n\r\n                registration(\r\n                    formData,\r\n                    setIsFetching,\r\n                    setError,\r\n                )\r\n            } else {\r\n\r\n                setError(\"Приложение было открыто НЕ в Телеграмме\");\r\n            }\r\n        } else if (params?.type === 'identification') {\r\n            // Логика для идентификации\r\n            if (tg) {\r\n\r\n                if (!photoUrl) {\r\n                    setError(\"Фото не сделано! Попробуйте снова.\");\r\n                    return;\r\n                }\r\n\r\n                const blob = base64ToBlob(photoUrl, \"image/jpeg\");\r\n\r\n                const formData = new FormData();\r\n\r\n                const data: FormDataCheckExist = {\r\n                    userId: params?.userId ?? '',\r\n                    photo: blob\r\n                }\r\n\r\n                formData.append('userId', data.userId);\r\n                formData.append('photo', data.photo);\r\n\r\n                setIsFetching(true)\r\n\r\n                identification(\r\n                    formData,\r\n                    setIsFetching,\r\n                    setError,\r\n                )\r\n            } else {\r\n                setError(\"Приложение было открыто НЕ в Телеграмме\");\r\n            }\r\n        }\r\n    };\r\n\r\n    if (!photoUrl) {\r\n        return <></>\r\n    }\r\n    return (\r\n        <VStack\r\n            max\r\n            gap={'15'}\r\n        >\r\n        <div\r\n            className={`img_box`}\r\n        >\r\n            <img\r\n                className=\"img\"\r\n                src={photoUrl ?? ''}\r\n                alt=\"Сделанное фото\"\r\n            />\r\n        </div>\r\n            <Button\r\n                width={'calc(100% - 20px)'}\r\n                onClick={()=>setIsCameraOn(true)}\r\n                text={REMAKE_PHOTO}\r\n                disabled={isFetching}\r\n            />\r\n            <Button\r\n                width={'calc(100% - 20px)'}\r\n                onClick={handleSendPhoto}\r\n                text={SEND}\r\n                disabled={isFetching}\r\n            />\r\n\r\n\r\n        </VStack>\r\n    );\r\n};\r\nexport default PhotoSendSection\r\n","import axios from 'axios';\r\nimport {InterfaceResponse, Telegram} from \"../../types/type\";\r\n\r\n// Берем URL API из переменной окружения\r\nconst URL = process.env.REACT_APP_API_URL\r\n\r\n// Определяем интерфейс для данных, которые мы добавляем в FormData\r\nexport interface FormDataCheckExist {\r\n    userId: string;\r\n    photo: Blob\r\n}\r\n\r\n// Тип, который перечисляет все возможные значения для поля text\r\ntype IdentificationResponseText =\r\n    | \"missing_photo\"  // Ошибка: нет фото\r\n    | \"missing_user_id\"  // Ошибка: нет userId\r\n    | \"face_not_found\"  // Ошибка: лицо не найдено на изображении\r\n    | \"embedding_not_found\"  // Ошибка: эмбеддинг не найден в базе\r\n    | \"similarity_not_confirmed\"  // Ошибка: сходство не подтверждено\r\n    | \"success\"  // Успех: верификация прошла успешно\r\n    | \"server_error\";  // Ошибка сервера\r\n\r\n// Интерфейс для ответа от сервера\r\ntype IdentificationResponse = InterfaceResponse<IdentificationResponseText>;\r\n\r\nexport const identification = (\r\n    data: FormData,// Данные для идентификации\r\n    setIsFetching: (val: boolean) => void, // Функция для управления состоянием загрузки\r\n    setError: (error: string | null) => void,// Функция для отображения ошибок\r\n) => {\r\n    const tg: Telegram | undefined = 'Telegram' in window ? window.Telegram as Telegram : undefined;\r\n    if (tg) {\r\n        axios\r\n            .post<IdentificationResponse>(`${URL}api/embeddings/identification`, data)\r\n            .then(res => {\r\n                // Завершаем загрузку\r\n                setIsFetching(false);\r\n                const result = res.data;\r\n\r\n                // Обрабатываем ответ от сервера\r\n                // Обрабатываем ответ от сервера\r\n                switch (result.status) {\r\n                    case 0: // Эмбеддинг для пользователя не найден в базе ИЛИ найден, но не совпал\r\n                    case 1: // Успешно пройдена\r\n                        tg.WebApp.sendData(JSON.stringify(result));\r\n                        break;\r\n\r\n                    case 2: // Ошибки валидации или системная ошибка\r\n                        setError('Попробуйте еще раз.'); // Устанавливаем текст ошибки для отображения\r\n                        break;\r\n\r\n                    default: // Непредвиденный статус\r\n                        setError(\"Ошибка. Пожалуйста, попробуйте позже.\");\r\n                        console.warn(\"Unexpected response:\", result);\r\n                        break;\r\n                }\r\n\r\n            })\r\n            .catch(err => {\r\n                setIsFetching(false);// Завершаем загрузку\r\n\r\n                let response: IdentificationResponse\r\n                // Проверяем, есть ли ответ от сервера\r\n                if (err.response) {\r\n                    response = err.response.data as IdentificationResponse;\r\n                    tg.WebApp.sendData(JSON.stringify(response)); // Отправляем данные из ответа\r\n                } else {\r\n                    // Общая ошибка (например, сеть недоступна)\r\n                    response = {status: 2, text: \"server_error\"}\r\n                    tg.WebApp.sendData(JSON.stringify(response));\r\n                }\r\n            })\r\n    }\r\n}\r\n","import React, {useState} from \"react\";\r\nimport {IDENTIFICATION, IS_CAMERA_OFF, ON_CAMERA, PLEASE_ON_CAMERA} from \"../../types/const\";\r\nimport {VStack} from \"../../shared/ui/VStack/VStack\";\r\nimport {ReactComponent as CameraSvg} from '../../shared/assets/svg/Camea.svg'\r\nimport {ReactComponent as ArrowSvg} from '../../shared/assets/svg/Arrow.svg'\r\nimport {CommonSection} from \"../../shared/ui/CommonSection/CommonSection\";\r\nimport {Section} from \"../../shared/ui/Section/Section\";\r\nimport {Text} from \"../../shared/ui/Text/Text\";\r\nimport {HStack} from \"../../shared/ui/HStack/HStack\";\r\nimport {Svg} from \"../../shared/ui/Svg/Svg\";\r\nimport CameraSection from \"../CameraSection/CameraSection\";\r\nimport PhotoSendSection from \"../PhotoSendSection/PhotoSendSection\";\r\nimport {ParamsType} from \"../../types/type\";\r\n\r\n\r\nconst Photo: React.FC<ParamsType> = (params) => {\r\n\r\n    const [photoUrl, setPhotoUrl] = useState<string | null>(null); // URL фото\r\n    const [log, setLog] = useState<string | null>(null);// Сообщение об ошибке\r\n    const [isCameraOn, setIsCameraOn] = useState(false);// Состояние, показывающее включена ли камера\r\n\r\n\r\n    return (\r\n        <>\r\n            <CommonSection\r\n                max\r\n                isHide={!(!photoUrl && !isCameraOn)}\r\n            >\r\n                <Section>\r\n                    <Text\r\n                        text={IDENTIFICATION}\r\n                        type={'hint'}\r\n                        align={'start'}\r\n                        max\r\n                    />\r\n                    <VStack\r\n                        gap={'15'}\r\n                        style={{padding: '56px 78px'}}\r\n                    >\r\n                        <tgs-player\r\n                            style={{\r\n                                width: '130px',\r\n                                height: '130px'\r\n                            }}\r\n                            width={'200px'}\r\n                            autoplay={true}\r\n                            loop={true}\r\n                            mode=\"normal\"\r\n                            src=\"https://data.chpic.su/stickers/u/UtyaDuck/UtyaDuck_005.tgs\"\r\n                            id=\"tgsPlayer__main__UtyaDuck\"\r\n                        >\r\n\r\n                        </tgs-player>\r\n                        <Text\r\n                            text={IS_CAMERA_OFF}\r\n                            type={'text'}\r\n                            align={'center'}\r\n                            size={'l'}\r\n                            max\r\n                        />\r\n                        <Text\r\n                            text={PLEASE_ON_CAMERA}\r\n                            type={'text'}\r\n                            align={'center'}\r\n                            max\r\n                        />\r\n\r\n                    </VStack>\r\n                </Section>\r\n\r\n                <Section clickable max onClick={() => setIsCameraOn(true)}>\r\n                    <HStack gap={'10'} max>\r\n                        <Svg Svg={CameraSvg}/>\r\n                        <Text\r\n                            text={ON_CAMERA}\r\n                            type={'text'}\r\n                            max\r\n                        />\r\n                        <Svg width={'12px'} height={'12px'} color={'subtitle'} Svg={ArrowSvg}/>\r\n                    </HStack>\r\n\r\n                </Section>\r\n\r\n            </CommonSection>\r\n\r\n            {isCameraOn &&\r\n                <CameraSection\r\n                    log={log}\r\n                    setLog={setLog}\r\n                    setPhotoUrl={setPhotoUrl}\r\n                    setIsCameraOn={setIsCameraOn}\r\n                    isCameraOn={isCameraOn}\r\n                />\r\n\r\n            }\r\n            {!isCameraOn && photoUrl && (\r\n                <PhotoSendSection\r\n                    photoUrl={photoUrl}\r\n                    params={params}\r\n                    setIsCameraOn={setIsCameraOn}\r\n                    setError={setLog}\r\n                />\r\n\r\n            )\r\n\r\n            }\r\n        </>\r\n    )\r\n\r\n};\r\nexport default Photo\r\n","import React from \"react\";\r\nimport './CommonSection.css'\r\nimport {classNames, Mods} from \"../../../lib/classNames/classNames\";\r\n\r\ninterface SectionProps {\r\n    children: any,\r\n    max?:boolean\r\n    isHide?:boolean\r\n}\r\n\r\nexport const CommonSection: React.FC<SectionProps> = (props) => {\r\n    const {\r\n        children,\r\n        max,\r\n        isHide = false,\r\n    } = props\r\n\r\n\r\n    const mods: Mods = {\r\n        'max': max,\r\n        'hide': isHide,\r\n    };\r\n\r\n    return (\r\n        <div\r\n            className={classNames('common_section', mods, [])}\r\n        >\r\n            {children}\r\n        </div>\r\n    );\r\n};\r\n","import { DetailedHTMLProps, HTMLAttributes, ReactNode } from 'react';\r\nimport './HStack.css'\r\nimport {classNames, Mods} from \"../../../lib/classNames/classNames\";\r\n\r\nexport type FlexJustify = 'start' | 'center' | 'end' | 'between' | 'around';\r\nexport type FlexAlign = 'start' | 'center' | 'end';\r\nexport type FlexWrap = 'nowrap' | 'wrap';\r\nexport type FlexGap = '5' | '10' | '15' | '25' | '30';\r\n\r\nconst justifyClasses: Record<FlexJustify, string> = {\r\n    start: 'justifyStart',\r\n    center: 'justifyCenter',\r\n    end: 'justifyEnd',\r\n    between: 'justifyBetween',\r\n    around: 'justifyAround',\r\n};\r\n\r\nconst alignClasses: Record<FlexAlign, string> = {\r\n    start: 'alignStart',\r\n    center: 'alignCenter',\r\n    end: 'alignEnd',\r\n};\r\n\r\n\r\n\r\nconst gapClasses: Record<FlexGap, string> = {\r\n    5: 'gap5',\r\n    10: 'gap10',\r\n    15: 'gap15',\r\n    25: 'gap25',\r\n    30: 'gap30',\r\n};\r\n\r\ntype DivProps = DetailedHTMLProps<\r\n    HTMLAttributes<HTMLDivElement>,\r\n    HTMLDivElement\r\n>;\r\n\r\nexport interface FlexProps extends DivProps {\r\n    className?: string;\r\n    children: ReactNode;\r\n    justify?: FlexJustify;\r\n    align?: FlexAlign;\r\n    wrap?: FlexWrap;\r\n    gap?: FlexGap;\r\n    max?: boolean;\r\n}\r\n\r\nexport const HStack = (props: FlexProps) => {\r\n    const {\r\n        className,\r\n        children,\r\n        justify = 'start',\r\n        align = 'center',\r\n        wrap = 'nowrap',\r\n        gap,\r\n        max,\r\n        ...otherProps\r\n    } = props;\r\n\r\n    const classes = [\r\n        className,\r\n        justifyClasses[justify],\r\n        alignClasses[align],\r\n        wrap,\r\n        gap && gapClasses[gap],\r\n    ];\r\n\r\n    const mods: Mods = {\r\n        'max': max,\r\n    };\r\n\r\n    return (\r\n        <div className={classNames('HStack', mods, classes)} {...otherProps}>\r\n            {children}\r\n        </div>\r\n    );\r\n};\r\n","import React, { forwardRef } from \"react\";\r\nimport './Section.css';\r\nimport { classNames, Mods } from \"../../../lib/classNames/classNames\";\r\n\r\ninterface SectionProps {\r\n    children: any;\r\n    className?: string;\r\n    clickable?: boolean;\r\n    disabled?: boolean;\r\n    max?: boolean;\r\n    onClick?: () => void;\r\n}\r\n\r\n// Используем forwardRef для передачи ref внутрь компонента\r\nexport const Section = forwardRef<HTMLDivElement, SectionProps>((props, ref) => {\r\n    const {\r\n        children,\r\n        className,\r\n        clickable,\r\n        disabled,\r\n        onClick = () => {},\r\n        max,\r\n    } = props;\r\n\r\n    const mods: Mods = {\r\n        'max': max,\r\n        'clickable': clickable,\r\n        'disabled': disabled,\r\n    };\r\n\r\n    return (\r\n        <div\r\n            ref={ref as React.Ref<HTMLDivElement>}\r\n            className={classNames('section', mods, [className])}\r\n            onClick={onClick}\r\n        >\r\n            {children}\r\n        </div>\r\n    );\r\n});\r\n","import React, { memo } from 'react';\r\nimport './Svg.css';\r\nimport {classNames, Mods} from \"../../../lib/classNames/classNames\";\r\n\r\n\r\ninterface SvgProps {\r\n    width?:string,\r\n    height?:string,\r\n    Svg: React.VFC<React.SVGProps<SVGSVGElement>>;\r\n    color?:'accent'| 'subtitle'\r\n}\r\n\r\nexport const Svg = memo((props: SvgProps) => {\r\n    const {\r\n        Svg,\r\n        width = '46px',\r\n        height = '46px',\r\n        color='accent',\r\n    } = props;\r\n\r\n    const mods: Mods = {\r\n    };\r\n\r\n    return (\r\n        <div\r\n            style={{\r\n                width: width,\r\n                height: height,\r\n            }}\r\n            className={classNames('SvgContainer', mods, [color])}\r\n        >\r\n            <Svg\r\n                className='Svg'\r\n                width={width}\r\n                height={height}\r\n            />\r\n        </div>\r\n\r\n    );\r\n});\r\n","import React from \"react\";\r\nimport './Text.css'\r\nimport {classNames, Mods} from \"../../../lib/classNames/classNames\";\r\n\r\nexport type FlexSize = 's' | 'm' | 'l'\r\n\r\nconst sizeClasses: Record<FlexSize, string> = {\r\n    s: 'size_s',\r\n    m: 'size_m',\r\n    l: 'size_l',\r\n};\r\n\r\ninterface TextProps {\r\n    text: string;\r\n    type: 'hint' | 'text',\r\n\r\n    className?: string;\r\n    align?: 'center' | 'start',\r\n    size?: FlexSize;\r\n    max?: boolean,\r\n}\r\n\r\nexport const Text: React.FC<TextProps> = (props) => {\r\n    const {\r\n        text,\r\n        type,\r\n\r\n        className,\r\n        align='start',\r\n        size='m',\r\n        max,\r\n\r\n    } = props\r\n\r\n    const classes = [\r\n        type,\r\n        className,\r\n        sizeClasses[size],\r\n        align,\r\n\r\n    ]\r\n    const mods: Mods = {\r\n        'max': max,\r\n    };\r\n\r\n    return (\r\n        <div\r\n            className={classNames('text_box', mods, classes)}\r\n        >\r\n            {text}\r\n        </div>\r\n\r\n    );\r\n};\r\n","export const IDENTIFICATION = 'Идентификация'\r\nexport const GEOLOCATION = 'Геолокация'\r\n\r\nexport const ON_CAMERA = 'Включить камеру'\r\nexport const IS_CAMERA_OFF = 'Камера выключена'\r\nexport const PLEASE_ON_CAMERA = 'Нажмите на кнопку ниже и разрешите доступ к камере'\r\n\r\nexport const SEND_GEOLOCATION = 'Отправьте геолокациию'\r\nexport const PLEASE_SEND_GEOLOCATION = 'Нажмите на кнопку ниже для отправки геолокации'\r\nexport const SEND_GEOLOCATION_BTN = 'Отправить геолокацию'\r\n\r\n\r\nexport const CAMERA_DESC = 'Пройдите фотоконтроль для идентификации. На фото должно быть отчетливо видно ваше лицо'\r\nexport const TAKE_PHOTO = 'Сделать фото'\r\n\r\n\r\nexport const REMAKE_PHOTO = 'Переснять фото'\r\nexport const SEND = 'Отправить фото'\r\n","var _path;\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nimport * as React from \"react\";\nfunction SvgArrow(_ref, svgRef) {\n  let {\n    title,\n    titleId,\n    ...props\n  } = _ref;\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 7,\n    height: 12,\n    fill: \"none\",\n    viewBox: \"0 0 7 12\",\n    className: \"p_ZQ v61B\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 2,\n    d: \"m1 1 5 5-5 5\"\n  })));\n}\nconst ForwardRef = /*#__PURE__*/React.forwardRef(SvgArrow);\nexport default __webpack_public_path__ + \"static/media/Arrow.cb0a50c25f777dde5217b7f02c5409b3.svg\";\nexport { ForwardRef as ReactComponent };"],"names":["_g","_extends","Object","assign","bind","n","e","arguments","length","t","r","hasOwnProperty","call","apply","SvgCamea","_ref","svgRef","title","titleId","props","fill","height","width","id","xmlns","xmlnsXlink","viewBox","xmlSpace","ref","d","ForwardRef","isRectangleCoveredByCircle","circle","rect","threshold","undefined","rectArea","Math","PI","intersectionArea","cx","cy","x","y","step","min","px","py","dx","dy","calculateIntersectionArea","overlapRatio","rectCenterX","rectCenterY","distanceSquared","isCenterInsideCircle","isCenterWithinSmallRadius","config","modelBasePath","face","enabled","detector","rotation","maxDetected","minConfidence","mesh","iris","description","emotion","body","hand","gesture","backend","cacheSensitivity","useFaceDetection","isCameraOn","videoRef","canvasRef","videoBorderRef","isLoaded","setLog","isFaceDetected","setIsFaceDetected","useState","humanLoaded","setHumanLoaded","detectionStart","setDetectionStart","humanInstance","setHumanInstance","isDraw","useEffect","async","console","log","Date","toISOString","human","Human","load","warmup","error","initHuman","animationFrameId","lastDetectionTime","new_log","Boolean","current","i","detectFace","now","video","canvas","video_border","displaySize","offsetWidth","offsetHeight","inputSize","videoWidth","videoHeight","faces","detect","resizedFaces","results","inputDimensions","targetDimensions","modelInputSize","videoAspectRatio","modelWidth","modelHeight","scaleXModel","scaleYModel","scaleXCanvas","scaleYCanvas","scaleFaceResult","box","modelX","modelY","modelWidthScaled","modelHeightScaled","Array","isArray","map","resizeResults","ctx","getContext","clearRect","clientWidth","clientHeight","faceDetected","forEach","transformedX","lineWidth","lineCap","lineJoin","strokeStyle","strokeRect","beginPath","arc","fillStyle","stroke","requestAnimationFrame","setPhotoUrl","setIsCameraOn","setIsLoaded","useRef","streamRef","stream","navigator","mediaDevices","getUserMedia","facingMode","srcObject","addEventListener","play","catch","err","toLocaleTimeString","once","warn","startVideo","getTracks","track","stop","_jsxs","CommonSection","max","children","Section","className","_jsx","playsInline","muted","controls","HStack","Text","text","CAMERA_DESC","type","clickable","onClick","takePhoto","context","drawImage","toDataURL","disabled","gap","Svg","CameraSvg","TAKE_PHOTO","color","ArrowSvg","Button","mods","style","classNames","base64ToBlob","base64","mimeType","byteString","atob","split","arrayBuffer","ArrayBuffer","uint8Array","Uint8Array","charCodeAt","Blob","photoUrl","params","setError","isFetching","setIsFetching","VStack","src","alt","REMAKE_PHOTO","handleSendPhoto","tg","window","Telegram","_params$userPhone","_params$userId","_params$isSavePhoto","blob","formData","FormData","data","userPhone","userId","isSavePhoto","photo","append","registration","axios","post","then","res","result","status","WebApp","sendData","JSON","stringify","_params$userId2","identification","response","SEND","_Fragment","isHide","IDENTIFICATION","align","padding","autoplay","loop","mode","IS_CAMERA_OFF","size","PLEASE_ON_CAMERA","ON_CAMERA","CameraSection","PhotoSendSection","justifyClasses","start","center","end","between","around","alignClasses","gapClasses","justify","wrap","otherProps","classes","forwardRef","memo","sizeClasses","s","m","l","GEOLOCATION","SEND_GEOLOCATION","PLEASE_SEND_GEOLOCATION","SEND_GEOLOCATION_BTN","_path","SvgArrow","strokeLinecap","strokeLinejoin","strokeWidth"],"sourceRoot":""}